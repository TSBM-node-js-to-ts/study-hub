### Ch1 노드 시작하기


# 핵심 개념 이해하기

<aside>

Node.jssms 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임입니다. 
</aside>


**서버** : 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말함

**런타임** : 특정 언어로 만든 프로그램들을 실행할 수 있는 환경

**libuv라이브러리** : 노드의 특성인 이벤트 기반, 논블로킹I/O모델을 구현하고 있음

📌 번과 디노도 좀 눈여겨보면 좋을 JS런타임… 

## 이벤트 기반

→ 이벤트(클릭, 네트워크 요청 등)가 발생할 때 미리 지정해둔 작업을 수행하는 방식 

### 순서

1. 이벤트 리스너에 콜백함수 등록 - 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두는 것
2. 이벤트 발생
3. 등록된 콜백 함수 호출
4. 발생한 이벤트가 없거나 발생한 이벤트를 다 처리하면 노드는 다음 이벤트까지 대기함

### 이벤트 루프 / 백그라운드 / 태스크 큐

📌 ***이벤트 루프***

- 이벤트 발생 시 호풀할 콜백함수들을 관리하고, 호출된 콜백삼수의 실행순서를 결정함
- 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복함
- 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 함수를 호출스택으로 가져옴 → 즉, 호출스택에 함수가 너무 많이 들어있으면 setTimeout(run, 3000)에서 3초가 지나 태스크큐에 run함수가 있다 하더라도 이벤트 루프는 호출스택에 run함수를 넣지 않음

📌 ***백그라운드***

- setTimeout같은 타이머나 이벤트 리스너들이 대기하는 곳
- 여러 작업이 동시에 실행될 수도 있음

📌 ***태스크 큐***

- 이벤트 발생 후, 백그라운드에선 태스크 큐로 타이머나 이벤트 리스너의 콜백함수들을 보냄

## 논블로킹 I/O

I/O작업 예시 : 파일 시스템 접근(파일 읽기 및 쓰기, 폴더 만들기 등), 네트워크를 통한 요청 등

논블로킹 : 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것 → JS에서는 I/O작업 같은 것이 동시처리가 가능함

블로킹 : 이전 작업이 끝나야만 다음 작업을 수행함

`setTimeout(콜백, 0)` : 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나

🧐 0ms면 바로 실행되는 거 아닌가요? : 아님, 브라우저와 노드 사이엔 기본적인 지연시간이 있기 때문에 바로 실행되지 않음

# 서버로써의 노드

### 장점

- JSON형식과 쉽게 호환됨
- I/O작업이 많은 서버로 적합
- 웹서버 내장

### 단점

- CPU작업이 많은 서버로는 부적합
- 하나뿐인 스레드가 멈추지 않도록 관리가 필요함
- 서버 규모가 커졌을 때 서버를 관리하기가 어려움

# 개발환경 설정하기

### node와 npm 설정

`node -v` 명령어 입력 → v22.19.0

`npm -v`명령어 입력 → 10.9.3

### vscode 설치
![alt text](image.png)

# 🧐 질문
1. 본문에서 libuv가 이벤트 기반, 논블로킹 I/O를 구현한다고 했는데, 그렇다면 libuv와 이벤트 루프는 정확히 어떤 관계인 걸까?
2. 서버 규모가 커졌을 때 관리가 어려운 이유는 구체적으로 무엇일까? - 막연히 '관리가 어렵다'고 되어 있는데 정확히 어떤 부분에서 관리가 어려워지는 걸까?
3. 번과 디노는 왜 등장하게 된 거지? Node.js의 어떤 부분을 보완하기 위해 나온 걸까?

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

![alt text](image-2.png)


### Ch2 알아둬야 할 자바스크립트
# ES2015+

## const, let

📌스코프 : 변수의 유효 범위 또는 변수가 살아 숨쉴수 있는 영역

**var** : 함수 스코프 → 블록의 범위와 관계 없이 사용할 수 있음

**const, let** : 블록 스코프 → 블록(중괄호 안)안에서만 쓸 수 있음

| 변수명 | 설명 |
| --- | --- |
| const | 한 번 값을 할당하면 재할당 불가능 |
| let | 한 번 값을 할당해도 재할당 가능 |

```jsx
if(true){
	var x = 3;
}
console.log(x); //이러면 3이 출력됨 

if(true){
	const y = 3;
}
console.log(y); //const, let은 블록 스코프라서 y는 출력이 안됨ㅠ

```

## 템플릿 문자열

→ 백틱을 이용해 더하기 기호 없이도 문자열 안에 변수를 넣을 수 있음

형식 : ``${변수}``

```jsx
const num3 =1;
const num4 = 2;
const result2 = 3;
const string2 = `${num3} 더하기 ${num4}는 '${result2}'`;
console.log(string2); //출력값 : 1 더하기 2는 '3'
```

## 객체 리터럴

→  객체를 정의할 때 속성명과 변수명이 동일한 경우엔 한 번만 써도 가능하도록 함

- 원래 `{name : name, age : age}`로 써야했던 걸 `{name, age}`로 써도 되도록

📌 코드의 중복을 피할 수 있어 편리함

📌 익숙해진다면 코드의 양을 많이 줄일 수 있음…

## 화살표 함수

→ function선언을 하는 대신 =>기호로 함수를 선언함

```jsx
function add1(x, y){
	return x+y;
} //기존 방식
```

```jsx
//화살
const add2 = (x,y)=>{
	return x+y;
};

const add3 = (x,y)=>x+y;
const add4 = (x,y)=>(x + y);
```

이때 함수 내부에 return문밖에 없을 땐 중괄호를 생략하고 add3, add4처럼 return할 식을 바로 적으면 된다

### 추가

```jsx
const relationship2 = {
	name : 'zero',
	friends: ['nero', 'hero', 'xero'],
	logFriends(){
		this.friends.forEach(friend=>{
			console.log(this.name, friend);	
		});
	},
};
relationship2.logFriends();
```

→ **화살표 함수를 사용함으로써** relationship2 안의 logFriends() 안에 따로 var that = this; 같은 줄을 사용해서 간접적으로 접근할 필요없이 **상위스코프의 this를 그대로 물려받을 수 있게 됨**

## 구조 분해 할당

- 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JS 표현식
- 객체와 배열로부터 속성/요소를 쉽게 꺼낼 수 있다!!
- 구조분해할당 방식을 이용하면 코드가 더 간결하고 가독성이 좋아짐…

```jsx
function printMovie({ title, director }) {
  console.log(`Title: ${title}, Director: ${director}`);
}

const movie = {
  title: "Inception",
  director: "Christopher Nolan",
  year: 2010
};

printMovie(movie);
```

→ 요런 식으로 하게 되면 printMovie()함수는 movie객체에서 title과 director값만을 추출해서 사용할 수 있게 됨

### 배열에 대한 구조분해할당은?

기존의 방식을 사용했다면 

```jsx
var array = [‘nodejs’, {}, 10, true];
var node = array[0];
var obj = array[1];
var bool = array[3];
```

상기 작성된 코드를 보면 알 수 있듯 요소를 변수에 대입하기 위해 작성하는 코드가 너무 길고 좀 읽기 불편함 

```jsx
const array = [‘nodejs’, {}, 10, true];
const [node, obj, , bool] = array;
```

근데 이런 식의 구조분해할당을 쓰게 되면 간결하게 요소를 변수에 대입해줄 수 있다. 

📌 nodejs를 node에 {}를 obj에 넣는 식…

📌 10에 해당하는 위치엔 변수명을 지어주지 않았기 때문에 무시함

## 클래스

*프로토타입 기반 문법을 보기 편하도록 클래스로 바꾼 느낌*

<aside>

### 프로토타입 기반이란?

클래스 기반 방식 같은 경우엔 애초의 틀(클래스)을 만들어두고 필요할 때마다 이제 그 틀을 기반으로 객체를 만들어내는 식이라면 프로토타입 같은 경우엔 아예 원본을 하나 만들고(틀이 없음) 새로운 게 필요하면 그 원본을 복제(정확히는 좀 더 참조의 느낌)해서 만들어내는 방느낌임. 그래서 새로 만들어진 것은 원본의 특징을 그대로 물려받게 됨. 

```jsx
// 1. 원본(프로토타입 객체)을 만듦
const robotPrototype = {
  material: 'steel',
  speak: function() {
    console.log(`I am a robot made of ${this.material}.`);
  }
};

// 2. 원본을 기반으로 새로운 객체를 만듦
// Object.create()는 지정된 프로토타입 객체를 갖는 새 객체를 만듦
const siri = Object.create(robotPrototype);
siri.name = 'Siri'; // siri만의 고유한 속성을 추가함

siri.speak(); // 출력: "I am a robot made of steel."
```

</aside>

근데 이런 식의 프로토타입 기반 방식으로 쓰여진 걸 좀 편하게 클래스처럼 보이게 쓸 순 없나?해서 나온 게 클래스 문법…  

```jsx
// 클래스를 정의합니다.
class Robot {
  constructor() {
    this.material = 'steel';
  }

  speak() {
    console.log(`I am a robot made of ${this.material}.`);
  }
}

// 새로운 객체를 만듦
const bixby = new Robot();
bixby.name = 'Bixby';

bixby.speak(); // I am a robot made of steel.
```

이런 식으로 코드를 작성하면 내용은 똑같지만 좀 더 직관적인 방식으로 코드를 작성할 수 있게 됨

## 프로미스

- 콜백지옥과 같은 단점을 보완하고자 **비동기 처리 전용 객체**로 등장하게 됨
- 웹 페이지에서 서버로 데이터를 요청했을 때, 데이터를 모두 받기 전에 웹에 출력하려고 하는 경우를 방지하기 위해 활용됨

## **Promise의 상태**

| 상태 | 설명 |
| --- | --- |
| Pending(대기) | 비동기 로직 처리의 미완료 상태 |
| Fulfilled(이행) | 비동기 로직 처리가 완료된 상태로 Promise 결과값 반환 상태 |
| Rejected(실패) | 비동기 로적 처리의 실패 또는 오류 상태 |

→ 비동기 작업의 성공과 실패 그리고 그 결과값을 나타내는 객체로서, 이를 사용해 비동기 작업을 쉽고 깔끔하게 할 수 있음

### **Pending**

```jsx
new Promise();

new Promise((resolve, reject) => {});

```

→ 생성된 promise객체는 일단 대기상태. 이때 인자로는 resolve와 reject를 가지게 됨

### **Fulfilled**

```jsx
// resolve()를 통해 Promise 실행
function getData(){
    return new Promise( (resolve, reject) => {
      let data = 10;
      resolve(data);
    })
  }

getData().then((resolvedData) => console.log(resolvedData));

```

- resolve에 parameter를 넣어주면 Promise가 이행상태로 넘어감
- then()을 이용해 결과값을 받음

### **Rejected**

```jsx
//reject를 호출해 고의적 실패로 연결
function getData(){
    return new Promise( (resolve, reject) => {
      reject(new Error("This is rejected!"));
    })
  }

getData().catch((err) => console.log(err));

```

- Promise 객체인 reject인자는 호출 시 실패 상태가 됨
- 이후 catch()를 활용하면 결과값을 받고 예외를 확인할 수 있음

## **Promise의 문제점**

가독성이 떨어짐

(promise를 then과 catch로 계속 연결하다보니…)

## async/awair

callback이나 promise의 문제(결국 가독성)를 해결하기 위해 ES7에서 추가된 문법

- async/await를 사용하면 비동기 코드를 동기 코드처럼 보이게 사용할 수 있음
    - async : 걍 함수 앞에 이거 붙이면 비동기 함수가 됨 / 그럼 async()가 Fulfiled Promise를 반환하게 됨
    - await : 결과값을 얻을 때까지 기다림 / 비동기 함수 왼쪽에 await만 명시 해주고 결과 값을 변수에 받도록 해서 사용하면 됨 / async로 선언된 함수 안에서만 await키워드를 쓸 수 있음

```jsx
const fetchData = async () => {
    try {
        const response = await asyncFunc()
        console.log(response)
    } catch (err) {
        console.log(err)
    }
}

```

→ asyncFunc함수의 실행결과가 반환되어 result에 할당되기 전까지 await키워드가 console.log 함수의 실행을 지연시킴

## Map/Set

참고 : https://velog.io/@merkyuri/Javascript-Map-Set

→ 객체와 배열만으로 해결하기 힘든 부분을 위해 등장하게 됨

**Map** : 객체와 유사

**Set** : 배열과 유사

### Map

- 속성들 간의 순서를 보장함
- 반복문을 사용할 수 있음
- 속성명으로 값도 사용가능함
- size메서드를 이용해 속성의 수를 쉽게 알 수 있음(검색속도가 빠름)

```jsx
new Map() // map을 만든다
map.set(key, value) // key를 이용해 value를 저장한다
map.get(key) // key에 해당하는 값 반환. key가 존재하지 않다면 undefined를 반환
map.has(key) // key가 존재하면 true, 아니면 false를 반환
map.delete(key) // key에 해당하는 값 삭제
map.clear() // map 안의 모든 요소 제거
map.size // 요소의 개수 반환

map.keys() // 각 요소의 키를 모아둔 iterable 객체를 반환
map.values() // 각 요소의 값을 모은 iterable 객체를 반환
map.entries() // 요소의 [key, value] 한 쌍으로 하는 iterable 객체 반환. 이 객체는 for...of 루프의 기초로 쓰인다
```

### Set

- **중복허용X** → 배열 자료구조를 쓰고는 싶은데 중복허용은 안 하고 싶을 때 사용하면 됨 OR 기존 배열에서 중복을 제거하고 싶을 때도…

```jsx
const arr = [1,2,2,3,4,5];

const s = new Set(arr); //set은 중복허용을 안 하니까 여기서 중복된 2들이 없어짐
cosnt result = Array.from(2);
console.log(result); //이러면 이제 결과가 1,2,3,4,5로 나옴
```

📌 Set을 다시 배열로 돌리고 싶다면 `Array.from(Set)`하면 됨

- 주요 메서드

```jsx
new Set(iterable) // set을 만든다. iterable 객체를 전달받으면(대게 배열) 그 안의 값을 복사해서 set에 넣어준다
set.add(value) // value를 추가하고 set 자신을 반환
set.delete(value) // value 제거. 호출 시점에 set 내에 value가 있어서 제거에 성공하면 true, 아니라면 false를 반환
set.has(value) // set 내에 값이 존재하면 true, 아니면 false
set.clear() // set 비우기
set.size // set에 몇 개의 값이 있는지 count

set.keys() // set 내의 모든 값을 포함하는 iterable 객체 반환
set.values() // set.keys와 동일한 작업을 한다. map과의 호환성을 위해 만들어진 메서드
set.entries() // set 내의 각 값을 이용해서 만든 [value, value] 배열을 포함하는 iterable 객체 반환. map과의 호환성을 위해 만들어졌다
```

## 널 병합/옵셔널 체이닝

ES2020에서 추가됨

널 병합 : `??`

옵셔널 체이닝 : `?.`

### 널 병합

- `||`연산자 대용으로 사용됨
    
    
    | 연산자 | 차이 |
    | --- | --- |
    | || | 첫 번째 truthy값을 반환함 |
    | ?? | 첫 번째 정의된defined값을 반환함 |
    - null과 undefined, 숫자 0을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 함
    - ?? : falsy값 중 null과 undefined만 따로 구분함
    
    ```jsx
    const a = 0;
    const b = a || 3; // || 연산자는 falsy 값이면 뒤로 넘어감
    console.log(b); // 3
    
    const c = 0;
    const d = c ?? 3; // ?? 연산자는 null과 undefined일 때만 뒤로 넘어감
    console.log(d); // 0;
    
    const e = null;
    const f = e ?? 3;
    console.log(f); // 3;
    
    const g = undefined;
    const h = g ?? 3;
    console.log(h); // 3;
    
    ```
    

📌 truthy / falsy값이란?

- `truthy`는 `true`로 평가되는 값 `falsy`값을 제외한 모든 값
- `falsy`는 `false`로 평가되는 값 : `false`, `null`, `undefined`, `0`, `-0`, `0n`, `NaN`, `""`(빈 문자열)

## 옵셔널 체이닝

- null / undefined의 속성을 조회하는 경우 에러가 발생하는 것을 막음
- JS프로그래밍을 할 때 발생하는 TypeError : Cannot read properties of undefined 또는 null에러의 발생 빈도를 크게 낮출 수 있음
- 대략 있으면 접근하고 아님 말아~ 의 느낌

```jsx
const member = {
  name: 'jinsu',
  address: {}
};

const cityName = member.address?.city;

console.log(cityName); // undefined
```

`const cityName = member.address?.city;` 에서 member 객체의 address 속성에 접근한 다음, 그 안의 city 속성 값을 가져오고자 했는데 옵셔널 체이닝 `?.` 을 써서 `member.address`안에 암것도 없는데도 에러가 안 나고 undefined를 반환함

# 프런트엔드 자바스크립트

## AJAX

- 비동기적 웹 서비스를 개발할 때 사용하는 기법
- 페이지 이동 없이 서버에 요청을 보내고 응답을 받는 기술
- 주로 jQuery나 axios 같은 라이브러리를 이용해서 요청을 보냄
    
    참고: [https://velog.io/@leebini/JQuery와-Axios의-차이](https://velog.io/@leebini/JQuery%EC%99%80-Axios%EC%9D%98-%EC%B0%A8%EC%9D%B4)
    

### 사용방식

```jsx
axios.get('https://www.zerocho.com/api/get')
  .then((result) => {
    console.log(result);
    console.log(result.data); // {}
  })
  .catch((error) => {
    console.error(error);
});
```

- axios.get함수의 매개변수로 요청을 보낼 주소를 넣음
- 이때 axios.get내부에 new Promise가 들어 있으므로 then/catch를 사용할 수 있음

📌 GET요청이면 axios.get를 사용하고 POST요청이면 axios.post를 사용함

## FormData

- HTML from태그를 동적으로 제어할 수 있는 기능(주로 AJAX와 함께 사용)

### 사용방식

1. FormData생성자로 formData객체를 만듦
2. 그리고 다음 코드를 한 줄씩 console에 입력함
    
    ```jsx
    const formData = new FormData(); 
    formData.append('name', 'zerocho'); 
    formData.append('item', 'orange'); 
    formData.append('item', 'melon'); 
    formData.has('item'); // true 
    formData.has('money'); // false; 
    formData.get('item');// orange 
    formData.getAll('item'); // ['orange', 'melon']; 
    formData.append('test', ['hi', 'zero']); 
    formData.get('test'); // hi, zero 
    formData.delete('test'); 
    formData.get('test'); // null 
    formData.set('item', 'apple'); 
    formData.getAll('item'); // ['apple'];
    ```
    
    | 메서드 | 설명 |
    | --- | --- |
    | has | 해당 키가 존재하는지 확인 |
    | get | 해당 키의 첫 번째 값을 가져옴 |
    | getAll | 해당 키의 모든 값을 배열로 가져옴 |
    | delete | 키와 그에 해당하는 값을 삭제 |
    | set | 기존 키의 값을 새로 설정 |
3. 그리고 axios로 폼 데이터를 서버에 보냄 
    
    ```jsx
    (async () => {
      try {
        const formData = new FormData();
        formData.append('name', 'zerocho');
        formData.append('birth', 1994);
        const result = await axios.post('https://www.zerocho.com/api/post/formdata', formData);
        console.log(result);
        console.log(result.data);
      } catch (error) {
        console.error(error);
      }
    })();
    
    ```
    

## encodeURLComponent, decodeURLComponent

- 한글을 처리하기 위해 사용하는 것
- AJAX 요청을 보낼 때 주소에 한글이 포함되는 경우 보통 한글 주소를 이해하지 못함. 근데 이때 encodeURLComponent를 사용해주면 된다

```jsx
(async () => {
  try {
    const result = await axios.get(`https://www.zerocho.com/api/search/**${encodeURIComponent('노드')}**`);
    console.log(result);
    console.log(result.data); // {}
  } catch (error) {
    console.error(error);
  }
})();
//한글주소 부분만 encodeURLComponent메서드로 감싸주면 됨
```

`encodeURIComponent()` 메서드로 한글주소를 감싸주면 → 한글 주소가 어쩌구저쩌구 문자열로 변환됨

그럼 받는 쪽에선 다시 `decodeURLComponent()` 를 이용해서 주소를 받으면 됨 → `decodeURIComponent('%EB%85%B8%EB%93%9C'); // 노드`

## 데이터 속성과 dataset

서버에서 내려보낸 데이터를 프론트엔드의 어디에, 어떤 코드로 넣어야 할지 고민이 된다면…

### 1순위로 **보안**을 생각하기!

HTML5에선 HTML과관련된 데이터를 저장하는 공식적인 방법이 있음 이름하야 **데이터속성*Data Attribute***

```jsx
<ul>
  <li data-id="1" data-user-job="programmer">Zero</li>
  <li data-id="2" data-user-job="designer">Nero</li>
  <li data-id="3" data-user-job="programmer">Hero</li>
  <li data-id="4" data-user-job="ceo">Kero</li>
</ul>

<script>
  console.log(document.querySelector('li').dataset);
  // { id: '1', userJob: 'programmer' }
</script>

```

- 화면엔 보이지 않지만 웹앱 구동에 필요한 데이터들을 넣어둠(data-로 시작하는 것들)
- 나중에 이 데이터들을 사용해 서버에 요청을 보낼 거임

<br/>
<br/>
<br/>
<br/>

![alt text](png3.jpeg)