-----[1주차] 제갈진우 학습 정리-----
# 📖 Node.js 1장: 핵심 개념

이 장은 Node.js가 무엇인지 정의하고, 그 근간을 이루는 네 가지 핵심 개념(런타임, 이벤트 기반, 논블로킹 I/O, 싱글 스레드)을 통해 Node.js의 동작 원리를 이해하는 것을 목표로 합니다.

## 1. Node.js의 정체: 자바스크립트 런타임

- 공식 정의: Node.js는 Chrome V8 엔진으로 만들어진 자바스크립트 런타임(Runtime)입니다.
- 런타임이란?: 특정 언어(여기서는 자바스크립트)를 실행할 수 있는 환경입니다. 즉, Node.js 덕분에 기존에 웹 브라우저 안에서만 동작하던 자바스크립트를 브라우저 밖(서버, 개인 컴퓨터 등)에서도 실행할 수 있게 되었습니다.
- 탄생 배경: 구글이 2008년 공개한 매우 빠른 오픈소스 자바스크립트 엔진인 V8 덕분에 속도 문제가 해결되었고, 이를 기반으로 2009년 라이언 달이 Node.js를 만들었습니다.
- 주요 용도: 가장 흔하게는 네트워크를 통해 클라이언트에게 서비스를 제공하는 서버(Server)를 만드는 데 사용됩니다.

## 2. Node.js의 동작 원리

Node.js는 이벤트 기반(Event-driven) 방식을 통해 싱글 스레드(Single Thread) 환경에서 논블로킹 I/O(Non-blocking I/O)를 효율적으로 처리합니다.

### 🔹 이벤트 기반과 이벤트 루프

Node.js는 '이벤트가 발생하면, 미리 등록해 둔 작업을 처리한다'는 원칙으로 움직입니다. 이 과정은 네 가지 핵심 요소가 함께 동작하며 이루어집니다.

1.  호출 스택 (Call Stack) : 함수의 호출을 순서대로 쌓아놓고 처리하는 공간입니다. (LIFO: 가장 나중에 들어온 함수가 먼저 실행됨)
2.  백그라운드 (Background) : `setTimeout` 같은 타이머나 파일 입출력(I/O) 등 시간이 오래 걸리는 작업을 처리하는 별도의 공간입니다.
3.  태스크 큐 (Task Queue) : 백그라운드에서 완료된 작업의 콜백 함수가 대기하는 줄입니다.
4.  이벤트 루프 (Event Loop) : 호출 스택이 비어 있을 때, 태스크 큐에서 대기 중인 함수를 호출 스택으로 가져와 실행시키는 관리자 역할을 합니다. 이 루프 덕분에 Node.js는 멈추지 않고 계속 작업을 처리할 수 있습니다.

### 🔹 논블로킹 I/O (Non-blocking I/O)

- I/O: 파일 읽기/쓰기, 네트워크 요청처럼 시간이 소요되는 작업을 의미합니다.
- 블로킹 vs 논블로킹:
  - 블로킹: 한 작업이 끝날 때까지 다음 작업이 기다리는 방식.
  - 논블로킹: 한 작업을 시작시키고 기다리지 않고 바로 다음 작업을 처리하는 방식.
- Node.js는 I/O 작업을 백그라운드에 위임하는 논블로킹 방식을 통해, 하나의 스레드만으로도 여러 요청을 효율적으로 처리합니다.

### 🔹 싱글 스레드 (Single Thread)

- 정의: Node.js는 개발자가 직접 제어할 수 있는 메인 스레드가 하나입니다. 이 때문에 우리가 작성한 자바스크립트 코드는 동시에 실행되지 않고 하나씩 처리됩니다.
- 레스토랑 비유: Node.js는 유능한 점원 한 명(싱글 스레드)이 여러 테이블의 주문을 기다리지 않고 계속해서 받고 주방에 전달(논블로킹)하는 효율적인 식당과 같습니다.
- 장점: 적은 자원으로 많은 요청을 처리할 수 있습니다.
- 단점: 점원이 아프면(에러 발생) 식당 전체가 멈추고, 하나의 요리가 너무 복잡하면(CPU 과부하) 전체 처리 속도가 느려집니다.

## 3. 서버로서의 Node.js

위와 같은 특징들 때문에 Node.js 서버는 다음과 같은 장단점을 가집니다.

- 👍 장점

  - I/O 작업에 강함: 실시간 채팅, API 서버 등 데이터 요청이 많고 빠른 응답이 필요한 서비스에 최적화되어 있습니다.
  - 생산성: 웹 프런트엔드와 같은 자바스크립트 언어를 사용하므로 하나의 언어로 전체 서비스를 개발할 수 있습니다.
  - 쉬운 진입: 웹 서버가 내장되어 있어 서버 개발에 익숙하지 않은 사람도 쉽게 시작할 수 있습니다.

- 👎 단점
  - CPU 작업에 약함: 이미지/비디오 처리, 대규모 데이터 분석 등 복잡한 연산이 많은 작업에는 부적합합니다. (다른 언어 서버가 더 효율적)
  - 에러 처리가 중요함: 싱글 스레드이므로, 처리되지 않은 에러 하나가 서버 전체를 멈추게 할 수 있습니다.

## 4. 서버를 넘어선 Node.js

Node.js는 자바스크립트 런타임이므로, 서버 개발에만 국한되지 않고 다양한 분야에서 활용됩니다.

- 웹 프레임워크: React, Angular, Vue 등 현대적인 웹 프런트엔드 개발 환경의 기반이 됩니다.
- 모바일 앱: React Native를 통해 하나의 코드로 iOS와 안드로이드 앱을 만듭니다.
- 데스크톱 앱: Electron을 통해 웹 기술로 데스크톱 프로그램을 만듭니다. (예: Visual Studio Code, Slack, Discord)

<br>
<br>
<br>
<br>

# 📖 Node.js 2장: 알아둬야 할 자바스크립트

이 장은 본격적인 Node.js 학습에 앞서, 책 전체에서 사용될 최신 자바스크립트(ES2015+) 문법과 서버와 통신하기 위한 프런트엔드 자바스크립트 기술을 설명하는 준비 파트입니다.

## 1\. 핵심 최신 문법 (ES2015+)

Node.js 개발은 최신 자바스크립트 문법을 적극적으로 사용합니다. 이 책을 이해하기 위해 반드시 알아야 할 주요 문법은 다음과 같습니다.

### 🔹 변수 선언: `const`, `let`

- `var`를 대체: `var`와 달리 `const`와 `let`은 `{}`를 기준으로 하는 블록 스코프(block scope)를 가집니다. 이로 인해 코드가 더 예측 가능하고 안정적이 됩니다.
- 사용법: 값을 변경할 필요가 없는 변수는 `const` (상수)로 선언하는 것을 기본으로 하고, 재할당이 필요한 경우에만 `let`을 사용합니다.

### 🔹 편의 문법: 템플릿 문자열 & 화살표 함수

- 템플릿 문자열 (Template Literals): 백틱(`` ` ``)을 사용하여 문자열 내부에 `${변수}` 형태로 변수를 쉽게 삽입할 수 있어, 문자열 조합이 매우 간결해집니다.
- 화살표 함수 (Arrow Functions): `function` 키워드 대신 `=>`를 사용해 함수를 더 짧게 표현할 수 있습니다.
  - 주의할 점: 화살표 함수는 자신만의 `this`를 가지지 않고, 상위 스코프의 `this`를 그대로 물려받습니다. 이 특징 때문에 `this`의 동작 방식이 기존 함수와 다릅니다.

### 🔹 객체와 배열: 객체 리터럴 & 구조 분해 할당

- 객체 리터럴 (Object Literals): 객체를 생성할 때 `{ name: name }` 대신 `{ name }`처럼, `{ sayJS: function() {} }` 대신 `{ sayJS() {} }`처럼 코드를 단축할 수 있습니다.
- 구조 분해 할당 (Destructuring Assignment): 객체나 배열의 속성/요소를 쉽게 추출하여 변수에 할당하는 문법입니다. 코드를 매우 간결하게 만들어주며, 특히 Node.js 모듈을 가져올 때 자주 사용됩니다.

  ```javascript
  // 객체 구조 분해
  const {
    getCandy,
    status: { count },
  } = candyMachine;

  // 배열 구조 분해
  const [node, obj, , bool] = array;
  ```

### 🔹 비동기 처리의 진화: 프로미스와 `async/await`

- 프로미스 (Promise): 비동기 작업의 성공(`resolve`) 또는 실패(`reject`) 상태를 나타내는 객체입니다. `.then()`과 `.catch()`를 체이닝하여 콜백 지옥(Callback Hell)을 해결하고 비동기 코드를 순차적으로 표현할 수 있게 해줍니다.
  - `Promise.all`: 여러 프로미스를 동시에 실행하고 모두 성공하면 결과를 받습니다.
  - `Promise.allSettled`: 성공/실패 여부와 관계없이 모든 프로미스의 결과를 각각 확인합니다.
- `async/await`: 프로미스를 기반으로, 비동기 코드를 마치 동기 코드처럼 보이게 만드는 최신 문법입니다. `async` 함수 안에서 `await` 키워드를 사용해 프로미스의 결과가 나올 때까지 기다립니다. 에러 처리는 `try...catch` 문으로 합니다.
  > ❗️ 이 책의 대부분 예제가 `async/await`를 사용하므로 반드시 숙지해야 합니다.
  ```javascript
  async function findUser() {
    try {
      let user = await Users.findOne({}); // 프로미스가 완료될 때까지 대기
      console.log(user);
    } catch (error) {
      console.error(error);
    }
  }
  ```

### 🔹 기타 유용한 문법

- 클래스 (Class): 프로토타입 기반의 상속을 `class`, `constructor`, `extends` 키워드로 더 명확하고 보기 좋게 표현하는 문법입니다.
- Map / Set: `Map`은 유연한 키를 가진 객체, `Set`은 중복을 허용하지 않는 배열과 유사한 새로운 자료구조입니다.
- 널 병합 (`??`) / 옵셔널 체이닝 (`?.`): `null`이나 `undefined` 값을 다룰 때 에러를 방지하고 코드를 간결하게 만들어주는 매우 유용한 최신 연산자입니다.

## 2\. 서버와 통신하는 프런트엔드 JS

Node.js 서버와 데이터를 주고받기 위해 프런트엔드(브라우저)에서 사용하는 기술입니다.

### 🔹 AJAX와 `axios`

- 페이지 이동 없이 서버와 비동기적으로 통신하는 기술입니다. 이 책에서는 `axios`라는 라이브러리를 사용해 `GET`(서버 데이터 조회), `POST`(서버에 데이터 전송) 요청을 보냅니다.

### 🔹 `FormData` & 데이터 속성

- FormData: `<form>` 태그의 데이터를 AJAX 요청으로 쉽게 보낼 수 있게 해주는 객체입니다.
- 데이터 속성 (`dataset`): HTML 태그에 `data-id="값"`과 같은 형태로 데이터를 저장하고, 자바스크립트의 `element.dataset.id`로 쉽게 접근하는 표준 방식입니다.

### 🔹 URL 인코딩

- `encodeURIComponent`: URL에 한글이나 특수문자가 포함될 때, 서버가 이해할 수 있는 형태로 안전하게 변환(인코딩)하는 함수입니다.
