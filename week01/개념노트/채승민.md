---
Author: CarefreeLife98
Date: 2025-10-20T14:21:00
Agenda:
tags:
  - TSBM_STUDIO
  - NodeJS
---
# Node.js 핵심 개념

노드란 무엇일까? 공식 사이트에서는 아래와 같이 설명하고 있다.

```text
"Node.js 는 Chrome V8 Javascript 엔진으로 빌드된 자바스크립트 런타임입니다."
```
`[노드 공식 사이트](https://nodejs.org/ko/)`

노드를 처음 접하는 대부분은 노드를 Java 진영의 Spring Framework 와 같은 서버 프레임워크로 이해하고 있을 수 있다. (나 또한 그랬다)

# 1. 서버란?
노드를 통해 다양한 자바스크립트 애플리케이션을 실행할 수 있지만, 그 중에서도 서버 애플리케이션을 실행하는데 제일 많이 사용된다.

- `서버: 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 혹은 프로그램.`
- `클라이언트: 요청을 보내는 주체로 브라우저, 데스크탑 프로그램, 모바일 앱, 타 서버로 요청을 보내는 서버 등이 될 수 있다.`

노드는 자바스크립트 프로그램이 서버로서 기능하기 위해 필요한 도구들을 제공하므로 서버 역할을 수행할 수 있다.
여기서 나는 아래와 같은 의문이 생겼었다.

`왜 기존의 서버 애플리케이션에서 사용하던 언어들을 사용하지 않고, 브라우저에서 사용하던 언어인 자바스크립트 기반의 노드를 굳이 사용하는 걸까?`

이 의문을 해결하려면 먼저 노드의 특성을 알아야 하니 공식 웹사이트 기준으로 알아보자.

# 2. 자바스크립트 런타임
`런타임: 특정 언어로 만든 프로그램들을 실행할 수 있는 환경.`

`노드는 자바스크립트 런타입` 이다.
쉽게 말해, 자바스크립트로 이루어진 프로그램을 컴퓨터에서 실행할 수 있도록 하는 `자바스크립트 실행기` 이다.

![[Pasted image 20251014195653.png]]
`노드의 내부 구조`

노드는 V8 과 더불어 `libuv` 라는 `비동기 I/O 작업, 이벤트 처리, 동시성 및 기타 시스템 관련 기능에 대한 크로스 플랫폼 지원` 을 제공하는 C++ 기반 라이브러리를 사용한다.
우리가 코딩한 자바스크립트 코드는 Node.js Core 모듈에 의해 JS 에서 C++ 함수로 바인딩되어 연결되며, 이로서 libuv 라이브러리를 사용할 수 있게 된다.

# 3. 이벤트 기반
```text
이벤트 기반 (event-driven): 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식.

이벤트의 예시: 클릭, 네트워크 요청 등
```

**이벤트 기반 시스템에서는 특정 이벤트 발생 시 무엇을 할 지 사전에 정의해두어야 한다.**
- `이벤트 리스너(event-listener) 에 콜백(call-back) 함수를 등록한다고 표현`
- e.g. 버튼 클릭 시 경고창 노출 -> 클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수 등록 -> 클릭 이벤트 발생 시마다 콜백 함수가 실행되어 경고창 노출

![[Pasted image 20251018155045.png]]
`이벤트 기반 시스템`

노드도 마찬가지로 이벤트 기반 방식으로 동작한다.
발생한 이벤트가 없거나, 발생한 이벤트를 전부 처리하면, 노드는 **다음 이벤트가 발생할 때까지 대기**한다.


## 이벤트 루프 (event loop)
이벤트 기반 모델에서는 `이벤트 루프(event loop)` 라는 중요한 개념이 있다.
이는 여러 이벤트가 동시에 발생했을때 **각 이벤트에 대한 콜백 함수를 어떠한 처리 순서로 호출할 지 판단**하는 개념이다.


### 호출 스택 (call stack)
노드는 자바스크립트 코드의 최상단부터 한 줄씩 실행한다.
함수 호출부를 발견한 순간, **호출 대상 함수를 호출 스택 (call stack) 에 삽입**한다.

```javascript
function first() {
  second();
  console.log('첫 번째');
}
function second() {
  third();
  console.log('두 번째');
}
function third() {
  console.log('세 번째');
}
first();
```

`first()` 함수가 가장 먼저 호출되고, 내부의 `second()` 함수가 호출된 뒤, 마지막으로 `third()` 함수가 호출된다.
이때, 호출 스택(call stack)에 삽입되는 순서는 호출되는 순서와 동일하며, **호출 스택에서 꺼내어 실행하는 순서는 역방향**이 된다.
	(호출 스택은 “실행 중인 함수들의 호출 순서”를 기록하는 **LIFO(Last In, First Out)** 스택 구조로 되어 있다.)

따라서 콘솔에는 `"세 번째" -> "두 번째" -> "첫 번째"`  순으로 로그가 출력된다.

![[Pasted image 20251018160143.png]]
`호출 스택(call stack)`


### anonymous 전역 컨텍스트
여기서 최하단의 `anonymous` 는 첫 실행 시의 `전역 실행 컨텍스트(Global Execution Context)` 를 의미한다.

> anonymous 함수: **“전역(global) 스코프에서 실행되는 최상위 코드 블록”**  

자바스크립트 엔진은 프로그램 실행 시, 가장 먼저 **전역 컨텍스트**를 생성한다.
이 전역 컨텍스트는 함수가 아닌 `“전체 스크립트 코드 자체”`이므로 이름이 없다.

아래처럼 에러를 일부러 발생시켜보면,

```javascript
function foo() {
  bar();
}
function bar() {
  throw new Error('Oops!');
}
foo();
```

출력되는 stack trace는 아래처럼 보인다.

```text
Error: Oops!
    at bar (<anonymous>:4:9)
    at foo (<anonymous>:2:3)
    at <anonymous>:6:1
```

여기서 마지막 줄: `at <anonymous>:6:1`
이 부분이 바로 `전역 코드(global code)` 이다.

즉, `foo()`를 **호출한 위치가 파일의 최상단(전역 영역)** 이므로, 이 코드의 **실행 주체(전역 실행 컨텍스트) 가 anonymous로 표시**된 것.

왜 이름이 없는가?

전역 코드에는 함수명이나 컨텍스트명이 존재하지 않는다.  즉, 자바스크립트 엔진이 내부적으로 실행할 때 아래와 같이 해석한다.

```javascript
(function() {   
	// 당신의 스크립트 전체 코드 
})();
```

그래서 브라우저 콘솔이나 Node.js 스택 트레이스에서는 전역 코드가  `“이름 없는 (익명) 함수처럼”` 보이게 되는 것.

전역 코드는 브라우저 환경과 Node.js 환경에 따라 아래와 같이 다르게 해석된다.

| 환경                  | Stack 최하단 표시                                       | 의미                   |
| ------------------- | -------------------------------------------------- | -------------------- |
| **Browser (V8 기반)** | `at <anonymous>` 또는 `(anonymous)`                  | 스크립트 전체(Global Code) |
| **Node.js**         | `at Object.<anonymous> (path/to/file.js:line:col)` | 모듈 스코프에서 실행된 코드      |

Node.js 에서는 `모듈 래퍼 함수 (Module Wrapper Function)` 를 통해 각 파일을 다음과 같이 감싼다.

```javascript
(function (exports, require, module, __filename, __dirname) {
  // 파일 내용
});
```

따라서 Node의 call stack에서는 `Object.<anonymous>` 형태로 표시됩니다.  
즉, **모듈 파일의 최상단 스코프**를 의미하는 것.

다시 돌아가서, 함수는 실행되는 동안 호출 스택에 머물러 있다가 실행이 완료되면 pop 되어 사라진다.
third, secont, first, anonymous 순으로 사라지고, anonymous 컨텍스트까지 모두 실행이 완료되었다면 호출스택은 비어있게 된다.


## 이벤트 루프(event loop), 백그라운드(background), 태스크 큐(task queue)

만약 특정 밀리초 (1/1000) 초 이후에 코드를 실행하는 `setTimeout` 을 사용하면 어떻게 될까?

```javascript
function run() { 
  console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
 
console.log('끝');
```
`콘솔 로그 결과: 시작 -> 끝 -> 3초 후 실행`

이는 이벤트 루프, 태스트 큐, 백그라운드 구조에 대해 알아야 그 동작 과정을 이해할 수 있다.

- `이벤트 루프:`
  **이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할**을 담당. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부름.

- `백그라운드:`
  **setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳**입니다. 노드에서는 `libuv` 라는 C/C++ 기반 코어 모듈에 의해 동작하며, 여러 작업을 동시에 실행할 수 있다. (**libuv 내부적으로 스레드풀(기본 4개)을 사용**하여 파일시스템 I/O, DNS, 일부 암호화 연산을 `비동기`적으로 처리) **JS 자체는 단일 스레드로 실행**되지만, 실제로 **시간이 걸리는 작업들은 백그라운드에서 처리되어 완료 시 콜백을 전달**한다. 그래서 `비동기 I/O`가 가능한 것.

- `태스크 큐:`
  이벤트 발생 후, **백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다.** 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 함. 콜백들은 보통 완료된 순서대로 줄을 서 있지만, **이벤트 루프가 태스크 큐를 처리하는 우선순위 규칙** 때문에  **특정 상황에서는 실제 실행 순서가 달라질 수 있다.** (Microtask, Macrotask, Node.js 의 경우 process.nextTick 까지).


### 태스크 큐의 종류와 우선순위

|구분|예시|처리 시점|우선순위|
|---|---|---|---|
|**Macrotask Queue**|`setTimeout`, `setInterval`, `setImmediate`, I/O 콜백, UI 이벤트 등|한 턴(이벤트 루프 사이클)이 끝날 때마다 1개씩 처리|⬇️ 낮음|
|**Microtask Queue**|`Promise.then`, `queueMicrotask`, `MutationObserver`|**각 macrotask가 끝난 후, 렌더링 전에 모두 실행**|⬆️ 높음|
|**process.nextTick Queue** (Node 전용)|`process.nextTick()`|**심지어 microtask보다도 먼저**, 현재 실행 중인 콜스택이 끝난 직후 실행|⬆️⬆️ 가장 높음|

### 이벤트 루프 - 백그라운드 - 태스크 큐
![[Pasted image 20251018164806.png]]
`이벤트 루프 - 1`

![[Pasted image 20251018165137.png]]
`이벤트 루프 - 2`

![[Pasted image 20251018165213.png]]
`이벤트 루프 - 3`

# 4. 논 블로킹 I/O
이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리 할 수 있음.
기본적으로 자바스크립트 엔진은 단일 스레드 위에서 동작하기 때문에, 동시에 실행 될 수 없다.
하지만 **자바스크립트 상에서 동작하는 작업이 아닌, I/O 작업과 같은 것은 동시에 처리 될 수 있다.**

I/O(입력, 출력) 과 같은 작업은 다음과 같다.
- `파일 시스템 접근` (파일 읽기 및 쓰기, 폴더 만들기 등)
- `네트워크를 통한 요청` (API 요청, 데이터베이스(DB) 접속, 소켓 통신, 파일 다운로드 등)

이러한 I/O 작업을 할 때 노드는 `논블로킹` 방식으로 처리하는 방법을 제공한다.

![[Pasted image 20251018165933.png]]
`블로킹 / 논블로킹`

- **논블로킹 (non-blocking): 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행**
- **블로킹 (blocking): 이전 작업이 끝나야만 다음 작업을 수행**

노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리할 수 있다.
따라서 **동시에 처리할 수 있는 작업들은 (파일 시스템, 네트워크 요청) 최대한 묶어 백그라운드로 넘겨야 지연시간을 최소화** 할 수 있다.

![[Pasted image 20251018171633.png]]
`동시 처리를 통한 지연시간 최소화`

## 블로킹 방식과 논블로킹 방식의 코드

```javascript
function longRunningTask() {
  // 오래 걸리는 작업
  console.log('작업 끝');
}

console.log('시작');
longRunningTask();
console.log('다음 작업');
```
`블로킹 방식: 시작 -> 작업 끝 (지연 시간 발생) -> 다음 작업`

```javascript
function longRunningTask() {
  // 오래 걸리는 작업
  console.log('작업 끝');
}
console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');
```
`논블로킹 방식: 시작 -> 다음 작업 -> 작업 끝`

`setTimeout(callback, 0)` 은 논블로킹 방식으로 사용하기 위한 기법 중 하나. 노드에서는 `setImmediate()` 를 주로 사용.
앞서 얘기한 이벤트 루프를 이해했다면, `setTimeout`의 콜백 함수인 `longRunningTask` 가 **태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있다.**

하지만 아무리 `논블로킹` 방식으로 코드를 작성하더라도, 그 동작이 자바스크립트 코드라면 동시에 실행되지 않는다. 이는 **I/O 작업에 국한되어 동시 처리가 가능**하기 때문이다.
따라서 `논블로킹` 과 `동시` 는 **동일한 의미가 아님**을 알아야 한다. **동시성은 동시 처리가 가능한 I/O 작업을 논블로킹 처리해야 얻을 수 있는 것**이다.

# 5. 싱글 스레드
**싱글 스레드란, 말 그대로 스레드가 하나뿐이라는 것.**
이는 우리가 작성하는 자바스크립트 코드가 동시에 실행될 수 없는 이유.

## 프로세스와 스레드의 차이
![[Pasted image 20251018173147.png]]
- `프로세스(Process):` **운영체제에서 할당하는 작업의 단위.**
	- 노드 / 웹 브라우저와 같은 프로그램은 개별 프로세스.
	- 프로세스 간에는 메모리 등의 컴퓨팅 리소스를 공유하지 않는다.
- `스레드(Thread):` **프로세스(Process) 내에서 실행되는 흐름의 단위.**
	- 프로세스는 여러 개의 스레드를 생성해 여러 작업을 동시에 처리할 수 있다.
	- 스레드들은 부모 프로세스의 컴퓨팅 리소스를 공유한다.
	- 부모 프로세스에게 할당된 메모리에 서로 접근 가능하므로 데이터를 공유할 수 있다.

`노드 = 싱글 스레드` 라고 하지만, 엄밀히 말하면 노드는 싱글 스레드로 동작하지 않는다.
노드를 실행하면 노드 프로세스가 생성되고, 이때 **여러개의 스레드를 생성하지만 우리가 직접 제어할 수 있는 스레드는 하나 뿐이다.** 
이에 노드가 싱글 스레드 기반으로 인식되고 있는 것.

### Node.js 가 생성하는 스레드의 종류

#### ① JavaScript 메인 스레드
- 우리가 작성한 JS 코드가 실행되는 곳.
- **V8 엔진**이 구동되는 스레드이며, **이벤트 루프(Event Loop)**가 이 스레드 위에서 동작.
- 이 스레드에서 실행되는 것:
    - `변수`, `함수`, `Promise`, `async/await` 등 순수 JS 로직
    - `console.log`, `setTimeout`의 콜백 등록 등
- **유일하게 직접 접근 가능한 스레드**


#### ② libuv Thread Pool (워커 스레드 풀)
- Node.js가 내부적으로 I/O 작업을 효율적으로 처리하기 위해 사용하는 **백그라운드 스레드 풀**.
- 기본적으로 **4개의 워커 스레드**가 생성되며, `UV_THREADPOOL_SIZE` 환경변수로 최대 128개까지 조정 가능.
	- 이 워커 스레드들은 아래와 같은 **비동기 I/O 작업**을 실제로 처리.

| 종류               | 예시                                   |
| ---------------- | ------------------------------------ |
| **파일 시스템 I/O**   | `fs.readFile()`, `fs.writeFile()`    |
| **DNS 조회 (비동기)** | `dns.lookup()`                       |
| **암호화 관련 연산**    | `crypto.pbkdf2()`, `crypto.scrypt()` |
| **압축/해제**        | `zlib` 모듈의 압축 함수들                    |
| **일부 네트워크 I/O**  | 비동기 소켓, TLS handshake 등              |
이런 함수들은 JS 메인 스레드에서 실행되지 않고,  **libuv의 워커 스레드로 넘겨져 백그라운드에서 처리**

```javascript
fs.readFile('test.txt', (err, data) => {
  console.log(data);
});
```
1. JS 코드가 `fs.readFile`을 호출 → Node는 실제 파일 I/O 요청을 libuv에게 전달.
2. libuv가 스레드 풀 중 하나에 작업을 맡깁니다.
3. 파일이 읽히면 해당 스레드가 완료 이벤트를 큐에 등록.
4. 이벤트 루프가 이 콜백을 가져와 JS 메인 스레드에서 실행.

즉, 실제 I/O는 **백그라운드 스레드**에서 일어나고, 결과만 **메인 스레드로 전달**되는 구조.


#### ③ OS 커널 / 시스템 스레드
- 파일, 네트워크 소켓 등은 **운영체제 커널 레벨의 비동기 기능 (epoll, kqueue, IOCP 등)** 을 이용.
- libuv는 이런 OS 기능들을 감싸서 **논블로킹 방식으로 Node.js가 사용할 수 있게 추상화**한 역할.
	- 즉, 실제 I/O는 OS 스레드에서 일어나고, Node는 그 이벤트를 받기만 한다.


**스레드 구성 요약**

| 구분                      | 스레드 수    | 역할                  | 직접 제어 가능 여부   |
| ----------------------- | -------- | ------------------- | ------------- |
| **JS 메인 스레드**           | 1        | JS 코드 실행, 이벤트 루프 동작 | ✅ 가능          |
| **libuv Thread Pool**   | 기본 4개    | 파일 I/O, 암호화 등       | ❌ 불가능 (자동 관리) |
| **OS 커널 스레드**           | OS 관리    | 소켓, 네트워크 I/O        | ❌ 불가능         |
| **Worker Threads (모듈)** | 직접 생성 가능 | CPU 연산 분리용          | ✅ 가능 (명시적 생성) |
```
노드12 버전부터는 안정화된 워커 스레드 (Worker Thread) 를 사용해 멀티 스레드를 사용할 수 있다.
직접 다수의 스레드를 다룰 수 있으며, CPU 작업 (연산이 많은 작업) 이 많은 경우 워커 스레드를 통해 동시 처리를 할 수 있다.
```

언뜻 보았을 때, 여러 일을 동시에 처리 할 수 있는 멀티 스레드가 싱글 스레드보다 단연 좋은 성능을 가질 것으로 예상된다. 하지만 꼭 그런 것은 아니다.
이를 이해시키기 위해 책에서는 아래와 같은 예시를 들고 있다.

![[Pasted image 20251018175158.png]]
```text
한 음식점에 점원이 한 명 있습니다. 손님은 여러 명이고요. 
점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 합니다. 그 후 다음 손님의 주문을 받습니다.

이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 하지 못하고 기다리고 있어야 합니다.
이것이 바로 싱글 스레드(점원), 블로킹 모델입니다. 매우 비효율적입니다.
```

![[Pasted image 20251018175228.png]]
```text
이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받습니다.
요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 것만 주방에 계속 알려주는 것입니다.
주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙합니다.
요리의 특성(블로킹인지 논블로킹인지)에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서가 일치하지 않을 수도 있습니다.

이것이 싱글 스레드, 논블로킹 모델입니다. 바로 노드가 채택하고 있는 방식입니다.
점원은 한 명이지만 혼자서 많은 일을 처리할 수 있습니다. 하지만 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가 생길 수 있습니다.
또한, 요리를 하는 데 시간이 오래 걸린다면(CPU를 많이 쓰는 작업) 주문이 많이 들어왔을 때 버거울 수 있습니다.
```

![[Pasted image 20251018175326.png]]
```text
멀티 스레드 방식에서는 손님 한 명이 올 때마다 점원도 한 명씩 붙어 주문을 받고 서빙합니다. 
언뜻 보면 싱글 스레드보다 좋은 방법처럼 보이지만, 장단점이 있습니다. 
일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없습니다. 점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문입니다. 
하지만 손님의 수가 늘어날수록 점원의 수도 늘어납니다. 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다는 것도 문제가 됩니다. 
점원을 새로 고용하거나 기존 직원을 해고하는 데는 비용이 발생합니다.
```

![[스크린샷 2025-10-18 오후 5.54.30.png]]
```text
그렇다면 점원 여러 명(멀티 스레드)이 모두 논블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 의문이 들 수 있습니다. 실제로 그렇습니다.
다만, 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어려우므로 멀티 프로세싱 방식을 대신 사용합니다.
I/O 요청에는 멀티 프로세싱이 더 효율적이기도 합니다.

I/O 작업을 처리할 때는 멀티 스레딩보다 멀티 프로세싱이 효율적이므로 노드는 멀티 프로세싱을 많이 합니다.
```

# 의문점 - 하나뿐인 스레드를 멈추지 않도록 관리하라?


# 의문점 - 하나뿐인 스레드가 멈추지 않도록 관리하라?
## 🧩 1. Node.js의 핵심 구조 — 싱글 스레드 이벤트 루프

Node.js는 자바스크립트 코드를 **단 하나의 스레드(메인 스레드)**에서 실행합니다.
이 스레드가 하는 일은:

* 요청을 받고
* 이벤트 루프를 돌리며
* 콜백을 실행하고
* 비동기 작업의 결과를 처리하는 것

즉, **Node.js 애플리케이션의 생명줄은 단 하나의 메인 스레드**입니다.

---

## ⚙️ 2. “스레드가 멈춘다”는 건 어떤 상황일까?

Node.js의 이벤트 루프(메인 스레드)는 **CPU 바운드 작업이나 동기 블로킹 코드** 때문에 멈출 수 있습니다.
즉, 메인 스레드가 한 작업 때문에 오래 “붙잡혀” 있으면
다른 요청을 처리하지 못하게 됩니다.

예시로 보면 👇

```js
// ❌ 나쁜 예시 — 메인 스레드가 멈춤
app.get('/heavy', (req, res) => {
  // CPU를 많이 쓰는 동기 작업
  let sum = 0;
  for (let i = 0; i < 1e10; i++) sum += i; // 100억
  res.send('Done');
});
```

이 코드를 실행하면:

* `/heavy` 요청을 처리하는 동안 이벤트 루프는 그 for문에 **완전히 붙잡혀 있음**
* 따라서 다른 요청(`/health` 등)은 응답하지 못함
* 심한 경우 서버 전체가 “먹통”처럼 느껴짐

➡️ 이것이 바로 "**하나뿐인 스레드가 멈춘다**"는 상황입니다.

---

## 🚨 3. 그래서 “관리”가 필요하다는 의미

이 말은 결국 다음과 같은 **운영/개발 측면의 주의사항**을 뜻합니다.

| 관리 포인트                | 설명                                                                          |
| --------------------- | --------------------------------------------------------------------------- |
| **CPU 바운드 작업 분리**     | 이미지 처리, 암호화, 데이터 압축 등은 `Worker Threads`, `child_process`, 혹은 외부 마이크로서비스로 분리 |
| **비동기 I/O 사용**        | 파일, 네트워크, DB 작업 등은 반드시 비동기(non-blocking) API 사용                             |
| **에러 핸들링 철저**         | `uncaughtException`, `unhandledRejection` 등의 예외 처리 누락 시 프로세스 전체가 종료될 수 있음   |
| **이벤트 루프 모니터링**       | `clinic`, `prometheus`, `event-loop-lag` 등을 사용해 루프가 막히지 않도록 모니터링            |
| **클러스터링(Clustering)** | Node.js `cluster` 모듈 또는 PM2로 여러 프로세스를 띄워 병렬 처리 구조 확보                        |

---

## 🧠 4. 요약하자면

> Node.js는 기본적으로 **단일 스레드 기반의 이벤트 루프 모델**을 사용하기 때문에,
> 메인 스레드가 **블로킹 작업에 의해 멈추면** 전체 서버가 정지 상태가 됩니다.
>
> 따라서 “하나뿐인 스레드가 멈추지 않도록 관리가 필요하다”는 말은
> **비동기 설계, CPU 바운드 작업 분리, 예외 관리, 프로세스 분산** 등을 통해
> 이벤트 루프가 항상 자유롭게 돌아가도록 관리해야 한다는 뜻입니다.

---

# 의문점 -  그렇다면 블로킹 작업을 빠르고 효율적으로 할 수 있는 방법은 뭐가 있을까?

## 🧩 1. 기본 개념

- Node.js는 기본적으로 **싱글 스레드(Event Loop)** 에서 자바스크립트 코드를 실행합니다.
- 하지만 `worker_threads` 모듈을 이용하면, **별도의 스레드에서 JS 코드를 병렬 실행**시킬 수 있어요.
- 즉, **CPU 바운드 작업을 분리해서 메인 루프가 멈추지 않게** 할 수 있습니다.

---

## ⚙️ 2. 기본 구조
`worker_threads` 모듈은 Node.js 내장 모듈이라 별도 설치 없이 사용 가능합니다.

### **(1) main.js – 메인 스레드**

```js
const { Worker } = require('worker_threads');

console.log('🧠 메인 스레드 시작');

const worker = new Worker('./worker.js', {
  workerData: { value: 10 }
});

worker.on('message', (result) => {
  console.log('✅ 워커 결과:', result);
});

worker.on('error', (err) => {
  console.error('❌ 워커 오류:', err);
});

worker.on('exit', (code) => {
  console.log(`🚪 워커 종료 (code: ${code})`);
});

console.log('➡️ 메인 스레드는 다른 작업 계속 수행 중...');
```

---

### **(2) worker.js – 워커 스레드**

```js
const { parentPort, workerData } = require('worker_threads');

// workerData: main.js에서 전달받은 데이터
const num = workerData.value;

let sum = 0;
for (let i = 0; i < 1e9; i++) {
  sum += i;
}

// 부모 스레드로 결과 전송
parentPort.postMessage({ input: num, result: sum });
```

---

### 🧩 실행 결과

```
🧠 메인 스레드 시작
➡️ 메인 스레드는 다른 작업 계속 수행 중...
✅ 워커 결과: { input: 10, result: 499999999500000000 }
🚪 워커 종료 (code: 0)
```

→ 메인 스레드는 블로킹되지 않고, 워커가 별도로 연산을 수행한 뒤 결과만 받아옵니다.
	
---

## ⚡️ 3. 장점

|장점|설명|
|---|---|
|✅ 메인 스레드 비차단|CPU 연산 중에도 이벤트 루프가 멈추지 않음|
|🔄 멀티코어 활용|여러 Worker를 띄워 병렬 처리 가능|
|🧱 구조적 메시징|Worker 간 통신은 `postMessage` 기반으로 안전하게 이루어짐|

---

## 🚫 4. 주의점

|항목|설명|
|---|---|
|❌ 공유 메모리 없음|JS 객체는 복사(직렬화)되어 전달되므로 큰 데이터 전달 시 비용 큼|
|💾 대용량 데이터|`SharedArrayBuffer`를 이용하면 일부 공유 가능하지만 신중히 사용|
|🧩 간단한 I/O|단순한 DB나 네트워크 I/O는 워커 대신 비동기 API로 처리하는 게 효율적|

---

## 🚀 5. 실제 서비스에서의 활용 패턴

|상황|추천 방식|
|---|---|
|이미지 변환, 압축, 암호화|Worker Threads|
|AI 추론, 수학적 계산|Worker Threads|
|파일 업로드/다운로드|그냥 비동기 I/O|
|데이터베이스 쿼리|비동기 ORM, 커넥션 풀|
|대규모 병렬처리|Worker Pool (예: `Piscina`, `node-worker-pool`)|

---

## 💡 6. 참고: 워커 풀(Pool) 사용 예시

여러 워커를 효율적으로 재사용하려면  
[`Piscina`](https://github.com/piscinajs/piscina) 같은 라이브러리를 쓰면 좋아요.

```js
// main.js
import Piscina from 'piscina';
const piscina = new Piscina({ filename: './worker.js' });

(async () => {
  const result = await piscina.run({ value: 10 });
  console.log('✅ 워커 결과:', result);
})();
```
