# 📘 1장

## 1️⃣ Node.js란 무엇인가
Node.js는 **Chrome V8 JavaScript 엔진으로 빌드된 자바스크립트 런타임**이다.  
즉, 브라우저 밖에서도 자바스크립트를 실행할 수 있는 환경을 제공한다.  
이 덕분에 자바스크립트를 이용해 **서버, CLI 도구, 데스크톱 앱, 모바일 앱 등 다양한 영역의 프로그램**을 만들 수 있다.

---

## 2️⃣ 서버(Server)란 무엇인가
서버는 **클라이언트의 요청(Request)에 응답(Response)** 하는 컴퓨터 또는 프로그램이다.  
클라이언트는 브라우저, 모바일 앱, 또는 다른 서버가 될 수도 있다.

예시:
- 브라우저가 웹 페이지를 요청하면, 서버는 HTML 파일을 응답한다.
- 앱스토어에서 앱을 설치할 때, 서버는 설치 파일을 전달한다.

요약하면, 서버는 “**요청에 응답하는 시스템**”이며, 노드는 이 서버 역할을 자바스크립트로 수행할 수 있게 해준다.

---

## 3️⃣ 런타임(Runtime) 이해하기
**런타임(Runtime)** 은 특정 언어의 코드를 실행할 수 있는 환경이다.  
노드는 자바스크립트 런타임이므로, 자바스크립트 코드를 브라우저 외부에서도 실행할 수 있다.

- 기존: 브라우저만 자바스크립트를 실행 가능
- 노드 등장 이후: 서버, CLI 등에서도 자바스크립트 실행 가능

노드는 **V8 엔진**과 **libuv 라이브러리**를 기반으로 작동한다.
- V8: 자바스크립트 코드를 빠르게 실행
- libuv: 이벤트 기반, 논블로킹 I/O 모델 구현

---

## 4️⃣ 이벤트 기반(Event-Driven) 모델
이벤트 기반이란 **이벤트 발생 시 미리 등록해둔 콜백 함수를 실행하는 구조**를 말한다.

- 이벤트 리스너(Event Listener)에 콜백을 등록
- 이벤트 발생 시 해당 콜백 실행
- 이벤트가 없으면 대기 상태 유지

노드는 이런 이벤트들을 관리하기 위해 **이벤트 루프(Event Loop)** 를 사용한다.  
이벤트 루프는 “콜백을 어떤 순서로 실행할지”를 결정하는 핵심 구조이다.

> 호출 스택(Call Stack)과 태스크 큐(Task Queue)를 통해  
> 이벤트가 처리되는 순서를 조율한다.

---

## 5️⃣ 논블로킹 I/O (Non-Blocking I/O)
**I/O(Input/Output)** 작업이란 파일 읽기, 네트워크 요청 등 외부 자원 접근을 말한다.  
노드는 이러한 작업을 **논블로킹 방식**으로 처리한다.

- **블로킹(Blocking)**: 한 작업이 끝나야 다음 작업 실행
- **논블로킹(Non-Blocking)**: 이전 작업이 끝나기 전에도 다음 작업 수행 가능

즉, 노드는 시간이 오래 걸리는 작업을 **백그라운드로 넘기고**,  
메인 스레드는 다른 작업을 계속 진행한다.

> I/O 작업을 효율적으로 병렬 처리하기 위해  
> 가능한 한 논블로킹 코딩 방식을 사용하는 것이 중요하다.

---

## 6️⃣ 싱글 스레드(Single Thread) 모델
노드는 기본적으로 **싱글 스레드, 논블로킹 모델**을 사용한다.  
즉, 자바스크립트 코드를 실행하는 **메인 스레드는 하나**뿐이다.

- 프로세스(Process): 운영체제에서 실행되는 독립된 프로그램 단위
- 스레드(Thread): 프로세스 내에서 실행되는 흐름 단위

노드는 내부적으로 여러 스레드를 생성하지만,  
개발자가 직접 제어할 수 있는 것은 **하나의 메인 스레드**뿐이다.

이 구조는 단순하지만, CPU 연산이 많은 작업에서는 비효율적일 수 있다.  
따라서 노드는 **I/O 중심의 서버**에 적합하다.

---

## 7️⃣ 노드의 장단점 요약

| 구분 | 설명 |
|------|------|
| **장점** | - 자바스크립트 하나로 프런트/백엔드 개발 가능<br>- 비동기 I/O로 빠른 요청 처리<br>- 내장 웹 서버로 간편한 서버 구축 |
| **단점** | - CPU 연산이 많은 작업에 부적합<br>- 싱글 스레드 특성상 에러 처리 실패 시 서버 전체 다운 가능 |

---

## 8️⃣ 노드의 활용 예시
- **실시간 애플리케이션**: 채팅, 주식 차트, 실시간 알림
- **API 서버**: JSON 기반의 빠른 데이터 통신
- **프런트엔드 개발 환경**: React, Vue, Angular 등의 빌드 도구
- **데스크톱/모바일 앱 개발**: Electron, React Native

> NASA, Netflix, Uber, LinkedIn, PayPal 등  
> 세계적인 기업들이 실제로 Node.js를 사용하고 있다.

---

## 9️⃣ 핵심 정리
- Node.js는 **자바스크립트를 서버에서도 실행할 수 있게 해주는 런타임**이다.
- **이벤트 기반, 논블로킹, 싱글 스레드** 모델로 작동한다.
- **I/O 중심의 서버**에 적합하며, CPU 중심의 연산에는 비추천이다.
- 자바스크립트 하나로 **전체 웹 생태계(프런트~백엔드)** 를 구성할 수 있다는 점이 가장 큰 강점이다.

---

## 🧩 의문점
### Q1. **‘운영체제(OS) 수준에서 동작한다’는 말의 정확한 의미는?**
**핵심 결론:** Node는 **OS 위에서 실행되는 네이티브 프로세스**다.
- `node app.js` 실행 시, OS는 **Node 프로세스**를 띄움. 내부엔 **V8(코드 실행)** + **libuv(I/O 엔진)**.
- Node API ↔ (C++ 바인딩) ↔ libuv ↔ **커널/시스템 콜** 흐름으로 연결.
- **매핑 예시:**

### Q2. **React는 브라우저에서만 동작하는데 왜 Node.js를 활용하나?**
**핵심 결론:** React **자체 실행은 브라우저**, 그러나 **개발/빌드/서버사이드렌더링(SSR)** 에 **Node가 필수 도구**로 쓰임.
- **일반 SPA(React)**
    - 실행: 브라우저.
    - **Node의 역할:**
        - 개발 서버(핫리로드, Vite/webpack dev server)
        - 빌드(Babel/TS → 브라우저 호환 번들)
        - 패키지 관리(npm, pnpm, yarn)
- **SSR/하이브리드(Next.js/Remix)**
    - **Node 서버에서 React 컴포넌트 실행 → HTML 선렌더링** 후 브라우저 전달.
    - SEO/퍼포먼스 이점, 라우팅/데이터 패칭 통합.
- **정리 표**

| 시나리오 | React 실행 위치 | Node 필요성 |
|---|---|---|
| 순수 SPA | 브라우저 | 개발·빌드·패키지 관리에 필요 |
| SSR(Next.js) | **브라우저 + Node 서버** | **렌더링/라우팅/데이터 패칭에 핵심** |
| React Native | 모바일 런타임 | 빌드/패키징 도구로 활용 |
---

# 📘 2장

## 1️⃣ const와 let
`var` 대신 `const`와 `let`을 사용한다.  
두 문법은 **블록 스코프(Block Scope)** 를 가지며, 이는 `if`, `for`, `function` 등의 `{}` 내부에서만 유효하다.

- `var`: 함수 스코프(Function Scope)
- `const`, `let`: 블록 스코프(Block Scope)

```js
if (true) {
  var x = 3;
}
console.log(x); // 3

if (true) {
const y = 3;
}
console.log(y); // ReferenceError
```

- `const`: 한 번 값이 할당되면 변경 불가 (상수)
- `let`: 재할당 가능
- 선언 시 초기화 필수 (`const c;` → SyntaxError)

> **권장 습관:**  
> 기본적으로 `const` 사용, 재할당이 필요한 경우에만 `let` 사용.

---

## 2️⃣ 템플릿 문자열
ES2015에서 추가된 **백틱(\`)** 기반의 문자열이다.  
`${변수}` 형식으로 변수나 표현식을 직접 삽입할 수 있어 가독성이 높다.

```js
const num1 = 1;
const num2 = 2;
const result = 3;
const string = `${num1} 더하기 ${num2}는 '${result}'`;
console.log(string); // 1 더하기 2는 '3'
```

> 문자열 결합(`+`)보다 직관적이며, 따옴표(`'`, `"`)와 혼용 가능하다.

---

## 3️⃣ 객체 리터럴
ES2015에서 객체 생성 시 더 간결한 문법을 사용할 수 있다.

```js
const sayNode = () => console.log('Node');
const es = 'ES';

const newObject = {
sayJS() {
console.log('JS');
},
sayNode, // 변수명과 속성명이 같을 경우 한 번만 작성
[es + 6]: 'Fantastic', // 동적 속성명
};
```
- **메서드 축약:** `sayJS() {}`
- **속성 축약:** `{ name, age }`
- **계산된 속성명:** `[es + 6]`

> 코드를 간결하게 작성할 수 있으며 유지보수성이 높아진다.

---

## 4️⃣ 화살표 함수 (Arrow Function)
`function` 대신 `=>`를 사용하는 간결한 함수 선언 방식이다.  
짧고 직관적이며 **상위 스코프의 this를 유지**한다.

```js
const add = (x, y) => x + y;
const not = x => !x;
```

**this 바인딩 차이 예시**

```js
var relationship1 = {
  name: 'zero',
  friends: ['nero', 'hero', 'xero'],
  logFriends: function () {
    var that = this;
    this.friends.forEach(function (friend) {
      console.log(that.name, friend);
    });
  },
};

const relationship2 = {
name: 'zero',
friends: ['nero', 'hero', 'xero'],
logFriends() {
this.friends.forEach(friend => {
console.log(this.name, friend);
});
},
};
```

> 화살표 함수는 자신만의 this를 갖지 않고 **바깥 스코프의 this를 그대로 사용**한다.

---

## 5️⃣ 구조 분해 할당
객체나 배열에서 원하는 값만 손쉽게 꺼낼 수 있는 문법이다.

```js
const candyMachine = {
  status: { name: 'node', count: 5 },
  getCandy() {
    this.status.count--;
    return this.status.count;
  },
};

const { getCandy, status: { count } } = candyMachine;
```

또한 배열에도 사용할 수 있다.

```js
const array = ['nodejs', {}, 10, true];
const [node, obj, , bool] = array;
```

> 다단계 구조의 속성도 간결하게 추출 가능하지만, 함수의 this가 달라질 수 있으므로 주의해야 한다.

---

## 6️⃣ 클래스 (Class)
기존의 프로토타입 기반 상속을 보기 좋게 만든 문법이다.

```js
class Human {
  constructor(type = 'human') {
    this.type = type;
  }
  static isHuman(human) {
    return human instanceof Human;
  }
  breathe() {
    console.log('h-a-a-a-m');
  }
}

class Zero extends Human {
constructor(type, firstName, lastName) {
super(type);
this.firstName = firstName;
this.lastName = lastName;
}
sayName() {
super.breathe();
console.log(`${this.firstName} ${this.lastName}`);
}
}

const newZero = new Zero('human', 'Zero', 'Cho');
Human.isHuman(newZero); // true
```

> 내부적으로는 여전히 프로토타입 기반으로 동작하지만 문법이 단순해졌다.

---

## 7️⃣ 프로미스 (Promise)
비동기 작업을 효율적으로 처리하기 위한 객체.  
콜백 지옥(callback hell)을 해결할 수 있다.

```js
const condition = true;
const promise = new Promise((resolve, reject) => {
  if (condition) resolve('성공');
  else reject('실패');
});

promise
.then(msg => console.log(msg)) // 성공(resolve)
.catch(err => console.error(err)) // 실패(reject)
.finally(() => console.log('끝'));
```

> then: 성공 시 동작  
> catch: 실패 시 동작  
> finally: 결과와 관계없이 항상 실행

---

## 8️⃣ async / await
Promise 기반 코드를 **동기식처럼 작성**할 수 있게 해주는 문법이다.

```js
async function findAndSaveUser(Users) {
  try {
    let user = await Users.findOne({});
    user.name = 'zero';
    user = await user.save();
    user = await Users.findOne({ gender: 'm' });
  } catch (err) {
    console.error(err);
  }
}
```

> 비동기 흐름을 단순하게 표현하며, 에러 처리는 `try/catch`로 처리한다.

---

## 9️⃣ Map / Set
ES2015에서 추가된 새로운 자료구조.

### ✅ Map
```js
const m = new Map();
m.set('a', 'b');
m.set(3, 'c');
const obj = {};
m.set(obj, 'd');
console.log(m.get(obj)); // d
console.log(m.size); // 3
```

> 키의 타입이 자유롭고, 순서를 보장한다.

### ✅ Set
```js
const s = new Set([1, 3, 2, 7, 2, 6, 3, 5]);
console.log(s.size); // 중복 제거 → 6

s.add('A');
s.delete(3);
console.log([...s]);
```

> 중복을 허용하지 않으며, 배열의 중복 제거 용도로 자주 사용된다.

---

## 🔟 널 병합(??) / 옵셔널 체이닝(?.)
ES2020에서 추가된 문법으로, 안정성을 높여준다.

### ✅ 널 병합 연산자(??)
```js
const a = 0;
const b = a || 3; // 0이 falsy → 3
const c = a ?? 3; // null/undefined만 체크 → 0 유지
```

### ✅ 옵셔널 체이닝 연산자(?.)
```js
const c = null;
console.log(c?.d); // undefined
console.log(c?.f?.()); // undefined
console.log(c?.[0]); // undefined
```

> `?.` 덕분에 “Cannot read properties of undefined” 에러를 방지할 수 있다.

---

## 1️⃣1️⃣ 프런트엔드 자바스크립트 개요
Node.js는 백엔드뿐 아니라 **브라우저 환경**에서도 활용된다.  
HTML 내 `<script>` 태그를 통해 직접 작성할 수 있다.

---

## 1️⃣2️⃣ AJAX
AJAX(Asynchronous JavaScript And XML)는 **페이지 새로고침 없이 서버와 통신**하는 기술이다.  
보통 `axios`나 `fetch`를 이용한다.

### GET 요청
```js
axios.get('https://www.zerocho.com/api/get')
  .then(result => console.log(result.data))
  .catch(console.error);
```

### async/await 방식
```js
(async () => {
  try {
    const result = await axios.get('https://www.zerocho.com/api/get');
    console.log(result.data);
  } catch (err) {
    console.error(err);
  }
})();
```

### POST 요청
```js
(async () => {
  try {
    const result = await axios.post('https://www.zerocho.com/api/post/json', {
      name: 'zerocho',
      birth: 1994,
    });
    console.log(result.data);
  } catch (err) {
    console.error(err);
  }
})();
```

> **GET:** 데이터 요청  
> **POST:** 데이터 전송

---

## 1️⃣3️⃣ FormData
HTML의 `<form>` 데이터를 동적으로 제어할 수 있다.

```js
const formData = new FormData();
formData.append('name', 'zerocho');
formData.append('item', 'apple');
console.log(formData.get('name')); // zerocho
```

axios로 전송할 수도 있다.

```js
(async () => {
  const formData = new FormData();
  formData.append('name', 'zerocho');
  formData.append('birth', 1994);
  const result = await axios.post('https://www.zerocho.com/api/post/formdata', formData);
  console.log(result.data);
})();
```

---

## 1️⃣4️⃣ encodeURIComponent / decodeURIComponent
URL에 한글이나 특수문자가 포함될 때 인코딩/디코딩을 위한 함수.

```js
const encoded = encodeURIComponent('노드');
console.log(encoded); // %EB%85%B8%EB%93%9C
console.log(decodeURIComponent(encoded)); // 노드
```

> 서버 간 한글 통신 시 반드시 사용해야 한다.

---

## 1️⃣5️⃣ 데이터 속성과 dataset
HTML 요소에 데이터를 저장하고 JS로 접근할 수 있다.

```html
<ul>
  <li data-id="1" data-user-job="programmer">Zero</li>
</ul>

<script>
  console.log(document.querySelector('li').dataset);
  // { id: '1', userJob: 'programmer' }
</script>
```

> `data-`로 시작하는 속성은 JS에서 `dataset`으로 접근 가능하다.  
> `data-user-job` → `dataset.userJob`

---

## 🧩 의문점
### Q. JavaScript의 `async/await`와 **Python의 `async/await`(코루틴)** 은 무엇이 같고, 무엇이 다를까?

#### 1) 공통점
- 둘 다 **협력형(concoperative) 비동기** 모델: `await` 시점에 **자발적으로 제어권을 이벤트 루프에 반환**해 다른 작업이 진행됨.
- `async`로 정의된 함수는 **즉시 실행 결과를 반환**하지만, 그 값은 “나중에 완료될 것”을 나타내는 핸들(약속/작업)이다.

| 개념 | JavaScript | Python |
|---|---|---|
| 비동기 함수 반환 | **Promise** | **Coroutine** 객체 (awaitable) |
| 실행 엔진 | V8 + **libuv** 이벤트 루프 | `asyncio` 이벤트 루프 (selectors/epoll 등) |
| 동시성 방식 | 싱글 스레드 + 이벤트 루프 | 싱글 스레드 + 이벤트 루프 (필요 시 executor) |
| 동시 실행 묶기 | `Promise.all()` | `asyncio.gather()` |
| 취소 | `AbortController` (주로 I/O API 연계) | `Task.cancel()` → `asyncio.CancelledError` |

---

#### 2) 근본 차이(언어/런타임 철학)
1) **타입/프로토콜**
    - **JS:** `async function`은 항상 **Promise**를 반환. `await`는 **Promise**만(또는 thenable) 기다림.
    - **Python:** `async def`는 **Coroutine(Awaitable)**. `await`는 **Awaitable 프로토콜** 전반(`Coroutine`, `Task`, `Future`)을 기다림. 더 **범용**.

2) **스케줄링 메커니즘**
    - **JS:** 이벤트 루프 단계 + **마이크로태스크 큐(Promise callbacks)**. `await`는 마이크로태스크로 이어지며, 각 턴 끝에 우선 처리.
    - **Python:** `await` 지점에서 **즉시 양보(yield)**. 루프는 준비된 I/O·타이머·Task를 공정하게 스케줄. **마이크로태스크 큐 개념은 없음**.

3) **작업 단위**
    - **JS:** 작업은 Promise 체인/마이크로태스크 중심. 병렬화는 `Promise.all()` 등으로 **배열 단위**.
    - **Python:** **Task**(코루틴 래핑)가 1급 구성요소. `asyncio.create_task()`로 명시적으로 스케줄링/취소/타임아웃.

4) **취소/타임아웃**
    - **JS:** 표준화 진행 중이었고, 현재는 **`AbortController`** 패턴이 사실상 표준. API가 이를 **명시 지원**해야 취소가 작동.
    - **Python:** **`Task.cancel()`**로 보편 취소. 코루틴이 `CancelledError`를 전파·처리. **`asyncio.timeout()`**(3.11+) 같은 문맥도구로 일관적.

5) **스레드/CPU 바운드 연계**
    - **JS:** Node의 **libuv 스레드풀**/워커(Worker Threads) 또는 별도 프로세스.
    - **Python:** GIL로 CPU 바운드는 **`asyncio.to_thread()`/`run_in_executor()`** 또는 멀티프로세싱이 일반적.

---

#### 3) 코드로 비교

**(A) 동시에 여러 I/O 실행하기**

```js
async function fetchAll(urls) {
  const resps = await Promise.all(urls.map(u => fetch(u)));
  return Promise.all(resps.map(r => r.json()));
}
```

```python
import asyncio, aiohttp

async def fetch_all(urls):
async with aiohttp.ClientSession() as sess:
tasks = [sess.get(u) for u in urls]
resps = await asyncio.gather(*tasks)
bodies = await asyncio.gather(*[r.json() for r in resps])
return bodies
```

**(B) 개별 작업 실패 허용(부분 성공 수용)**

```js
const results = await Promise.allSettled(tasks);
// [{status:'fulfilled', value:...}, {status:'rejected', reason:...}]
```

```python
# Python
results = await asyncio.gather(*tasks, return_exceptions=True)
# 성공: 값, 실패: Exception 객체가 자리함
```
**(C) 취소/타임아웃**

```js
const ac = new AbortController();
const p = fetch(url, { signal: ac.signal });
setTimeout(() => ac.abort(), 1000);
await p; // AbortError
```

```python
import asyncio
task = asyncio.create_task(do_work())
task.cancel()  # 코루틴 내부로 CancelledError 전파

import asyncio
async with asyncio.timeout(1.0):
await do_work()   # 1초 넘으면 TimeoutError
```

---

#### 4) 예외 전파 & 정리(Cleanup)

- **JS:** `await` 시 Promise가 reject되면 **그 자리에서** throw. `try/catch/finally`로 정리.
- **Python:** `await` 시 코루틴이 예외를 **해당 시점에** throw. `CancelledError`도 일반 예외처럼 다룸.

```js
try {
  const data = await mayFail();
} catch (e) {
  // reject가 여기로 도달
} finally {
  // cleanup
}
```

```python
try:
  data = await may_fail()
except asyncio.CancelledError:
  # 취소 시 정리 로직
  raise
except Exception as e:
  ...
finally:
  # cleanup
  ...
```

---

#### 5) 디테일 
- **JS**
    - `await` 누락 시 **묵시적 병렬**이 아니라 **미처리 Promise** 방치 → 로그/메모리 누수.
    - Node 16+: 미처리 reject는 `UnhandledPromiseRejection`로 프로세스에 영향. **반드시 `catch`**.
    - **마이크로태스크 우선순위**로 인해 `setTimeout(...,0)`보다 Promise 콜백이 먼저 실행.
- **Python**
    - `async def` 호출 결과(코루틴)를 `await`하지 않으면 **`RuntimeWarning: coroutine was never awaited`**.
    - **취소 전파**를 명시적으로 고려해야 함(서브코루틴 내부에서 `CancelledError` 처리).
    - CPU 바운드 코드를 코루틴에 직접 넣지 말고 **executor/프로세스**로 분리.

---

#### 6) 결론 
- 두 언어 모두 **협력형 비동기**를 `async/await`로 깔끔히 표현하지만,
- **JS는 Promise 중심·마이크로태스크 큐**, **Python은 Coroutine/Task 중심·await 시 즉시 양보**라는 **스케줄링 철학의 차이**가 크다.
- **취소·타임아웃·작업 수명주기**는 Python이 프리미티브(Task, CancelledError)로 더 일관적이고 강력하며, JS는 API별 `AbortController` 패턴이 널리 쓰인다.
- 실무에서는 **동시성 묶기(`Promise.all` vs `asyncio.gather`)**, **에러/취소 설계**, **CPU 바운드 분리**가 승부처다.



