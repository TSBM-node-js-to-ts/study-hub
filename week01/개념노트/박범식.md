## 학습 내용

[1장 포스팅](https://bumsiku.kr/posts/node-js-introduction)

[2장 포스팅](https://bumsiku.kr/posts/javascript-es6-basics)

## 1장 추가학습 내용

> Node.js 의 스레드 풀은 Auto Scalable 인가??

### Node.js의 스레드 풀(Thread Pool) 이해

Node.js는 단일 스레드 이벤트 루프(event loop)를 기반으로 동작하지만, 내부적으로 **libuv**라는 라이브러리를 사용하여 **백그라운드 스레드 풀**을 운영합니다.  
이 스레드 풀은 비동기적으로 실행해야 하는 **블로킹 I/O 작업**(예: 파일 읽기, 암호화, DNS, 압축 등)을 처리하는 데 사용됩니다.

### 기본 구성

- **기본 스레드 수:** 4개  
- **역할:** 블로킹 작업을 비동기적으로 처리하여 이벤트 루프가 멈추지 않도록 함  
- **라이브러리:** libuv (Node.js의 비동기 I/O 엔진)

### 스레드 풀 크기 조정 방법

Node.js의 스레드 풀 크기는 환경 변수로 설정할 수 있습니다.  
`UV_THREADPOOL_SIZE` 환경 변수를 사용해 원하는 스레드 수를 지정할 수 있으며, 이는 **프로세스 시작 전에만** 적용됩니다.  
실행 중에는 동적으로 변경할 수 없습니다.

### 오토스케일링 지원 여부

Node.js의 스레드 풀은 **자동 스케일링을 지원하지 않습니다.**

- 스레드 풀 크기는 고정(fixed-size)입니다.  
- 워크로드(I/O 요청 수)가 늘어나도 자동으로 확장되지 않습니다.  
- 이는 libuv의 설계 철학이 **예측 가능한 성능**과 **낮은 오버헤드**를 유지하기 위함입니다.

### 자동 확장이 없는 이유

Node.js는 “논블로킹 I/O 중심의 경량 이벤트 루프”라는 설계를 따릅니다.  
스레드 풀은 **I/O 오프로딩**(offloading)을 위한 보조 역할일 뿐, CPU 바운드 작업을 병렬 처리하기 위한 용도가 아닙니다.  
자동 확장을 허용하면 스케줄링 및 context switching 비용이 증가하기 때문입니다.


### CPU 바운드 작업 병렬화 방법

CPU 연산이 많은 작업의 경우, 다음 대안을 고려할 수 있습니다.

| 목적 | 권장 방법 |
|------|------------|
| CPU 바운드 연산 (예: 해싱, 이미지 처리 등) | `worker_threads` 모듈 사용 |
| I/O 비동기 작업 | libuv 스레드 풀 자동 사용 |
| 멀티코어 활용 | `cluster` 모듈 또는 PM2 사용 |

### 요약 정리

| 항목 | 설명 |
|------|------|
| 기본 스레드 풀 크기 | 4 |
| 설정 방법 | `UV_THREADPOOL_SIZE` 환경 변수 |
| 오토스케일링 | ❌ 지원하지 않음 |
| 적용 시점 | Node.js 프로세스 시작 전 |
| 대체 방안 | `worker_threads`, `cluster`, `PM2` 등 |

---

## 2장 추가 학습 내용

> 2장의 Async/Await은 콜백 함수와 Promise를 완전히 대체하는 것으로 이해했는데 Async/Await 방식으로 모든 것이 가능한지? (Super Set 인지?)

### Async/Await은 Promise의 Superset인가?

Async/Await은 **Promise를 완전히 대체하는 것이 아니라, Promise를 더 쉽게 다루기 위한 문법적 설탕(Syntactic Sugar)**이다. 즉, 내부적으로는 여전히 Promise 기반으로 동작하며, Promise 없이 Async/Await만으로는 비동기 처리를 구현할 수 없다.

### 관계 요약

- **Promise**: 비동기 작업의 상태(대기 → 이행/거부)를 관리하는 객체.
- **Async/Await**: Promise를 마치 동기 코드처럼 읽기 쉽게 작성하기 위한 문법.
- **콜백(Callback)** → **Promise** → **Async/Await** 순으로 발전했지만, 완전한 대체가 아니라 “추상화의 단계 상승”이다.


### 가능한 범위

- 대부분의 비동기 로직은 Async/Await로 표현 가능하다.
- 그러나 Promise의 `Promise.all()`, `Promise.race()` 같은 병렬 실행 제어는 여전히 Promise API를 직접 사용해야 한다.
- Async/Await은 try/catch를 통한 에러 핸들링을 제공해 가독성이 높다.

### 결론

Async/Await은 Promise를 포함하는 **상위 개념(Super Set)처럼 보이지만**, **Promise를 완전히 대체하는 것은 아니다.**  
즉, Async/Await은 Promise의 표현 방식을 단순화한 문법적 래퍼(wrapper)이며, Promise의 기능을 모두 내장한 별개의 구조는 아니다.

Async/Await, Promise, Callback은 모두 비동기 처리를 다루지만, **용도와 상황**에 따라 적절히 선택하는 것이 중요하다.

### 1. Async/Await을 사용하는 경우

**가장 일반적인 선택**으로, 대부분의 비동기 코드를 작성할 때 권장된다.

- 코드 흐름이 **순차적(직렬적)**으로 진행될 때
- 에러를 **try/catch 블록**으로 간단히 처리하고 싶을 때
- 비동기 로직을 **동기 코드처럼 읽기 쉽게** 만들고 싶을 때

**예시 상황**
- API 호출 → 결과 처리 → 후속 로직 순으로 차례대로 실행할 때
- 파일 읽기 후 가공 → 데이터베이스 저장 같은 절차적 작업

### 2. Promise를 사용하는 경우

Async/Await으로도 가능하지만, 다음과 같은 경우에는 **Promise 체이닝**이 유리하다.

- **여러 비동기 작업을 동시에 실행**해야 할 때 (`Promise.all`, `Promise.race`)
- **이벤트 기반 비동기 처리**나 **스트림** 등에서 병렬 제어가 필요한 경우
- **에러 제어나 후속 처리 로직을 체이닝 형태로 명시**하고 싶을 때

**예시 상황**
- 여러 API를 병렬로 호출하고 모든 결과가 도착하면 처리할 때
- 다수의 비동기 작업을 동시 실행 후, 하나라도 완료되면 바로 결과를 반환할 때

### 3. Callback을 사용하는 경우

현재는 잘 사용되지 않지만, 다음과 같은 **저수준 제어가 필요한 경우**나 **레거시 코드**에서 사용된다.

- Promise를 지원하지 않는 오래된 API나 라이브러리 사용 시
- 이벤트 루프에 직접 접근하거나, 매우 단순한 비동기 호출만 처리할 때
- 외부 인터페이스에서 **콜백 패턴이 이미 정의되어 있을 때**

**예시 상황**
- Node.js의 일부 오래된 파일 시스템 함수(`fs.readFile(path, callback)`)
- 외부 SDK가 콜백 기반만 제공하는 경우

### 결론

| 상황 | 권장 방식 | 이유 |
|------|-----------|------|
| 순차적인 비동기 로직 | Async/Await | 가독성 높고 오류 처리 용이 |
| 병렬 실행이 필요한 경우 | Promise | 동시 처리 제어 가능 |
| 레거시 또는 저수준 API | Callback | 기존 코드 호환성 유지 |

Async/Await은 기본 선택지이지만, **Promise 병렬 제어나 콜백 기반 API 통합 시에는 보완적으로 사용**하는 것이 이상적이다.
