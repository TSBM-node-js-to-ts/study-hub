---
Author: CarefreeLife98
Date: 2025-11-01T19:51:00
Agenda:
tags:
  - TSBM
  - TSBM_STUDIO
  - NodeJS
---
# Router 객체
`express` 를 사용하는 이유 중 하나는 라우팅을 깔끔하게 관리할 수 있다는 점.

`app.js` 에서 `app.get` 같은 메서드가 바로 라우터.

```javascript
const express = require('express');

const router = express.Router();

// GET / 라우터
router.get('/', (req, res) => {
  res.send('Hello, Express');
});

module.exports = router;
```
`routes/index.js`

```javascript
const express = require('express');

const router = express.Router();

// GET /user 라우터
router.get('/', (req, res) => {
  res.send('Hello, User');
});

module.exports = router;
```
`routes/user.js`

위와 같이 만든 `index.js` 와 `user.js` 를 `app.use` 를 통해 `app.js` 에 연결한다.

```javascript
const indexRouter = require('./route/index');
const userRouter = require('./route/user');

app.use('/', indexRouter);
app.use('/user', userRouter);

// 404 에러 처리 미들웨어
app.use((req, res, next) => {
  res.status(404).send('Not Found');
});

/* 에러처리 미들 웨어 추가 */
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
});
```
`app.js`

**indexRouter 구조**
- `app.use('/')` +` router.get('/')` = **[GET] /**

**userRouter 구조**
- `app.use('/user')` + `router.get('/')` = **[GET] /user**

위와 같이 **`app.use` 로 연결할 때 주소가 합쳐진다는 것을 염두.**

![[스크린샷 2025-11-01 오후 4.50.40.png]]
![[스크린샷 2025-11-01 오후 4.50.50.png]]

`next('route')` 함수를 통해 **다음 라우터로 넘어갈 수 있는 기능**을 앞서 소개했었다.
이 기능은 **현재 라우터에 연결된 나머지 미들웨어들을 건너뛰고 싶을때 사용**한다.

```javascript
router.get('/', (req, res, next) => {
  // 해당 함수를 통해 현재 라우터에 연결된 미들웨어를 건너뛰고 바로 다음 라우터로 이동.
  next('route');
}, (req, res, next) => {
  console.log('실행되지 않습니다');
  next();
}, (req, res, next) => {
  console.log('실행되지 않습니다');
  next();
});

router.get('/', (req, res) => {
  console.log('실행됩니다');
  res.send('Hello, Express');
});
```
`next('route')`

위 예제처럼 같은 주소의 라우터를 여러 개 만들어도 된다.
`next()` 를 호출하면 **해당 라우터에 장착된 미들웨어가 실행**되며, `next('route')` 를 호출하면 **현재 라우터에 장착된 미들웨어를 뛰어넘고 주소와 일치하는 다음 라우터로 이동**한다.

## Router 주소 표현 방식: 라우트 매개 변수
라우터 주소에는 **정규표현식을 비롯한 특수패턴을 사용**할 수 있다.
그 중 자주 사용하는 **라우트 매개변수 방식**은 아래와 같이 사용한다.

```javascript
router.get('/user/:id', (req, res) => {
  console.log(req.params, req.query);
});
```
`라우트 매개 변수 형식 /:{param}`

주소에 `:id` 와 같은 형식을 볼 수 있다.
이는 해당 문자를 그대로 주소로 사용하는 것이 아니라, **해당 위치에 id 라는 키를 가진 동적인 값이 들어올 수 있음을 표현**한다.
- 예: "/user/1", "/user/123"

이는 `req.params` 객체에 저장되어 있다.
- **:id 인 경우:** `req.params.id`
- **:type 인 경우:** `req.params.type`

이 패턴을 사용할 때 **주의점은 일반 라우터보다 후순위에 위치**해야 한다는 것.

```javascript
router.get('/user/:id', (req, res) => {
  console.log('얘만 실행된다.');
});
router.get('/user/like', (req, res) => {
  console.log('전혀 실행되지 않는다.');
});
```
`라우트 매개변수 형식 주의점`

`/user/:id` 는 **와일드 카드와 같은 역할**을 하기 때문에, 동일한 depth 의 모든 주소를 점유할 수 있다. 
따라서 **같은 depth 를 가지는 일반 라우터는 라우트 매개변수를 쓰는 라우터보다 상단에 위치해야 처리될 수 있다.**

주소에 **쿼리스트링**을 사용할 수도 있다.
**쿼리스트링의 키-값 정보는 req.query 객체에 저장**된다.

- **요청 주소** : `/user/123?limit=5&skip=10`
	- **req.params** : `{ id: '123' }`
	- **req.query** : `{ limit: '5', skip: '10' }`

## 라우터 활용법
### 주소는 같지만 메서드가 다른 경우

```javascript
router.get('/abc', (req, res) => {
  res.send('GET /abc');
});
router.post('/abc', (req, res) => {
  res.send('POST /abc');
});

// 위와 같이 같은 주소를 가지지만, 메서드가 다른 경우 아래와 같이 같은 주소로 묶을 수 있다.

router.route('/abc')
  .get((req, res) => {
    res.send('GET /abc');
  })
  .post((req, res) => {
    res.send('POST /abc');
  });
```

# express 의 req, res 객체
**익스프레스의 req, res 객체는 Node.js - http 모듈의 req, res 객체를 `확장`한 것.**

따라서 **기존 http 모듈의 메서드도 사용**할 수 있고, **익스프레스가 추가한 메서드나 속성을 사용**할 수도 있다. (하지만 익스프레스의 메서드가 워낙 편리하므로 기존 http 모듈의 메서드는 잘 쓰이지 않음)

# 자주 쓰이는 속성과 메서드 (req)
- `req.app` : req 객체를 통해 app 객체에 접근할 수 있다. **req.app.get('port')**
- `req.body` : body-parser 미들웨어가 만드는 **요청의 본문을 해석한 객체.**
- `req.cookies`: cookie-parser 미들웨어가 만드는 **요청의 쿠키를 해석한 객체.**
- `req.ip` : **요청의 ip 주소**.
- `req.params` : **라우트 매개변수**에 대한 정보가 담긴 객체.
- `req.query` : **쿼리스트링에 대한 정보**가 담긴 객체.
- `req.signedCookies` : **서명된 쿠키**들은 req.cookies 대신 여기에 저장.
- `req.get(헤더 이름)` : **헤더의 값**을 가져오고 싶을 때 사용하는 메서드.

# 자주 쓰이는 속성과 메서드 (res)
- `res.app` : **res 객체를 통해 app 객체에 접근**할 수 있다.
- `res.cookie(키, 값, 옵션)` : **쿠키를 설정**하는 메서드.
- `res.clearCookie(키, 값, 옵션)` : **쿠키를 제거**하는 메서드.
- `res.end()` : **데이터 없이 응답**을 전송.
- `res.json(JSON)` : **JSON 형식의 응답**을 전송.
- `res.locals` : **하나의 요청 안에서 미들웨어 간에 데이터를 전달하고 싶을 때 사용하는 임시** 객체.
- `res.redirect(주소)` : **리다이렉트할 주소와 함께 응답**.
- `res.render(뷰, 데이터)` : **템플릿 엔진을 렌더링해서 응답할 때 사용**하는 메서드.
- `res.send(데이터)` : **데이터와 함께 응답**을 보냅니다. 문자열, HTML, 버퍼, 객체, 배열 등.
- `res.sendFile(경로)` : 경로에 위치한 **파일을 응답**.
- `res.set(헤더, 값)` : **응답의 헤더를 설정**.
- `res.status(코드)` : 응답 시의 **HTTP 상태 코드를 지정**.

# req, res 객체의 메서드 체이닝 (method chaining)
**메서드 체이닝**을 활용하면 **코드양을 줄일 수 있다.**

```javascript
res
  .status(201)
  .cookie('test', 'test')
  .redirect('/admin');
```
`express - req,res 객체의 메서드 체이닝`

# 템플릿 엔진 (template-engine) 이란?

**템플릿 엔진(template engine)** 은 “코드 + 데이터 → HTML 등 결과 문자열” 을 만들어주는 도구를 말한다.

또한, 단순히 미리 정의된 템플릿 (HTML) 에 데이터를 넣어 완성된 문자열 (HTML) 을 만드는 도구로서 정의되므로 **어디에서 실행되는지에 따라 SSR (Server Side Rendering) / CSR (Client Side Rendering) 이 될 수 있다.**

자바스크립트 진영에서는 대표적으로 `퍼그 (Pug)` 와 `넌적스 (Nunjucks)` 라는 템플릿 엔진이 있다.

# 퍼그 (구: 제이드)
![[Pasted image 20251101181052.png]]
`Pug 로고`

```bash
$ npm i pug
```
`pug 설치`

익스프레스와 연결하려면 `pug` 설치 후 `app.js` 에 아래와 같이 설정해주어야 한다.

```javascript
...
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'pug');
...
```
`app.js`

`views` 는 **템플릿 파일들이 위치한 폴더**를 지정.
`res.render` 메서드가 **이 폴더를 기준으로 템플릿 엔진을 찾아서 렌더링** 한다.
- `res.render('index')` : **views/index.pug** 를 렌더링.
- `res.render('admin/main')` : **views/admin/main.pug** 를 렌더링.

`view engine` 은 **어떤 종류의 템플릿 엔진**을 사용할지를 설정.

## Pug 의 HTML 표현 방식

기존 HTML 과 다르게 `<`, `>` 와 닫는 태그가 없다.
따라서 **`탭 / 스페이스` 와 같은 공백을 기준으로 태그의 계층을 규명**한다.
- **공백의 크기는 상관없는 대신, 모든 파일에 동일한 크기의 들여쓰기를 사용**해야한다.

`<`, `>` 를 사용하여 태그 를 표현하지 않으므로, 태그의 속성 또한 태그명 뒤에 소괄호로 묶어 사용하는 등 조금 다르게 표현된다.

![[스크린샷 2025-11-01 오후 6.26.11.png]]
`pug 와 html 의 작성법 비교`

**속성 중 아이디와 클래스**가 있는 경우 아래와 같이 표현한다. (`div` 태그는 `div` 문자 생략 가능)
![[스크린샷 2025-11-01 오후 6.27.06.png]]

HTML 텍스트는 아래와 같이 **태그 / 속성 뒤에 한 칸을 띄어 입력**한다.
![[스크린샷 2025-11-01 오후 6.29.40.png]]

여러 줄의 텍스트를 입력하는 경우 파이프 (|) 를 사용하여 입력.
![[스크린샷 2025-11-01 오후 6.30.46.png]]

`style / script` 태그를 사용한 `css / javascript` 코드를 작성하려면 태그 뒤에 점(.) 을 붙힌다.
![[스크린샷 2025-11-01 오후 6.31.43.png]]

## Pug 의 변수 사용법

### express 의 res.render 메서드

**정적 HTML 파일과 다르게 자바스크립트 변수를 템플릿에 렌더링** 할 수 있다.
`res.render` 를 호출할 때 변수를 담으면 `Pug` 가 처리한다.

```javascript
router.get('/', (req, res, next) => {
  res.render('index', { title: 'Express' });
});
```
`routes/index.js`

`res.render(템플릿, 변수 객체)` 는 익스프레스가 `res` 객체에 추가한 템플릿 렌더링을 위한 메서드이다.

> `index.pug` 를 HTML 로 렌더링하며 `{ title: 'Express' }` 라는 객체를 변수로 주입.

`layout.pug` 와 `index.pug` 의 `title` 부분이 모두 'Express' 로 **치환**된다.


#### 추가 활용법 - res.locals 객체 기반 렌더링

아래와 같이 `res.locals` 객체를 활용하여 변수를 넣는 방법도 있다.

```javascript
router.get('/', (req, res, next) => {
  res.locals.title = 'Express';
  res.render('index');
});
```

- 이 경우 템플릿 엔진이 res.locals 객체를 읽어 변수를 주입한다.
- 타 **미들웨어에서 `res.locals` 객체에 템플릿 엔진용 변수를 미리 지정**할 수 있다.


### Pug 의 변수 사용법
![[스크린샷 2025-11-01 오후 6.44.17.png]]
`서버로부터 받은 변수는 다양한 방식으로 퍼그에서 사용 가능하다`

- **변수를 텍스트로 사용** : `태그=변수`, `속성=변수`
- **텍스트 중간에 변수 사용** : `#{변수}`

**`#{}` 내부와 `=` 기호 뒷부분은 자바스크립트로 해석**하므로 `input` 태그의 경우처럼 자바스크립트 구문도 사용 가능하다.

내부에 직접 변수를 선언할 수도 있다.

`- (대시)` 를 먼저 입력하면 뒤에 자바스크립트 구문을 작성할 수 있다.
- 이곳에 변수를 선언하면 **다음 줄부터 해당 변수 사용 가능.**

![[스크린샷 2025-11-01 오후 6.49.59.png]]

퍼그는 기본적으로 **변수의 특수 문자를 `HTML Entity` 로 `Escape` 처리**한다.
Escape 처리를 원하지 않는다면 `=` 대신 `!=` 를 사용하면 된다.

![[스크린샷 2025-11-01 오후 6.51.49.png]]

### Pug 의 반복문

**반복 가능한 변수인 경우** `each / for` 를 통한 반복문을 사용할 수 있다.

![[스크린샷 2025-11-01 오후 6.54.44.png]]
`each 를 사용한 반복문 사용`

![[스크린샷 2025-11-01 오후 6.55.32.png]]
`반복문 사용시 인덱스 또한 사용 가능하다`


### Pug 의 조건문
`if` , `else if` , `else` 사용 가능.

![[스크린샷 2025-11-01 오후 6.56.36.png]]
`if / else 문 사용 예시`

`case` 문 또한 사용 가능하다.
![[스크린샷 2025-11-01 오후 6.57.34.png]]
`case 문 사용 예시`

### Pug 의 include 기반 컴포넌트 분리

![[스크린샷 2025-11-01 오후 6.58.32.png]]
`include header / footer 기반 컴포넌트 분리 및 재사용`

### Pug 의 레이아웃 지정 (extends / block)
레이아웃을 정할 수 있으며, 공통되는 레이아웃 부분을 따로 관리할 수 있다.

![[스크린샷 2025-11-01 오후 7.00.45.png]]
- 레이아웃이 될 파일에는 공통된 마크업을 정의.
- 페이지마다 달라질 부분을 `block` 으로 비워둔다.
	- `block {블록 명}` 과 같은 형태로 선언.
- `block` 파일에는 `extends` 키워드로 레이아웃 파일을 지정하고 블록 부분을 작성.
	- 추후 익스프레스에서 `res.render('body')` 를 사용해 **하나의 HTML 로 합쳐 렌더링** 할 수 있다.

# 넌적스 (Nunjucks)
넌적스는 앞서 본 퍼그의 HTML 문법 사용 방식의 변화가 어려운 사람들을 위해 모질라에서 만들어졌다.

```bash
$ npm i nunjucks
```
`넌적스 설치`

`view engine` 을 넌적스로 교체.

```javascript
const nunjucks = require('nunjucks');

app.set('view engine', 'html');
nunjucks.configure('views', {
  express: app,
  watch: true,
});
```
`view engine 교체 및 넌적스 초기화`

퍼그와는 연결 방법이 다소 다른것을 볼 수 있다.
`nunjucks.configure` 의 **첫번째 인수로 views 폴더 경로**를 지정하고 **두번째 인수로 옵션**을 지정한다.
- 이때 `express` 속성에 `app` 객체를 연결
- `watch=true` 인경우 **HTML 파일이 변경될 때 템플릿 엔진을 다시 렌더링.**

## 넌적스의 변수 사용법
이제 `view engine` 으로 넌적스를 연결했으니, `res.render` 호출 시 변수를 넌적스가 처리한다.

```html
<h1>{{title}}</h1> // 변수
<p>Welcome to {{title}}</p> // 변수
<button class="{{title}}" type="submit">전송</button>
<input placeholder="{{title}} 연습" />
```
`넌적스에서 변수는  {{변수명}} 으로 감싼다.`

**내부에 변수를 사용할 수도 있다.** 변수를 선언하는 경우 `{% set 변수 = '값' %}` 와 같이 사용한다.

```html
{% set node = 'Node.js' %}
{% set js = 'Javascript' %}
<p>{{node}}와 {{js}}</p>
```
`넌적스: 변수 선언`

HTML 을 이스케이프하고 싶지 않다면, `{{ 변수 | safe }}` 를 사용.
```html
<p>{{'<strong>이스케이프</strong>'}}</p>
<p>{{'<strong>이스케이프하지 않음</strong>' | safe }}</p>
```
`넌적스: HTML 이스케이프 처리 제외`

## 넌적스의 반복문 사용법
넌적스에서는 특수한 문을 `{% %}` 내부에 작성한다. 따라서 반복문도 `{% %}` 내부에 작성한다.

![[스크린샷 2025-11-01 오후 7.30.55.png]]
`넌적스: 반복문`

넌적스의 반복문에서 인덱스를 사용하려면 `loop.index` 라는 특수한 변수를 사용해야 한다.
![[스크린샷 2025-11-01 오후 7.31.29.png]]
`넌적스: 반복문에서 인덱스 값 사용`

## 넌적스의 조건문 사용법
조건문은 아래와 같이 이루어져 있다.
- `{% if 변수 %}`
- `{% elif %}`
- `{% else %}`
- `{% endif %}`

![[스크린샷 2025-11-01 오후 7.33.01.png]]
`넌적스: 조건문`

`case` 문은 없으며 (...) `elif` 를 통해 분기 처리해야 한다.
![[스크린샷 2025-11-01 오후 7.33.39.png]]
`넌적스: elif 조건문`

`{{ }}` 안에서는 아래와 같이 사용한다.

```html
<div>{{'참' if isLoggedIn}}</div>
<div>{{'참' if isLoggedIn else '거짓'}}</div>
```
`넌적스: {{}} 내부 조건문`

## 넌적스의 include
퍼그와 마찬가지로 **다른 파일을 불러와 사용**할 수 있다.

**헤더나 푸터, 내비게이션처럼 웹 제작 시 공통되는 부분을 따로 관리**할 수 있어 컴포넌트를 재사용할 수 있다.
- `include 파일경로` 와 같은 형태로 사용

![[스크린샷 2025-11-01 오후 7.37.59.png]]
`넌적스: include 를 통한 HTML 재사용`

## 넌적스의 extends 와 block
공통되는 레이아웃을 따로 분리하여 관리할 수 있다.

```html
<!-- layout.html -->

<!DOCTYPE html> 
<html> 
  <head> 
    <title>{{title}}</title> 
    <link rel="stylesheet" href="/style.css" /> 
    {% block style %} 
    {% endblock %} 
  </head> 
  <body> 
    <header>헤더입니다.</header> 
    {% block content %} 
    {% endblock %} 
    <footer>푸터입니다.</footer> 
    {% block script %} 
    {% endblock %} 
  </body> 
</html>
```
`넌적스: 레이아웃 파일`

- 공통된 마크업을 작성
- 페이지마다 달라질 부분을 `block` 으로 비워둠
	- `{% block {블록명} %}` 과 같이 선언.
	- `{% endblock %}` 으로 블록을 종료.


```html
<!-- body.html -->
{% extends 'layout.html' %} 

{% block content %} 
<main> 
  <p>내용입니다.</p> 
</main> 
{% endblock %} 

{% block script %} 
<script src="/main.js"></script> 
{% endblock %}
```
`넌적스: block 파일`

- `{% extends 경로 %}` 키워드로 레이아웃 파일 지정.
- 추후 익스프레스에서 `res.render('body')` 를 통해 하나의 HTML 로 합쳐 렌더링.

## 넌적스 실습
```html
<!-- layout.html -->

<!DOCTYPE html>
<html>
  <head>
    <title>{{title}}</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    {% block content %}
    {% endblock %}
  </body>
</html>
```
`layout.html`

```html
<!-- index.html -->
{% extends 'layout.html' %}

{% block content %}
<h1>{{title}}</h1>
<p>Welcome to {{title}}</p>
{% endblock %}
```
`index.html`

```html
<!-- error.html -->
{% extends 'layout.html' %}

{% block content %}
<h1>{{message}}</h1>
<h2>{{error.status}}</h2>
<pre>{{error.stack}}</pre>
{% endblock %}
```
`error.html`

## 에러 페이지 렌더링 (feat. 에러 처리 미들웨어)

**404 응답 미들웨어와 에러 처리 미들웨어에서 에러 페이지로 렌더링 하도록 수정.**

```javascript
// app.js

app.use((req, res, next) => {
  const error =  new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

app.use((err, req, res, next) => {
  res.locals.message = err.message;
  res.locals.error = process.env.NODE_ENV !== 'production' ? err : {};
  res.status(err.status || 500);
  res.render('error');
});
```
`app.js`

