## Router 객체

⇒ express에서는 코드의 가독성을 위해 라우터를 분리할 수 있는 방법을 제공

따라서 router 객체로 라우팅 분리가 가능함.

```jsx
//routes/index.js
const express = require('express');

const router = express.Router();

// GET / 라우터
router.get('/', (req, res) => {
  res.send('Hello, Express');
});

module.exports = router;
```

```jsx
//routes/user.js
const express = require('express');

const router = express.Router();

// GET /user 라우터
router.get('/', (req, res) => {
  res.send('Hello, User');
});

module.exports = router;
```

현재 app.js 코드

```jsx

const express = require('express');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const dotenv = require('dotenv');
const path = require('path');

dotenv.config();
const indexRouter = require('./routes'); //6.3장
const userRouter = require('./routes/user'); //6.3장

const app = express();
app.set('port', process.env.PORT || 3000);

app.use(morgan('dev'));
app.use('/', express.static(path.join(__dirname, 'public')));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(process.env.COOKIE_SECRET));
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: {
    httpOnly: true,
    secure: false,
  },
  name: 'session-cookie',
}));

app.use('/', indexRouter);
app.use('/user', userRouter);

app.use((req, res, next) => {
  res.status(404).send('Not Found');
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

`require('./routes/index.js') = require('./routes')`

같은 의미이다.

### 라우터에 연결된 나머지 미들웨어 건너뛰고 싶을 때

`next('route')`

```jsx
router.get('/', (req, res, next) => {
  **next('route');**
}, (req, res, next) => {
  console.log('실행되지 않습니다');
  next();
}, (req, res, next) => {
  console.log('실행되지 않습니다');
  next();
});
router.get('/', (req, res) => {
  console.log('실행됩니다');
  res.send('Hello, Express');
});
```

### 라우트 매개변수

```jsx
router.get('/user/:id', (req, res) => {
  console.log(req.params, req.query);
});
```

주소 :id 의 형태로, /users/1 or /user/234 등의 요청 처리

해당되는 1과 234의 값들은 `req.params`객체 안에 들어있다.

**주의사항**

:id 형태의 라우트 매개변수는 일반 라우터 아래에 위치해야한다.

```jsx
router.get('/user/:id', (req, res) => {
  console.log('실행');
});
router.get('/user/like', (req, res) => {
  console.log('실행X');
});
```

## req, res 객체

express의 req,res 객체는 http 모듈의 req,res 객체를 확장한 것.

- 기존 http 모듈의 메서드 사용가능
- 익스프레스 추가 메서드 or 속성 사용가능

### [req] 자주 쓰이는 메서드

- req.app: req 객체를 통해 **app 객체에 접근** 가능, **req.app.get('port')**와 같은 식으로 사용 가능
- req.body: body-parser 미들웨어가 만드는 요청의 **본문을 해석**한 객체
- req.cookies: cookie-parser 미들웨어가 만드는 요청의 **쿠키를 해석**한 객체
- req.ip: **요청의 ip 주소**가 담김
- req.params: **라우트 매개변수에** 대한 정보가 담긴 객체
- req.query: **쿼리스트링**에 대한 정보가 담긴 객체
- req.signedCookies: 서명된 쿠키들은 req.cookies 대신 여기에 담겨 있습니다.
- req.get(헤더 이름): 헤더의 값을 가져오고 싶을 때 사용하는 메서드입니다.

### [res] 자주 쓰이는 메서드

- res.app: req.app처럼 res 객체를 통해 app 객체에 접근할 수 있습니다.
- res.cookie(키, 값, 옵션): 쿠키를 설정하는 메서드입니다.
- res.clearCookie(키, 값, 옵션): 쿠키를 제거하는 메서드입니다.
- res.end(): 데이터 없이 응답을 보냅니다.
- res.json(JSON): JSON 형식의 응답을 보냅니다.
- res.locals: 하나의 요청 안에서 미들웨어 간에 데이터를 전달하고 싶을 때 사용하는 객체입니다.
- res.redirect(주소): 리다이렉트할 주소와 함께 응답을 보냅니다.
- res.render(뷰, 데이터): 다음 절에서 다룰 템플릿 엔진을 렌더링해서 응답할 때 사용하는 메서드입니다.
- res.send(데이터): 데이터와 함께 응답을 보냅니다. 데이터는 문자열일 수도, HTML일 수도, 버퍼일 수도, 객체나 배열일 수도 있습니다.
- res.sendFile(경로): 경로에 위치한 파일을 응답합니다.
- res.set(헤더, 값): 응답의 헤더를 설정합니다.
- res.status(코드): 응답 시의 HTTP 상태 코드를 지정합니다.

## 템플릿 엔진

퍼그(Pug)와 넌적스(Nunjucks)

### 퍼그(제이드)

사용법 : `npm i pug`

express와 연결하는 방법

```jsx
app.set('port', process.env.PORT || 3000);
**app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'pug');

app.use(morgan('dev'));**
```

- views : 템플릿 파일들이 위치한 폴더 지정

### HTML과 PUG의 차이점

| 퍼그 | HTML |
| --- | --- |
| doctype html
html
    head
        title = title
        link(rel=”stylecheet”, href=’/stylesheets/style.css’) | <!DOCTYPE html>
<html>
    <head>
        <title>익스프레스</title>
        <link rel=”stylesheet” href=”/style.css”/>
    </head>
</html> |
| #login-button | <div id="login-button"></div> |
| p Welcome to Express | <p>Welcome to Express</p> |
| button(type=”submit”) 전송 | <button type=”submit”>전송</button> |
| 여러 줄 인 경우 `|` 사용 | <br/> |
| style.
scipt. | <style>
<script> |

### 변수

HTML과 달리 **자바스크립트 변수를 템플릿에서 직접 렌더링**할 수 있음

`res.render('index', { title: 'Express' })`

를 호출하면, `index.pug`에서 `title` 변수를 바로 사용할 수 있음

```
h1= title
p Welcome to #{title}
button(class=title, type='submit') 전송
input(placeholder=title + ' 연습')
```

= 또는 #{} 로 변수를 사용 가능하며, 

#{} 내부와 = 뒤는 자바스크립트 문법으로 해석됨.

변수를 직접 선언하고 사용할 수도 있음

- 를 먼저 입력하면 자바스크립트 구문 작성이 가능

```
- const node = 'Node.js'
- const js = 'Javascript'
p #{node}와 #{js}
```

---

### HTML 이스케이프

- Pug는 특수 문자를 자동으로 HTML 엔티티로 변환
- 이스케이프를 원하지 않으면 `=` 대신 `!=` 사용

```
p= '<strong>이스케이프</strong>'
p!= '<strong>이스케이프하지 않음</strong>'
```

| 특수문자 | HTML 엔티티 |
| --- | --- |
| `<` | `&lt;` |
| `>` | `&gt;` |
| `&` | `&amp;` |
| `'` | `&apos;` |
| `"` | `&quot;` |

---

### 반복문

`each` 또는 `for` 문을 사용해 배열이나 반복 가능한 데이터를 출력 가능

```
ul
  each fruit in ['사과', '배', '오렌지']
    li= fruit
```

```
//인덱스도 함께 사용 가능
ul
  each fruit, index in ['사과', '배', '오렌지']
    li= (index + 1) + '번째 ' + fruit
```

---

### 조건문

`if`, `else if`, `else`, `case` 문으로 분기 처리 가능

```
if isLoggedIn
  div 로그인 되었습니다.
else
  div 로그인이 필요합니다.

```

```
case fruit
  when 'apple'
    p 사과입니다.
  when 'banana'
    p 바나나입니다.
  default
    p 다른 과일입니다.
```

---

### include

공통된 레이아웃(헤더, 푸터 등)을 다른 파일로 분리하고 불러올 수 있음

```
// header.pug
header
  a(href='/') Home
  a(href='/about') About

// main.pug
include header
main
  h1 메인 파일
  p 다른 파일을 include할 수 있음
include footer
```

---

### extends와 block

공통 레이아웃을 정의하고, 각 페이지별로 다른 내용만 block으로 채울 수 있음

```
// layout.pug
doctype html
html
  head
    title= title
    link(rel='stylesheet', href='/style.css')
  body
    header 헤더입니다.
    block content
    footer 푸터입니다.
```

```
// body.pug
extends layout

block content
  main
    p 내용입니다.
```

layout.pug의 block content 부분에 body.pug의 내용이 삽입됨

여러 페이지에서 같은 레이아웃을 재사용할 수 있음

---

### 예시: views 폴더 구조

```
views/
 ├── layout.pug
 ├── index.pug
 └── error.pug
```

```
// index.pug
extends layout
block content
  h1= title
  p Welcome to #{title}

// error.pug
extends layout
block content
  h1= message
  h2= error.status
  pre #{error.stack}
```

---

### 6.5.2 넌적스(Nunjucks)

- 퍼그의 들여쓰기 문법이 익숙하지 않은 사람을 위해 만들어진 엔진
- HTML 문법을 그대로 사용하며, `{% %}` 와 `{{ }}` 문법을 지원
- 모질라에서 개발

```bash
npm i nunjucks
```

app.js 설정:

```jsx
const nunjucks = require('nunjucks');
app.set('view engine', 'html');
nunjucks.configure('views', {
  express: app,
  watch: true,
});
```

---

### 변수

넌적스는 변수를 `{{ }}`로 감싼다.

```html
<h1>{{title}}</h1>
<p>Welcome to {{title}}</p>
<button class="{{title}}" type="submit">전송</button>
```

변수 선언은 `{% set 변수명 = 값 %}` 형태

```html
{% set node = 'Node.js' %}
{% set js = 'Javascript' %}
<p>{{node}}와 {{js}}</p>
```

HTML 이스케이프를 원하지 않으면 `| safe`를 붙인다.

```html
<p>{{'<strong>이스케이프</strong>'}}</p>
<p>{{'<strong>이스케이프하지 않음</strong>' | safe }}</p>
```

---

### 반복문

`{% for item in list %}` ~ `{% endfor %}` 구조를 사용

```html
{% set fruits = ['사과', '배', '오렌지'] %}
<ul>
  {% for item in fruits %}
    <li>{{loop.index}}번째 {{item}}</li>
  {% endfor %}
</ul>
```

⇒ loop.index로 인덱스 값을 가져올 수 있다.

---

### 조건문

`{% if %}`, `{% elif %}`, `{% else %}` 로 분기 가능

```html
{% if isLoggedIn %}
<div>로그인 되었습니다.</div>
{% else %}
<div>로그인이 필요합니다.</div>
{% endif %}
```

```html
//짧은 표현도 가능
<div>{{'참' if isLoggedIn else '거짓'}}</div>
```

---

### include

공통 파일을 불러와 재사용 가능하다.

```html
{% include "header.html" %}
<main>
  <h1>메인 파일</h1>
</main>
{% include "footer.html" %}
```

---

### extends와 block

공통 레이아웃을 지정하고, 페이지별 block을 채워 넣는 방식

```html
<!-- layout.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>{{title}}</title>
    <link rel="stylesheet" href="/style.css" />
    {% block style %}{% endblock %}
  </head>
  <body>
    <header>헤더입니다.</header>
    {% block content %}{% endblock %}
    <footer>푸터입니다.</footer>
    {% block script %}{% endblock %}
  </body>
</html>
```

```html
<!-- body.html -->
{% extends 'layout.html' %}
{% block content %}
<main><p>내용입니다.</p></main>
{% endblock %}
```

---

### 에러 처리 미들웨어

서버에서 존재하지 않는 라우터에 접근하거나 에러가 발생하면

404 페이지나 에러 페이지를 렌더링

```jsx
app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

app.use((err, req, res, next) => {
  res.locals.message = err.message;
  res.locals.error = process.env.NODE_ENV !== 'production' ? err : {};
  res.status(err.status || 500);
  res.render('error');
});
```

- `next(error)` → 인수가 에러 처리 미들웨어의 `err`로 전달됨
- `res.locals`에 저장된 값은 템플릿에서 바로 사용 가능
- `error.stack`은 개발 환경에서만 표시, 배포 시에는 숨김
    
    (보안상 서버 구조 노출 방지)