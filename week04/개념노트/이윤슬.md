
## 목차
- [next()와 next('route')의 차이](#next와-nextroute의-차이)
- [라우트 매개변수와 정규식](#라우트-매개변수와-정규식)
- [req.params, req.query, req.body 구분](#reqparams-reqquery-reqbody-구분)
- [미들웨어 스택과 404 처리](#미들웨어-스택과-404-처리)
- [템플릿 엔진의 필요성](#템플릿-엔진의-필요성)
- [주요 템플릿 엔진 비교](#주요-템플릿-엔진-비교)

---

## next()와 next('route')의 차이

### 기본 동작 방식

`next()`와 `next('route')`는 미들웨어 흐름을 제어하는 방식이 다르다.

- **next()**: 현재 레이어의 다음 핸들러로 이동한다. 같은 라우터에 묶인 미들웨어 체인을 순차적으로 실행한다.
- **next('route')**: 현재 라우터 체인을 탈출하고, 같은 경로와 매칭되는 다음 라우터로 점프한다. 현재 라우터에 남은 핸들러들은 모두 건너뛴다.

```js
router.get('/', (req, res, next) => {
  if (!req.user) return next('route'); // 현재 체인 탈출
  next();
}, (req, res) => {
  res.send('로그인 사용자 전용');
});

router.get('/', (req, res) => {
  res.send('게스트 전용');
});
```

### 내부 메커니즘

Express는 라우터 내부에 `stack`(레이어 배열)을 유지한다. 각 레이어는 `path`, `method`, `handle`을 가진다.

- `next()`는 같은 레이어 체인에서 인덱스를 +1 하며 진행
- `next('route')`는 현재 라우터의 체인 인덱스를 끝으로 건너뛰어 다음 라우터 레이어 탐색으로 넘어감

### app.use()에서 사용 불가능한 이유

`app.use()`는 전역 미들웨어 레이어이지 라우트 체인이 아니다. `next('route')`는 "같은 경로, 같은 메서드에 묶인 라우트 체인"이라는 문맥이 있을 때만 의미가 있다. 전역 미들웨어에는 "다음 라우터로 점프"라는 개념 자체가 없음!

전역에서 분기하려면 조건부 `return next()`를 사용하거나 라우팅 구조를 재구성해야 한다.

### 실무 활용

`next('route')`는 조건부 접근 제어(로그인, 권한, AB 테스트)같은 빠른 탈출(early exit)에 유용하다. 하지만 남용하면 제어 흐름이 난해해지므로, 핸들러를 분리하는 구조가 더 읽기 좋다.

---

## 라우트 매개변수와 정규식

### 매개변수 매칭 원리

Express는 경로 패턴을 정규식으로 컴파일하고, 캡처 그룹으로 추출한 값을 `req.params`에 매핑한다.

```js
router.get('/user/:id', (req, res) => {
  // /user/123 → req.params = { id: '123' }
  res.json(req.params);
});
```

`/user/:id`는 내부적으로 `/^\/user\/([^/]+?)\/?$/` 같은 정규식으로 변환되고, 첫 번째 캡처가 `params.id`에 할당된다.

### 정규식 제약 추가

패턴에 정규식을 추가해서 매칭 범위를 제한할 수 있다.

```js
router.get('/user/:id(\\d+)', handler);
```

위 라우트는 `/user/123`은 매칭하지만 `/user/abc`는 매칭하지 않는다.

**장점:**
- 의도하지 않은 라우트 오인 매칭을 줄인다 (예: `/user/search`가 숫자 id 라우트로 잘못 매칭되는 것을 방지)
- 입력 유효성을 URL 레벨에서 1차 보장한다

물론 서버단 스키마 검증(zod, joi, express-validator)은 별도로 수행해야 한다.

### 라우트 선언 순서

와일드카드(`*`)나 느슨한 패턴(`/:id`)은 매칭 범위가 넓기 때문에 항상 뒤에 두어야 한다. Express는 등록 순서대로 스택을 순회하므로, 상단에 와일드카드가 있으면 아래 상세 라우트를 영원히 가린다.

```js
router.get('/user/like', specificHandler);         // 1) 구체적 경로
router.get('/user/:id(\\d+)', numericHandler);     // 2) 제약 있는 매개변수
router.get('/user/:id', genericHandler);           // 3) 제약 없는 매개변수
router.get('/user/*', wildcardHandler);            // 4) 와일드카드(항상 맨 끝)
```


---

## req.params, req.query, req.body 구분

### 세 가지 데이터 소스

| 구분 | 추출 위치 | 전형적 용도 | 형 변환 | 전처리 필요 |
|------|----------|------------|---------|------------|
| `req.params` | URL Path (`/users/:id`) | 리소스 식별자 | 전부 문자열 | X |
| `req.query` | Query String (`?q=abc&limit=10`) | 필터, 페이지네이션, 옵션 | 전부 문자열(배열 가능) | `app.set('query parser')` 설정 가능 |
| `req.body` | Request Body (JSON/Form) | 생성, 수정 데이터 | 타입 유지(JSON) | body-parser 계열 미들웨어 필수 |

**중요한 점:**
- GET, POST 모두 `req.query`는 유효하다 (HTTP 규약상 GET에도 쿼리 허용)
- `req.body`는 본문이 있는 메서드(POST, PUT, PATCH)와 파서 미들웨어가 있어야 파싱된다

```js
app.use(express.json());                          // JSON
app.use(express.urlencoded({ extended: true }));  // form-encoded
```

### URLSearchParams vs req.query

- **URLSearchParams**: 브라우저/Node 표준 API로 순수 객체가 아니다. `get`, `getAll`, `has`, `toString` 등 메서드를 제공하며 순서와 중복 키를 보존
- **req.query**: Express가 파싱한 일반 객체. 값은 문자열 또는 문자열 배열



### 실무 활용

- 숫자, 불리언, 배열 쿼리는 스키마로 변환/검증한 뒤 사용
  ```js
  z.object({ limit: z.coerce.number().int().min(1).max(100) })
  ```
params는 리소스 식별, query는 옵션/필터, body는 내용물

---

## 미들웨어 스택과 404 처리

### 스택 관리 원리

Express는 등록 순서대로 레이어 스택을 순회한다.

1. 경로/메서드가 맞으면 실행 → `next()` 시 다음으로
2. 끝까지 매칭이 안 되면 404

명시적으로 404 미들웨어를 넣지 않아도 기본적으로 "Cannot GET /..."을 내보내지만, 커스텀 404가 권장

```js
// 모든 라우터보다 뒤에
app.use((req, res) => {
  res.status(404).json({ message: 'Not Found' });
});

// 에러 핸들러는 (err, req, res, next) 시그니처
app.use((err, req, res, next) => {
  res.status(err.status || 500).json({ error: err.message });
});
```

### 404를 맨 마지막에 두는 이유

위에서부터 소비되지 않은 요청만 최종적으로 404로 떨어져야 한다. 중간에 두면 정상 라우트까지 가기 전에 404가 가로채는 "섀도잉"이 발생한다.

### app.use() vs app.all()

- **app.use(path?, middleware)**
  - 모든 메서드, 경로 접두(prefix) 매칭
  - 전처리/공통 미들웨어(로그, CORS, 인증, 파서)에 사용
  - 메서드 판별 없음 → 라우팅 핸들러가 아니다

- **app.all(path, handler)**
  - 모든 메서드에 대해 정확 경로 매칭하는 라우트 핸들러
  - 메서드별 분기가 필요 없을 때, 또는 fall-through 엔드포인트에 사용

```js
app.all('/health', (req, res) => res.send('ok')); // GET/POST/... 모두 ok
```

- 전역 미들웨어(인증/권한)는 `app.use('/api', auth())`
- 라우터 파일마다 404 라우트를 두지 말고, 앱 말미에 전역 404 하나로 일원화
- 에러 핸들러는 반드시 맨 마지막

---

## 템플릿 엔진의 필요성

### HTML의 한계

HTML 자체로는 동적 기능을 표현할 수 없다. 

데이터 개수만큼 자동 반복하거나 조건 분기(if, else) 같은 로직을 처리할 수 없다. HTML만으로 1000개의 데이터를 표현하려면 1000개의 `<div>`를 직접 작성해야 한다.

자바스크립트에서는 다음과 같이 가능함


```js
const items = [1, 2, 3];
items.forEach(i => {
  document.body.innerHTML += `<p>${i}</p>`;
});
```

하지만 이 방식은 브라우저 실행 이후에만 렌더링된다.
 즉, "초기 HTML"은 여전히 비어 있어서 SEO에 불리!

### 서버사이드 렌더링(SSR)

이 문제를 해결하는 방식이 바로 서버에서 HTML을 미리 만들어 보내는 SSR이고, 이때 필요한 것이 템플릿 엔진(Template Engine)이다.

자바스크립트로 HTML을 "코드처럼 다룰 수 있게 하는 도구"가 템플릿 엔진!

---

## 주요 템플릿 엔진 비교

### 템플릿 엔진별 특징

| 엔진 | 문법 스타일 | 장점 | 단점 |
|------|-----------|------|------|
| **EJS** | `<%= %>` (JS 유사) | 익숙하고 간단함 | 레이아웃 기능 부족 |
| **Pug** | 들여쓰기 기반, 태그 생략 | 간결한 문법, 빠른 작성 | 익숙해지기까지 시간 필요 |
| **Nunjucks** | Jinja2 문법 (`{% %}`) | 조건문·반복문 풍부, 상속·include 지원 | 약간의 러닝커브 |
| **Handlebars** | Mustache 기반 (`{{}}`) | React-like 문법, 안전성 높음 | 복잡한 로직에 제약 |

Nunjucks는 Jinja2(파이썬 Flask 등)와 비슷한 문법 덕분에 직관적이고 강력한 상속 기능을 제공해서 유지보수성이 좋다.

### Nunjucks 기본 구조

```js
// app.js
const express = require('express');
const nunjucks = require('nunjucks');

const app = express();
app.set('view engine', 'html');
nunjucks.configure('views', { express: app, watch: true });

app.get('/', (req, res) => {
  res.render('index', { title: 'Hello', users: ['Alice', 'Bob'] });
});
```

```html
<!-- views/index.html -->
<!DOCTYPE html>
<html>
  <head><title>{{ title }}</title></head>
  <body>
    <ul>
      {% for user in users %}
        <li>{{ user }}</li>
      {% endfor %}
    </ul>
  </body>
</html>
```

서버가 HTML을 완성해서 브라우저로 전송하므로, 초기 로딩 시점부터 완성된 페이지가 나타난다. React처럼 클라이언트에서 다시 그릴 필요가 없다.

### React/Vue와의 차이

| 비교 항목 | 템플릿 엔진 (Nunjucks 등) | React / Vue |
|----------|------------------------|-------------|
| 실행 위치 | 서버 (SSR) | 클라이언트 (CSR) |
| 데이터 갱신 | 새로고침 필요 | 동적 갱신 가능 (state) |
| SEO | 매우 유리 | SSR 추가 구성 필요 |
| 복잡도 | 낮음 | 높음 |
| 주 사용 목적 | 빠른 서버 렌더링, 간단한 페이지 | 대규모 SPA, 인터랙션 많은 UI |

템플릿 엔진은 SSR, React/Vue는 CSR이다. 하지만 Next.js, Nuxt.js처럼 서버 사이드 렌더링 프레임워크로 경계가 흐려지고 있다.

### EJS를 추천하지 않는 이유

- 레이아웃(상속) 기능이 기본적으로 없어서 매 페이지마다 `<header>`와 `<footer>`를 중복 작성해야 한다
- 템플릿 내에서 로직이 JS에 너무 의존적이라 템플릿과 로직 분리가 어렵다

반면 Nunjucks는 상속 구조를 지원

```html
<!-- base.html -->
<html>
  <body>
    {% block content %}{% endblock %}
  </body>
</html>

<!-- index.html -->
{% extends "base.html" %}
{% block content %}
  <h1>Hello</h1>
{% endblock %}
```

React의 layout component 구조와 유사하게 재사용이 가능하다.

---

## 핵심 요약

### Express 라우팅 체크리스트

- `next('route')`는 같은 경로의 다음 라우터로 점프 — 조건부 분기에만 
- `params/query/body` 역할을 구분하고 스키마 검증으로 타입·제약을 확실히
- 미들웨어는 등록 순서가 곧 우선순위. 전역 전처리 → 라우트 → 404 → 에러 핸들러 순서를 지키고, `app.use`(접두 미들웨어)와 `app.all`(모든 메서드 라우트)을 구분

### 템플릿 엔진 핵심 개념

| 개념 | 설명 |
|------|------|
| **HTML** | 정적 문서. 로직 없음 |
| **템플릿 엔진** | JS로 동적 HTML 생성 (반복, 조건, 변수 삽입 등) |
| **Nunjucks** | 강력한 문법 + 레이아웃 상속 가능 |
| **EJS** | 단순하지만 확장성 부족 |
| **React/Vue** | 프런트엔드 중심의 CSR 방식, 데이터 변경에 즉시 반응 |