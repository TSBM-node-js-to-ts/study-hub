# 📘 5장

npm을 통해 전 세계 개발자들이 만들어 둔 **패키지(모듈)** 를 가져와 쓰고, 나의 코드를 배포할 수 있다.  
이 장에서는 **npm 기본 사용법 → 패키지/버전 관리 → 자주 쓰는 명령어 → 직접 배포** 순서로 정리한다.

---

## 1️⃣ npm이란?
- **npm (Node Package Manager)**: Node.js의 공식 패키지 매니저이자 패키지 레지스트리.
- 전 세계 수많은 자바스크립트 패키지들이 **패키지(=노드 모듈)** 형태로 등록됨.
- 필요한 기능을 **설치해서 가져다 쓰고**, 내 코드를 **배포**할 수도 있음.

> 대안: **yarn**, **pnpm** — 사용법은 거의 동일. 성능/편의 차이만 있음.

---

## 2️⃣ package.json으로 패키지 관리하기
프로젝트는 보통 **package.json** 파일로 시작한다. 설치한 패키지의 **이름/버전/스크립트** 등이 기록되어 **같은 환경을 재현**할 수 있다.

### 2-1. 초기화
```bash
$ npm init
# name, version, description, main, scripts, author, license 등 입력
```

생성 예시:
```json
{
"name": "npmtest",
"version": "0.0.1",
"description": "hello package.json",
"main": "index.js",
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
"author": "YourName",
"license": "ISC"
}
```

### 2-2. scripts 실행
```bash
$ npm run test
# start/test 는 run 생략 가능: npm start, npm test
```


### 2-3. 패키지 설치
```bash
$ npm install express
```

- **dependencies**에 기록됨:
    ```
    "dependencies": {
      "express": "^4.17.3"
    }
    ```

> **주의**: 프로젝트 이름(name)과 설치할 패키지 이름이 **겹치면 안 됨**.

### 2-4. 개발용 패키지
실제 배포에는 쓰지 않고 **개발 중에만** 쓰는 도구는 `--save-dev`:
```bash
$ npm install --save-dev nodemon

"devDependencies": {
"nodemon": "^2.0.16"
}
```


### 2-5. peerDependencies
라이브러리가 **특정 버전의 다른 패키지가 존재한다고 가정**할 때:
```
"peerDependencies": {
"jquery": "^3.0.0"
}
```
- 충돌 시 `ERESOLVE` 오류 → **해당 버전으로 맞추기**(권장), 불가 시 `npm i --force` 또는 `--legacy-peer-deps` (비권장).

### 2-6. node_modules / package-lock.json
- **node_modules**: 실제 설치 파일 폴더(커밋 X).
- **package-lock.json**: 모든 **정확한 버전/의존관계** 기록(커밋 O).  
  배포 환경에서는 **`npm ci`** 로 lock에 **정확히 일치**하게 설치.

### 2-7. 전역 설치 vs npx
- 전역(Global) 설치: CLI로 쓰는 도구를 시스템에 설치
  ```bash
    $ npm install --global rimraf   # -g
    $ rimraf node_modules
  ```
- **npx**: 전역 설치 없이 **로컬 의존성**을 명령처럼 실행
  ```bash
  $ npm install --save-dev rimraf
  $ npx rimraf node_modules
  ```

### 2-8. 내장 모듈 이름 충돌?
- `fs`, `os` 같은 **내장 모듈 이름과 동일한 npm 패키지**가 있어도, `require('fs')` 는 **내장 모듈**이 로드됨.
- 명시하려면 **노드 프로토콜** 사용:
  ```js
  require('node:fs')
  ```

### 2-9. 여러 개 한 번에 설치 / 제거
```bash
$ npm install morgan cookie-parser express-session
$ npm rm fs
```

### 2-🔟 취약점 점검
$ npm audit
$ npm audit fix        # 자동 수정
$ npm audit fix --force

### 2-⚙️ node_modules 수정 패치 반영
**patch-package**로 node_modules 수정사항을 유지:
```
# package.json
"scripts": { "postinstall": "patch-package" }

# 설치 & 패치 생성
$ npm i patch-package
# (node_modules 내 수정 후)
$ npx patch-package <패키지명>
```

---

## 3️⃣ 패키지 버전 이해하기 (SemVer)
버전은 보통 **메이저.마이너.패치**(예: 2.4.1)

- **메이저**: 하위 호환 깨짐(예: 1.x → 2.0.0)
- **마이너**: 기능 추가(호환 유지)
- **패치**: 버그 수정(호환 유지)

> 한 번 배포된 버전의 **내용은 바꾸지 않는다**. 변경 시엔 **숫자를 올려 새 버전** 배포.

### 버전 범위 기호
- **^1.2.3**: 마이너/패치 업데이트 허용 → **1.x.x** (2.0.0 미만)
- **~1.2.3**: 패치만 허용 → **1.2.x**
- 비교 연산자: `>`, `<`, `>=`, `<=`, `=`
- **@latest**: 안정 최신
- **@next**: 최신 프리릴리즈(알파/베타/RC 포함)

---

## 4️⃣ 기타 유용한 npm 명령어
- 업데이트 확인:
  ```bash
  $ npm outdated
  # Current / Wanted / Latest 비교
  $ npm update
  $ npm update <pkg>
  ```

- 제거:
  ```bash
  $ npm uninstall <pkg>    # npm rm <pkg>
  ```

- 검색/정보:
  ```bash
  $ npm search express
  $ npm info express
  ```

- 로그인/로그아웃/확인:
  ```bash
  $ npm login
  $ npm whoami
  $ npm logout
  ```

- 버전 올리기:
  ```bash
  $ npm version 5.3.2
  $ npm version major | minor | patch
  ```

- 특정 버전 경고(Deprecated):
  ```bash
  $ npm deprecate <pkg> "<message>"
  ```

- 배포/삭제:
  ```bash
  $ npm publish
  $ npm unpublish <pkg> --force # 24시간 이내만 가능
  ```
---

## 5️⃣ 패키지 배포하기 (핵심 흐름)
1) **npm 계정** 생성 & 이메일 인증 → 콘솔에서 `npm login` (OTP 포함)
2) **엔트리 파일**(package.json의 `main`) 작성

예시:
```js
module.exports = () => {
return 'hello package';
};
```

3) **배포**
   ```bash
   $ npm publish
   ```
# 이름이 이미 사용 중이면 에러 → package.json의 "name" 변경 후 재시도

4) **버전 업 후 재배포**=
   ```bash
   $ npm version patch # v0.0.1 -> v0.0.2
   $ npm publish
   ```

5) **삭제(실수 방지 제약)**
   ```bash
   $ npm unpublish <pkg> --force   # 24시간 이내만 가능
   ```

> 실무에서는 릴리즈 자동화 도구(예: **release-it**)도 자주 사용.

---

## 🧩 의문점
- npm과 yarn/pnpm의 실제 체감 성능 차이는?
---

# 📘 6장

4장에서 직접 HTTP 서버를 만들며 “라우팅 분기, 본문 파싱, 쿠키/세션 처리” 같은 공통 작업이 **반복**되고 **확장성**도 떨어진다는 걸 느꼈다면, 이번 장의 **Express(익스프레스)** 가 바로 해결사다.  
Express는 Node.js의 `http` 위에 올라가는 **웹 서버 프레임워크**로, 요청/응답 객체를 확장하고, **미들웨어** 기반으로 기능을 모듈화해 **코드 가독성·유지보수성**을 크게 높인다.

> 다른 대안(koa, hapi)도 있지만, 생태계 규모·예제가 가장 풍부한 건 여전히 **Express**.

---

## 1️⃣ Express를 쓰는 이유 (한 줄 요약)
- **라우팅/미들웨어/에러 처리**가 체계적 → `if...else` 분기 지옥 탈출
- 요청/응답 객체 기능 확장(`res.send`, `res.json`, `res.sendFile` 등)
- 생태계가 커서 **쿠키/세션/로그/업로드** 등 검증된 미들웨어를 그대로 사용
---

## 2️⃣ 프로젝트 시작하기

### 2-1. 프로젝트 초기화 & 의존성
`package.json`은 가장 먼저 만든다.
```json
{
  "name": "learn-express",
  "version": "0.0.1",
  "description": "익스프레스를 배우자",
  "main": "app.js",
  "scripts": {
    "start": "nodemon app"
  },
  "author": "YourName",
  "license": "MIT"
}
```

설치:
```bash
$ npm i express
$ npm i -D nodemon
```

- `start` 스크립트에서 **nodemon**을 사용하면 파일 저장 시 서버 **자동 재시작**
- 배포 환경에서는 `nodemon` 사용 X (개발용 전용)

### 2-2. 최소 서버(app.js)
```js
const express = require('express');

const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
res.send('Hello, Express');
});

app.listen(app.get('port'), () => {
console.log(app.get('port'), '번 포트에서 대기 중');
});
```

실행:
```bash
$ npm start
```

### 2-3. HTML 파일 응답
```html
<!-- index.html -->
<html>
<head>
  <meta charset="UTF-8" />
  <title>익스프레스 서버</title>
</head>
<body>
  <h1>익스프레스</h1>
  <p>배워봅시다.</p>
</body>
</html>
```
```js
const express = require('express');
const path = require('path');

const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
res.sendFile(path.join(__dirname, 'index.html'));
});

app.listen(app.get('port'), () => {
console.log(app.get('port'), '번 포트에서 대기 중');
});
```

---

## 3️⃣ 미들웨어 핵심 개념과 흐름

### 3-1. 미들웨어 기본
- **형태**: `(req, res, next) => { ... }`
- **연결**: `app.use(...)`, `app.get(..., 미들웨어1, 미들웨어2, ...)`
- **흐름**: 위→아래 **순차 실행**, 다음으로 넘기려면 `next()` 호출
- **특수**: 에러 처리 미들웨어는 **인자 4개** `(err, req, res, next)`

예시:

```js
app.use((req, res, next) => {
  console.log('모든 요청에서 실행');
  next();
});

app.get('/', (req, res, next) => {
console.log('GET / 에서만 실행');
next();
}, (req, res) => {
throw new Error('에러는 에러 처리 미들웨어로 이동');
});

app.use((err, req, res, next) => {
console.error(err);
res.status(500).send(err.message);
});
```

> `next('route')` → 다음 라우터로 점프,  
> `next(err)` → **바로 에러 처리 미들웨어**로 이동

### 3-2. 실행 범위 제어
- `app.use(미들웨어)` → 모든 요청
- `app.use('/abc', 미들웨어)` → `/abc`로 시작하는 요청만
- `app.post('/abc', 미들웨어)` → `/abc` **POST**만

### 3-3. 미들웨어 간 데이터 공유
- 요청 생명주기 동안만 공유: **`res.locals`**
- 앱 전역 설정(요청과 무관): **`app.set` / `app.get`**

```js
app.use((req, res, next) => {
  res.locals.data = '한 요청 내에서만 공유';
  next();
});
```

---

## 4️⃣ 자주 쓰는 미들웨어 모음

### 4-1. morgan (요청 로깅)
```js
const morgan = require('morgan');
app.use(morgan('dev'));  // dev | combined | common | short | tiny
```

- 예: `GET / 200 7.409 ms - 50`  
  → [메서드] [경로] [상태] [소요 ms] - [응답 바이트]

### 4-2. static (정적 파일 제공)
```js
const path = require('path');
app.use('/', express.static(path.join(__dirname, 'public')));
```

- `public/styles.css` → `http://localhost:3000/styles.css`
- 실제 서버 경로와 요청 경로가 분리되어 **보안 측면**에서도 유리
- 파일이 존재하면 **응답 후 next 미호출** (다음 미들웨어 실행 X)

### 4-3. body-parser (내장 버전)
본문 데이터를 **`req.body`** 로 파싱:

```js
app.use(express.json()); // JSON
app.use(express.urlencoded({ extended: false })); // 폼 URL-encoded
```
> Raw/Text 본문이 필요하면 별도 설치:
```js
// $ npm i body-parser
const bodyParser = require('body-parser');
app.use(bodyParser.raw());
app.use(bodyParser.text());
```

### 4-4. cookie-parser (쿠키 파싱)
```js
const cookieParser = require('cookie-parser');
app.use(cookieParser(process.env.COOKIE_SECRET));
```

- 평문 쿠키: `req.cookies`, 서명 쿠키: `req.signedCookies`
- 쿠키 설정/삭제:
  ```js
  res.cookie('name', 'zerocho', {
  httpOnly: true, secure: true,
  expires: new Date(Date.now() + 900000),
  });
  res.clearCookie('name', 'zerocho', { httpOnly: true, secure: true });
  ```

### 4-5. express-session (세션)
```js
const session = require('express-session');
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: { httpOnly: true, secure: false },
  name: 'session-cookie',
}));
```

- `req.session`에 사용자별 데이터 저장:
  ```js
  req.session.name = 'zerocho';
  req.sessionID;          // 세션 ID
  req.session.destroy();  // 세션 제거
  ```

> 배포 시에는 **store(예: Redis)** 를 연결해 세션을 외부에 보관(서버 재시작 시 유지)

### 4-6. .env 환경변수 (dotenv)
```js
const dotenv = require('dotenv');
dotenv.config();  // .env → process.env
```
- 비밀 키/환경별 설정을 코드에서 분리, **보안/편의성** 향상

### 4-7. 미들웨어 패턴: “미들웨어 안에 미들웨어”
```js
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production') {
    require('morgan')('combined')(req, res, next);
  } else {
    require('morgan')('dev')(req, res, next);
  }
});
```
- 조건에 따라 **동적으로 다른 미들웨어** 주입 가능

---

## 5️⃣ 파일 업로드: multer

### 5-1. 설치 & 기본 설정
```bash
$ npm i multer
```

업로드 디렉터리 준비:

```js
const fs = require('fs');
try { fs.readdirSync('uploads'); }
catch (e) {
  console.error('uploads 폴더가 없어 생성합니다.');
  fs.mkdirSync('uploads');
}
```

multer 인스턴스:

```js
const multer = require('multer');
const path = require('path');

const upload = multer({
storage: multer.diskStorage({
destination(req, file, done) {
done(null, 'uploads/');                      // 저장 폴더
},
filename(req, file, done) {
const ext = path.extname(file.originalname); // .png
done(null, path.basename(file.originalname, ext) + Date.now() + ext);
},
}),
limits: { fileSize: 5 * 1024 * 1024 },          // 5MB
});
```

### 5-2. 단일 파일 업로드 (single)
폼:

```html
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="image" />
  <input type="text" name="title" />
  <button type="submit">업로드</button>
</form>
```

라우터:

```js
app.post('/upload', upload.single('image'), (req, res) => {
  console.log(req.file);  // 파일 메타데이터
  console.log(req.body);  // 텍스트 필드
  res.send('ok');
});
```

`req.file` 예시:
```
{
  fieldname: 'image',
  originalname: 'nodejs.png',
  encoding: '7bit',
  mimetype: 'image/png',
  destination: 'uploads/',
  filename: 'nodejs1693456789012.png',
  path: 'uploads/nodejs1693456789012.png',
  size: 53357
}
```
### 5-3. 다중 파일 업로드
- 같은 name, 여러 파일: **array**
  ```js
  <input type="file" name="many" multiple />
  app.post('/upload', upload.array('many'), (req, res) => {
  console.log(req.files); // 배열
  res.send('ok');
  });
  ```

- 다른 name 각각: **fields**
  ```js
  <input type="file" name="image1" />
  <input type="file" name="image2" />
  app.post('/upload',
  upload.fields([{ name: 'image1' }, { name: 'image2' }]),
  (req, res) => {
  console.log(req.files.image1, req.files.image2);
  res.send('ok');
  }
  );
  ```

- 파일 없이 멀티파트 폼: **none**
  ```js
    <form action="/upload" method="post" enctype="multipart/form-data">
      <input type="text" name="title" />
      <button type="submit">업로드</button>
    </form>
    
    app.post('/upload', upload.none(), (req, res) => {
    console.log(req.body);
    res.send('ok');
    });
  ```

---

## 6️⃣ 한 화면에 모아보기 (실습용 스니펫)

`.env`:
```
COOKIE_SECRET=cookiesecret
```

`app.js` (핵심만 발췌):
```js
const express = require('express');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const dotenv = require('dotenv');
const path = require('path');
const fs = require('fs');
const multer = require('multer');

dotenv.config();
const app = express();
app.set('port', process.env.PORT || 3000);

app.use(morgan('dev'));
app.use('/', express.static(path.join(__dirname, 'public')));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(process.env.COOKIE_SECRET));
app.use(session({
resave: false,
saveUninitialized: false,
secret: process.env.COOKIE_SECRET,
cookie: { httpOnly: true, secure: false },
name: 'session-cookie',
}));

try { fs.readdirSync('uploads'); }
catch (e) { fs.mkdirSync('uploads'); }

const upload = multer({
storage: multer.diskStorage({
destination(req, file, done) { done(null, 'uploads/'); },
filename(req, file, done) {
const ext = path.extname(file.originalname);
done(null, path.basename(file.originalname, ext) + Date.now() + ext);
},
}),
limits: { fileSize: 5 * 1024 * 1024 },
});

app.get('/upload', (req, res) => {
res.sendFile(path.join(__dirname, 'multipart.html'));
});
app.post('/upload', upload.single('image'), (req, res) => {
console.log(req.file);
res.send('ok');
});

app.get('/', (req, res) => {
res.send('Hello, Express');
});

app.use((err, req, res, next) => {
console.error(err);
res.status(500).send(err.message);
});

app.listen(app.get('port'), () => {
console.log(app.get('port'), '번 포트에서 대기 중');
});
```

`multipart.html`:
```html
<form id="form" action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="image" />
  <input type="text" name="title" />
  <button type="submit">업로드</button>
</form>
```
