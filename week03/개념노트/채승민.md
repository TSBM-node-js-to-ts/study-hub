---
Author: CarefreeLife98
Date: 2025-10-27T21:14:00
Agenda:
tags:
  - NodeJS
  - TSBM_STUDIO
---
**`Express` 는 `http` 모듈의 요청과 응답 객체에 추가 기능들을 부여한 것이다.**

> 공식 정의: **Express** is a fast, unopinionated, minimalist web framework for Node.js.
> = Express는 빠르고, 특정한 방식(opinion)에 얽매이지 않은, 최소한의 필요한 것들을 담은 Node.js 용 웹 프레임워크이다.

# Express 프로젝트 시작

```json
{
  "name": "learn-express",
  "version": "0.0.1",
  "description": "Learn about Express",
  "main": "app.js",
  "scripts": {
	"start": "nodemon app", // 추가: app.js 를 nodemon 으로 실행. nodemon 은 소스코드 수정 사항 발생시 서버를 자동으로 재시작. (hot reload)
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "express"
  ],
  "author": "carefreelife98",
  "license": "ISC",
  "dependencies": {
    "express": "^5.1.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

```

1. `learn-express` 폴더 생성 및 이동
2. `npm init` 을 통해 `package.json` 생성 및 `script: start` 추가
3. `npm i express`, `npm i -D nodemon` 패키지 설치.

```javascript
const express = require('express'); // express 모듈을 로드

const app = express(); // express 모듈을 실행하여 app 변수에 할당. express 모듈 내부에 http 모듈이 내장되어 서버 역할을 수행 할 수 있다.
app.set('port', process.env.PORT || 3000); // 서버가 실행될 포트를 설정. (default: 3000)

app.get('/', (req, res) => { // get '/' 요청 시 "Hello Express" 를 응답.
  res.send('Hello Express'); // express 에서는 응답 메서드가 res.write, res.end 대신 res.send() 를 사용.
});

app.get('/html', (req, res) => { // get '/html' 요청 시 를 html 파일을 응답.
  res.sendFile(path.join(__dirname, '/index.html')); // 파일 응답 시 res.sendFile() 사용 가능.
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), 'Server is running on: http://localhost:' + app.get('port'));
});
```
- `app.get('키')` 및 `app.set('키', '값')` 을 통해 데이터를 저장하고 불러올 수 있다.
- `app.get('주소', '라우터'):` 주소에 대한 **get 요청이 올 때의 처리 동작**을 명시.
	- `req:` 요청에 관한 정보가 들어있는 객체
	- `res:` 응답에 관한 정보가 들어있는 객체
- `app.get` 이외에도 `put, patch, delete, options` 메서드가 존재.


# 자주 사용하는 미들웨어 (middleware)
**미들웨어는 익스프레스의 핵심**이다.
**요청과 응답의 중간(middle) 에 위치하기 때문에 미들웨어(middleware)** 라고 부른다.
- 라우터 (router)
- 에러 핸들러 (error handler) 등

미들웨어는 `app.use(미들웨어)` 와 같은 방식으로 아래와 같이 사용된다.

```javascript
const express = require('express');

const app = express();
app.set('port', process.env.PORT || 3000);


/* 미들 웨어 추가 */
app.use((req, res, next) => {
  console.log('모든 요청에 실행됩니다.');
  next();
});

app.get('/', (req, res, next) => { // 주소 미전달 시 모든 요청에서 실행됨.
  console.log('GET / 요청에서만 실행됩니다.');
  next();
}, (req, res) => {
  throw new Error('에러는 에러 처리 미들웨어에서 처리됩니다.');
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), 'Server is running on: http://localhost:' + app.get('port'));
});
```
`app.js`

위와 같이 `app.use` 에 파라미터가 `req, res, next` 인 함수를 넣어주면 된다.
**미들웨어는 위에서부터 아래로 순차실행되며 요청과 응답 사이에 특별한 기능을 추가**할 수 있다.
- `next():` 다음 미들웨어로 넘어감. `next()` 를 호출하지 않을 시 다음 미들웨어가 실행되지 않는다.
- **첫번째 파라미터인 주소를 전달하지 않을 시 모든 요청에서 해당 미들웨어가 실행됨.**
- **하나의 라우터 (`app.get`, `app.use` 등) 에 여러 개의 미들웨어를 장착** 할 수 있다.

`app.get`, `app.post` 와 같은 Http Method 기반 라우터 함수에서도 아래와 같이 미들웨어를 등록하고 사용할 수 있다.

```javascript
app.post('/abc', 미들웨어)
```

또한, 현재 `app.get('/' ~ )` 의 두번째 미들웨어에서 에러를 발생시키고 있는데, 이 **에러는 하단에 정의한 에러 처리 미들웨어에 전달**된다.

```javascript
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
});
```
`에러 처리 미들웨어`

**에러 처리 미들웨어**는 파라미터가 `err, req, res, next` 네 개이다.
**`res.status()` 메서드로 Http 상태 코드 지정 가능. (default: 200 OK)**

## morgan (로깅)
**요청과 응답에 대한 정보를 콘솔에 기록.**

```javascript
app.use(morgan('dev')); // combined, commonm, short, tiny 와 같이 파라미터를 변경하여 사용가능.
```

`morgan('dev')`
- `GET / 500 7.777 ms - 30` : \[HTTP 메서드] \[주소] \[HTTP 상태 코드] \[응답 속도] - \[응답 바이트]

## static
**`static` 미들웨어는 정적 파일들을 제공하는 라우터 역할**을 한다. `express` 에서 기본 제공하는 미들웨어.

```javascript
// app.use('요청 경로', express.static('실제 경로'));
app.use('/', express.static(path.join(__dirname, 'public')));
```

`static` 함수의 파라미터로 **정적 파일들이 담겨 있는 폴더 경로를 지정.**
- `public/stylesheets/style.css` -> `http://localhost:3000/stylesheets/style.css` 로 접근 가능.

**실제 서버의 폴더 경로에는 'public' 경로가 존재하지만, 요청 주소에는 'public' 없이 사용할 수 있다.**
이는 서버의 폴더 경로와 요청 경로를 다르게 지정함으로써, 외부인이 서버 구조를 쉽게 파악할 수 없는 **보안적 이점**이 될 수 있다.

> 만약 요청 경로에 해당하는 파일이 없다면 내부적으로 `next()` 를 호출하여 다음 미들웨어로 요청을 전달한다.


## body-parser
**요청의 본문 (body) 에 있는 데이터를 해석해서 `req.body` 객체로 만들어주는 미들웨어.**
보통 `폼 데이터` 나 `AJAX` 요청의 데이터를 처리하며 멀티파트(이미지, 동영상, 파일) 데이터는 처리하지 못한다. -> 뒤에 나오는 `multer` 모듈 사용하여 처리.

```javascript
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
```
`expresss 4.16.0 부터 body-parser 미들웨어의 일부 기능이 익스프레스에 내장되어 따로 설치할 필요가 없다.`

하지만, `JSON` 과 `URL-encoded` 형식의 데이터 외에 `Raw(버퍼 데이터)` , `Text(텍스트 데이터)` 형식의 데이터를 추가로 해석하기 위해서는 `body-parser` 를 설치한 후 다음과 같이 설정해야 한다.

```bash
$ npm i body-parser
```
`body-parser 설치`

```javascript
const bodyParser = require('body-parser');
app.use(bodyParser.raw());
app.use(bodyParser.text());
```

### 요청 데이터 종류
1. **JSON**: JSON 형식의 데이터 전달
2. **URL-encoded**: 주소 형식으로 데이터 전달 (폼 데이터 전송)
	- `urlencoded({ extended: false })` : 노드의 **querystring** 모듈을 통해 쿼리스트링을 해석. (내장 모듈)
	- `urlencoded({ extended: true })` : **qs** 모듈을 통해 쿼리스트링을 해석. (npm 패키지, querystring 을 확장한 모듈)


## cookie-parser
**요청에 동봉된 쿠키를 해석하여 `req.cookies` 객체로 변환**

```javascript
app.use(cookieParser(비밀 키));
```

**해석된 쿠키들은 `req.cookies` 객체에 저장**되며, **유효 기간이 지난 쿠키는 자동으로 필터링**된다.

```javascript
app.use(cookieParser(process.env.COOKIE_SECRET));

app.use((req, res, next) => {
  console.log('쿠키 파서 미들웨어 실행');
  console.log(req.cookies);
  next();
})

// 쿠키 파서 미들웨어 실행
// { Cookie_1: 'value' }
```

`cookieParser()` 의 첫번째 파라미터로 **비밀 키**를 넣을 수 있다.
**서명된 쿠키가 있는 경우, 제공한 비밀 키를 통해 해당 쿠키가 내 서버에서 만들어진 쿠키임을 검증**할 수 있다.
쿠키는 클라이언트에서 위조하기 쉬워 이와 같이 **비밀 키를 통해 만들어낸 서명을 쿠키 값 뒤에 붙인다.**
이 경우 **쿠키는 `name=carefreelife98.sign` 과 같은 모양**이 되고, **`req.signedCookies` 객체에 저장**된다.

`cookie-parser` 는 말 그대로 파서이기 때문에 쿠키를 생성하는 데에 쓰이진 않는다.
**쿠키를 생성/제거 하려면 `res.cookie`, `res.clearCookie` 메서드를 사용해야 한다.**
- `res.cookie(키, 값, 옵션)`
	- 옵션: `domain`, `expires`, `httpOnly`, `maxAge`, `path`, `secure` 등

```javascript
res.cookie('name', 'carefreelife98', { 
  expires: new Date(Date.now() + 900000),
  httpOnly: true,
  secure: true,
});
res.clearCookie('name', 'carefreelife98', { httpOnly: true, secure: true });
```

- \[주의 사항] 쿠키를 지우려면, 키와 값외에 **옵션 또한 정확히 일치해야 쿠키가 지워진다.** (expires, masAge 제외)


## express-session
**세션 관리용 미들웨어.** 세션을 구현하거나 특정 사용자를 위한 데이터를 임시적으로 저장해둘때 유용하다.
**세션은 사용자 별로 `req.session` 객체 안에 유지**된다.

```javascript
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: {
    httpOnly: true,
    secure: false,
  },
  name: 'session-cookie',
}));
```

`express-session` 은 파라미터로 세션의 설정값을 받는다.
- `resave` : 요청이 올 때 세션에 수정 사항이 발생하지 않더라도 세션을 다시 저장할지의 여부.
- `saveUninitialized` : 세션에 저장할 내역이 없더라도 처음부터 세션을 생성할지의 여부.
- `secret` : 비밀 키
- `name` : 세션 쿠키의 이름

`express-session` 은 세션 관리 시 클라이언트로 쿠키를 보낸다. (=세션 쿠키)
안전하게 쿠키를 전송하려면 **비밀 키를 사용해 쿠키에 서명을 추가**해야 한다. (`cookie-parser` 에 설정한 `secret` 과 동일하게 설정)

또한, `express-session` 의 `store` 라는 옵션을 통해 **데이터 베이스를 연결하여 세션 데이터를 저장하고 사용할 수 있다.**

아래와 같이 `express-session` 으로 만들어진 `req.session` 객체에 **값을 대입하거나 삭제해서 세션을 변경** 할 수 있다.

```javascript
req.session.name = 'zerocho'; // 세션 등록
req.sessionID; // 세션 아이디 확인
req.session.destroy(); // 세션 모두 제거
```
- 세션 저장을 강제하는 `req.session.save` 메서드 또한 존재하지만, 일반적으로 **요청이 끝날 때 자동으로 호출**되므로 직접 save 메서드를 호출할 일은 거의 없다.

## multer
**이미지, 동영상 등을 비롯한 여러 가지 파일을 멀티파트 형식으로 업로드 할 때 사용하는 미들웨어.**

```html
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="image" />
  <input type="text" name="title" />
  <button type="submit">업로드</button>
</form>
```
- **멀티 파트 (multipart):** `enctype` 이 `multipart/form-data` 인 폼을 통해 업로드하는 데이터 형식.

이러한 `form` 을 통해 업로드하는 파일은 `body-parser` 로는 처리할 수 없고, 직접 파싱하기 어려우므로 `multer` 라는 미들웨어를 사용한다.

```bash
$ npm i multer
```

```javascript
const multer = require('multer');

// 파라미터로 multer 설정 추가
const upload = multer({
  storage: multer.diskStorage({
	// 어디에 (destination)
    destination(req, file, done) {
      done(null, 'uploads/'); // 서버에 해당 폴더가 꼭 존재해야 한다.
    },
    // 어떤 이름으로 (filename) 저장할 지
    filename(req, file, done) {
      const ext = path.extname(file.originalname);
      done(null, path.basename(file.originalname, ext) + Date.now() + ext);
    },
  }),
  limits: { fileSize: 5 * 1024 * 1024 },
});
```
- `storage` : **어디에(destination) 어떤 이름으로(filename) 저장**할지 설정
- `req` : 요청에 대한 정보
- `file` : 파일 정보
- `done` : **비동기 완료 콜백 함수**. `(에러, 실제 경로 or 파일 이름)` 와 같이 사용
- `limits` : **업로드에 대한 제한 사항**을 설정

위와 같이 설정이 끝나고 생성된 `upload` 상수에는 **다양한 미들웨어가 존재**한다.

```javascript
app.post('/upload', upload.single('image'), (req, res) => {
  console.log(req.file, req.body);
  res.send('ok');
});
```
`단일 파일 업로드: single 미들웨어 사용`

`single` 미들웨어를 라우터 미들웨어 앞에 넣어두면 `multer` 설정에 따른 파일 업로드 후 `req.file` 객체가 생성된다.
`upload.single` 메서드의 파라미터는 **input 태그의 name** 이나 **폼 데이터의 키**와 동일하게 설정.
**업로드 성공 시 결과는 `req.file` 에 저장**된다.

```json
// req.file 구성
{ 
  fieldname: 'img',
  originalname: 'nodejs.png',
  encoding: '7bit',
  mimetype: 'image/png',
  destination: 'uploads/',
  filename: 'nodejs1514197844339.png',
  path: 'uploads\nodejs1514197844339.png',
  size: 53357
}
```

여러 파일을 업로드 하는 경우 아래와 같이 `upload.array` 를 사용.

```javascript
app.post('/upload', upload.array('many'), (req, res) => {
  console.log(req.files, req.body);
  res.send('ok');
});
```
**업로드 성공 시 결과는 `req.files` 에 저장**된다.

![[Pasted image 20251027165505.png]]


# 미들웨어의 특성 활용하기

```javascript
app.use(
  morgan('dev'),
  express.static('/', path.join(__dirname, 'public')),
  express.json(),
  express.urlencoded({ extended: false }),
  cookieParser(process.env.COOKIE_SECRET),
);
```

미들 웨어는 `req, res, next` 를 파라미터로 갖는 함수 (에러 처리 미들웨어만 `err` 파라미터를 추가적으로 가짐).
- app.use 나 **특정 HTTP Method (get, post 등) 를 명시**하는 경우 `app.get`, `app.post` 와 같이 사용.
- **특정 주소의 요청에만 미들웨어가 실행**되게 하려면 **첫 번째 파라미터로 주소**를 전달.
- 하나의 **미들웨어 내부적으로 여러 개의 미들웨어를 추가 장착** 할 수 있으며, **다음 미들웨어로 요청을 전달하기 위해서는 `next()` 메서드를 호출**해야 함.
- `next()` 를 호출하지 않는 미들웨어의 경우에는 `res.send`, `res.sendFile` 등의 메서드로 응답을 보내야 함.
	- **[주의사항] 이 경우 이후에 정의된 미들웨어는 실행되지 않음.**
- `next()` 도 호출하지 않고 응답도 없는 경우 **클라이언트를 응답을 받지 못해 계속 기다리게 된다.**

![[Pasted image 20251027162143.png]]
`next() 메서드에 파라미터 추가`

위와 같이 `next()` 메서드에 파라미터를 추가하면 특별한 동작을 한다.

> **`route` 라는 문자열을 넣으면 다음 라우터의 미들웨어로 이동하며 그 외의 경우 에러 처리 미들웨어로 이동**한다.

![[Pasted image 20251027162421.png]]
`next() 함수에 'route' 가 아닌 다른 데이터를 넘기면 해당 데이터는 에러 처리 미들웨어의 "err" 파라미터로 전달된다.`

# 자주 사용하는 미들웨어 패턴
미들웨어를 사용할 때 기존 미들웨어의 기능을 확장하기 위해,
아래와 같이 미들웨어 내부적으로 추가 미들웨어를 조합하는 방식으로 사용할 수 있다.

```javascript
// 조건문에 따라 다른 미들웨어를 적용하는 방식으로 확장
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production') {
    morgan('combined')(req, res, next);
  } else {
    morgan('dev')(req, res, next);
  }
});
```

# 에러 처리 미들웨어와 미들웨어 등록 순서의 중요성
> 에러 처리 미들웨어를 라우터의 미들웨어 레이어 스택 중간에 등록하면 해당 라우터에서 에러 처리가 되지 않는 걸까?

## 핵심 원칙: 스택 순서가 중요하다
Express의 **미들웨어 스택(`router.stack`)** 은 **등록 순서대로 실행**.
- 일반 미들웨어는 `handle_request` 호출
- 에러 미들웨어는 `handle_error` 호출 (단, `next(err)` 호출 시)

즉, **에러 처리 미들웨어가 스택 중간에 등록되어 있다면**:
1. `next()` 호출 시 → 일반 요청 흐름에서는 **스킵됨**
2. `next(err)` 호출 시 → **handle_error가 있으면 실행**, 그 이후 Layer는 계속 순회

하지만 `next(err)` 에 의해 수행되는 `handle_error` 함수는 직접 에러를 처리하거나 다음 에러 처리 미들웨어로 에러를 전달하며, 다음 에러 처리 미들웨어가 없는 경우 문제가 될 수 있다. (어떤 문제?)

따라서 글로벌 에러 처리 핸들러를 가장 마지막에 등록하여 전체 범위에 대해서 에러 발생 시 방어 로직을 추가해주어야 한다.

## Express Stack 은 LIFO 인가?
- **Express 스택은 LIFO(Last-In-First-Out) 스택이 아니라 단순 배열 순차 탐색**
- Layer는 **등록 순서대로 stack 배열에 push**
- 일반 요청 → 0부터 끝까지 순서대로 실행
- 에러 발생 → handle_error가 있는 Layer만 순차 탐색

즉, “가장 먼저 등록된 미들웨어가 가장 마지막에 실행된다?”는 **오해**.
**가장 먼저 등록된 미들웨어가 가장 먼저 실행된다. 실제로는 FIFO, 즉 큐(queue)처럼 동작.**

등록 순서: A → B → C
실행 순서: A → B → C
“스택”이라는 용어는 그냥 **추상적으로 “Layer들을 쌓아놓은 구조”**를 표현하기 위해 사용

자료구조 관점에서 보면 배열 + 순차 실행 → 큐와 유사
