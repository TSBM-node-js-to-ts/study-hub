# Node.js 학습 정리

## 목차
- [npm과 패키지 매니저](#npm과-패키지-매니저)
- [dependencies 관리](#dependencies-관리)
- [npm 명령어](#npm-명령어)
- [Express 프레임워크](#Express-프레임워크)
- [미들웨어](#미들웨어)

---

## npm과 패키지 매니저

npm은 Node Package Manager의 약어. npm에 업로드된 노드 모듈을 패키지라고 부른다.

모듈이 다른 모듈을 사용할 수 있는 것처럼 패키지는 다른 패키지를 사용할 수도 있다 → 이를 의존 관계라 함

npm의 대체자로 yarn과 pnpm이 있다.

### 패키지 매니저 비교

| 구분 | npm | Yarn | pnpm |
| --- | --- | --- | --- |
| 개발사 | Node.js 공식 | Meta (Facebook) | pnpm 팀 (오픈소스) |
| 기본 구조 | 중첩(node_modules) 구조 | 평탄화된 구조 | 하드링크 기반 공유 저장소 |
| 속도 | 느림 | 빠름 | 가장 빠름 |
| 디스크 사용량 | 많음 (중복 설치) | 중간 | 적음 (공유 캐시 사용) |
| 의존성 관리 | 비결정적 | 개선된 lockfile | 정확한 lockfile 관리 |
| 설치 명령어 | `npm install` | `yarn install` | `pnpm install` |
| 캐싱 방식 | 로컬 폴더 기반 | 전역 캐시 | 하드링크 + 전역 저장소 |
| Workspaces | 지원 (v7+) | 지원 | 가장 완성도 높음 |

### npm

패키지를 각 프로젝트의 `node_modules` 안에 복사해서 중첩 저장함

→ 중복 패키지가 많고 디스크 낭비가 큼

```
node_modules/
 ├─ react/
 ├─ axios/
 └─ react-dom/
```

### Yarn

중복된 패키지를 평탄화(flatten)해서 `node_modules`에 하나의 평면으로 배치

설치 속도가 빨라지고 충돌도 줄지만, 일부 의존성 버전 충돌 문제가 있었음

### pnpm

핵심은 **하드링크(hard link)** 방식

실제 패키지 파일은 한 번만 저장 → 다른 프로젝트는 링크로 참조

즉, 공유 저장소(`~/.pnpm-store`)를 사용

```
/home/user/.pnpm-store/
 ├─ react@18.2.0/
 ├─ axios@1.3.4/
 └─ lodash@4.17.21/

projectA/node_modules/react  → 하드링크
projectB/node_modules/react  → 하드링크
```

장점:
- 디스크 절약
- 설치 속도 빠름
- 의존성 충돌 방지

### lock 파일 비교

| 매니저 | Lock 파일명 | 특징 |
| --- | --- | --- |
| npm | `package-lock.json` | 자동 생성, 비교적 길고 불안정 |
| yarn | `yarn.lock` | 구조가 단순하고 안정적 |
| pnpm | `pnpm-lock.yaml` | 가장 엄격하고 결정적(deterministic) |

### 실무에서는?

| 상황 | 추천 매니저 |
| --- | --- |
| 일반적인 프로젝트 | npm (기본 제공이라 세팅 쉬움) |
| 속도와 캐시가 중요 | pnpm |
| 모노레포 관리 | pnpm or Yarn Berry(v3 이상) |
| 기존 CRA 기반 | npm 또는 yarn v1 |
| Next.js, TurboRepo 등 대규모 프로젝트 | pnpm 강력 추천 |

최근에는 많은 대규모 프로젝트(예: Vite, TurboRepo, NX, Next.js)에서 pnpm을 기본으로 채택하고 있음

---

## dependencies 관리

### dependencies vs devDependencies vs peerDependencies

| 구분 | 의미 | 설치 위치 | 예시 |
| --- | --- | --- | --- |
| dependencies | 런타임에 실제로 필요한 패키지 | 프로젝트의 `node_modules` | React, Express |
| devDependencies | 개발/빌드/테스트 시에만 필요 | 프로젝트의 `node_modules` | ESLint, Webpack, Jest |
| peerDependencies | 호환되는 외부 환경이 필요하다는 계약 | 설치는 안 되고 버전만 명시 | React 플러그인 등 |

### peerDependencies 이해하기

peerDependencies는 **공유 의존성(shared dependency)**을 선언하는 메커니즘

라이브러리가 직접 의존성을 설치하지 않고, 사용자가 특정 버전의 라이브러리를 갖고 있다고 가정하고 동작함

예시:

```json
{
  "name": "react-plugin-A",
  "peerDependencies": {
    "react": "^18.0.0"
  }
}
```

`react-plugin-A`는 React를 직접 설치하지 않고, 사용자가 이미 React 18을 설치했다고 가정

→ 이렇게 해야 플러그인이 사용자 프로젝트 안의 React 인스턴스와 동일한 버전을 공유하게 됨

### peerDependencies가 중요한 이유

**1. 버전 불일치 문제**

React 플러그인이 React 18을 요구하는데 프로젝트가 React 17을 사용 중이라면?

→ 런타임 충돌 발생 가능

**2. 여러 패키지가 서로 다른 peerDeps를 요구하는 경우**

- A는 React 17을 요구
- B는 React 18을 요구

→ 동시에 사용 불가

`npm i --force` 또는 `npm i --legacy-peer-deps`로 강제 설치 가능하지만, 이는 빌드가 되게만 하는 임시방편. 의존성 충돌은 그대로 존재함

→ 실무에서는 두 라이브러리를 동시에 써야 하는 설계 자체를 재검토해야 함

### 전역 설치

| 항목 | 내용 |
| --- | --- |
| 목적 | CLI 도구처럼 전역에서 실행 가능한 프로그램 설치 |
| 예시 | `npm i -g nodemon`, `npm i -g eslint` |
| 설치 경로 | macOS: `/usr/local/lib/node_modules`<br>Windows: `C:\Users\<사용자>\AppData\Roaming\npm` |
| 확인 | `npm root -g` |

전역 패키지는 프로젝트의 `package.json`에 기록되지 않음

→ 전역 설치는 프로젝트 내부가 아닌, 시스템 전체에 설치되는 CLI용 도구이기 때문

### 실무 개발 패턴

| 상황 | 추천 방식 |
| --- | --- |
| React / Vue 플러그인 개발 | `peerDependencies` 명시 필수 |
| 라이브러리 배포 | `dependencies`는 필요한 최소한만 포함 |
| 빌드, 테스트 도구 | `devDependencies`로 관리 |
| CLI 도구 배포 | `bin` 필드 + 전역 설치 고려 |

**기억할 것:**
1. 라이브러리 배포할 때는 `peerDependencies`로 호환성 관리
2. 패키지 설치할 때 `peerDependencies` 경고 무시하지 말 것
3. CLI 도구는 global, 코드 실행용 라이브러리는 local

---

## npm 명령어

### 기본 정보 확인

| 명령어 | 설명 |
| --- | --- |
| `npm -v` | npm 버전 확인 |
| `node -v` | Node.js 버전 확인 |
| `npm config list` | npm 설정값 목록 확인 |
| `npm root -g` | 전역 패키지 설치 경로 확인 |
| `npm list` | 현재 프로젝트의 의존성 트리 확인 |
| `npm list -g --depth=0` | 전역 설치된 패키지 목록 확인 |

### 패키지 설치 / 제거

| 명령어 | 설명 |
| --- | --- |
| `npm install <패키지명>` | 패키지 설치 (`dependencies`에 자동 추가) |
| `npm install <패키지명> --save-dev` | 개발용 패키지 설치 |
| `npm install` | `package.json`에 있는 모든 의존성 설치 |
| `npm install -g <패키지명>` | 전역 설치 |
| `npm uninstall <패키지명>` | 패키지 제거 |
| `npm ci` | CI 환경 전용 설치 (lockfile 기반) |

### 의존성 관리

| 명령어 | 설명 |
| --- | --- |
| `npm update` | 모든 의존성을 최신 버전으로 업데이트 |
| `npm outdated` | 업데이트 가능한 패키지 목록 확인 |
| `npm audit` | 보안 취약점 점검 |
| `npm audit fix` | 자동으로 취약점 수정 시도 |
| `npm dedupe` | 중복 설치된 패키지 통합 |
| `npm rebuild` | 손상된 패키지 재빌드 |

`npm audit`는 패키지의 취약점을 검사함

npm에 패키지들이 워낙 많다 보니 일부 패키지는 악성 코드를 담고 있음. 이런 것들이 npm에 보고되는데, npm audit을 통해 악성 코드가 담긴 패키지를 설치하지 않았는지 검사 가능

### 프로젝트 초기화 / 정보

| 명령어 | 설명 |
| --- | --- |
| `npm init` | 새 `package.json` 파일 생성 (대화형) |
| `npm init -y` | 기본 설정으로 즉시 생성 |
| `npm info <패키지명>` | 패키지 정보 보기 |
| `npm view <패키지명> version` | 특정 패키지의 최신 버전만 확인 |
| `npm docs <패키지명>` | 해당 패키지 공식 문서 페이지 열기 |
| `npm repo <패키지명>` | 해당 패키지의 GitHub 저장소 열기 |

### 스크립트 실행

| 명령어 | 설명 |
| --- | --- |
| `npm run <스크립트명>` | `package.json`의 `"scripts"` 항목 실행 |
| `npm start` | `"start"` 스크립트 실행 |
| `npm run build` | 빌드 명령 실행 |
| `npm test` | 테스트 명령 실행 |

예시:

```json
{
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon server.js",
    "test": "jest"
  }
}
```

scripts 부분에 start 속성은 잊지 말고 넣어야 함

`nodemon app`을 하면 app.js를 nodemon으로 실행한다는 뜻. 서버 코드에 수정 사항이 생길 때마다 매번 서버를 재시작하기는 귀찮으므로 nodemon 모듈로 서버를 자동으로 재시작

### 캐시 / 정리

| 명령어 | 설명 |
| --- | --- |
| `npm cache verify` | 캐시 무결성 검사 |
| `npm cache clean --force` | npm 캐시 강제 삭제 |
| `npm prune` | `package.json`에 없는 불필요한 패키지 제거 |
| `npm doctor` | npm 환경 진단 |

### npx

전역 설치를 기피하고 싶을 때 사용

전역 패키지는 `package.json`에 기록되지 않아 재설치의 어려움이 있기 때문

```bash
$ npm install --save-dev rimraf
$ npx rimraf node_modules
```

`npx <패키지명>`: 전역 설치 없이 일회성 실행

### 유용한 패키지

**rimraf**

리눅스나 맥의 rm -rf 명령어를 윈도우에서도 사용 가능하게 해주는 패키지

**patch-package**

node_modules 내부의 수정 사항을 영구적으로 반영해주는 패키지

설치한 패키지에서 버그가 발생했는데 당장 수정이 필요할 때 주로 사용. 문제는 수정한 그 당시에는 node_modules 내부 패키지가 잘 돌아가지만 한 번이라도 npm i를 입력하게 되면 수정한 내용이 초기화됨

---

## Express 프레임워크

### Node.js와 Express

Node.js는 HTTP 모듈을 내장하고 있어서 간단히 서버를 만들 수 있음

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  if (req.url === '/') res.end('홈페이지');
  else if (req.url === '/about') res.end('소개 페이지');
  else res.end('404 Not Found');
});

server.listen(3000, () => console.log('Server running on 3000'));
```

문제는 요청 경로마다 if문으로 분기해야 하고, POST body 파싱, 쿠키 처리, 정적 파일 서빙 같은 건 직접 다 구현해야 함

→ 복잡한 웹 서비스를 만들기엔 너무 비효율적

Express는 Node.js 위에 만들어진 웹 애플리케이션 프레임워크

Node.js의 저수준 API를 더 쉽고 체계적으로 다루기 위한 추상화 계층

### Express를 쓰는 이유

| 이유 | 설명 |
| --- | --- |
| 라우팅 | URL마다 다른 함수로 깔끔하게 분리 가능 |
| 미들웨어 | 요청/응답 중간에 로직을 끼워 넣어 재사용성 향상 |
| 요청 데이터 파싱 | `req.body`, `req.params`, `req.query` 등 자동 처리 |
| 정적 파일 제공 | 이미지, CSS, JS 파일을 자동으로 서비스 |
| 확장성 | 쿠키, 세션, CORS, JWT, 로깅 등 미들웨어로 손쉽게 확장 |
| 코드 구조화 | 대규모 서버 코드도 모듈 단위로 깔끔하게 관리 |

### 코드 비교

**순수 Node.js 버전**

```javascript
const http = require('http');
const url = require('url');

http.createServer((req, res) => {
  const path = url.parse(req.url).pathname;
  if (path === '/user' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ name: 'Yoonsle' }));
  } else {
    res.writeHead(404);
    res.end('Not Found');
  }
}).listen(3000);
```

**Express 버전**

```javascript
const express = require('express');
const app = express();

app.get('/user', (req, res) => {
  res.json({ name: 'Yoonsle' });
});

app.listen(3000, () => console.log('Server running on 3000'));
```

불필요한 `url.parse`, `res.writeHead`, `JSON.stringify` 같은 것을 전부 없애줌

→ 코드가 훨씬 직관적이고 유지보수하기 쉬움

### Express 시작하기

```json
{
  "name": "learn-express",
  "version": "1.0.0",
  "scripts": {
    "start": "nodemon app"
  },
  "dependencies": {
    "express": "^5.1.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}
```

```javascript
const express = require('express');
const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
  res.send('Hello, Express');
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

**코드 설명**

1. `const express = require('express');` - Express 패키지 불러오기
2. `const app = express();` - Express 함수 실행하면 서버 인스턴스 생성
3. `app.set('port', ...)` - 서버가 사용할 포트 번호 설정. `process.env.PORT`는 환경 변수, 없으면 3000 사용
4. `app.get('/', ...)` - 루트 경로로 GET 요청이 들어오면 실행할 함수 등록
5. `app.listen(...)` - 서버를 실행하고 지정한 포트에서 요청 대기

### req, res 객체

Express가 요청을 받을 때 자동으로 만들어서 콜백 함수에 전달해주는 객체

**req (Request)**

| 속성 | 설명 | 예시 |
| --- | --- | --- |
| `req.method` | HTTP 메서드 | `"GET"` |
| `req.url` | 요청된 URL 경로 | `"/users?id=1"` |
| `req.query` | 쿼리스트링 객체 | `{ id: "1" }` |
| `req.params` | URL 파라미터 객체 | `/user/:id → { id: "10" }` |
| `req.body` | POST로 전달된 본문 | `{ name: "Yoonsle" }` |
| `req.headers` | 요청 헤더 정보 | `{ host: 'localhost:3000' }` |

**res (Response)**

| 메서드 | 설명 | 예시 |
| --- | --- | --- |
| `res.send()` | 문자열, 객체 등 응답 전송 | `res.send('ok')` |
| `res.json()` | JSON 형식으로 응답 | `res.json({ success: true })` |
| `res.status()` | HTTP 상태 코드 지정 | `res.status(404).send('Not Found')` |
| `res.redirect()` | 다른 주소로 리다이렉트 | `res.redirect('/login')` |
| `res.set()` | 응답 헤더 지정 | `res.set('Content-Type', 'text/html')` |
| `res.end()` | 응답 종료 | `res.end()` |

---

## 미들웨어

미들웨어는 Express의 핵심

요청과 응답의 중간(middle)에 위치하기 때문에 미들웨어(middleware)라고 부름

### 기본 사용법

미들웨어는 `app.use`와 함께 사용

```javascript
app.set('port', process.env.PORT || 3000);

app.use((req, res, next) => {
  console.log('모든 요청에 다 실행됩니다.');
  next();
});

app.get('/', (req, res, next) => {
  console.log('GET / 요청에서만 실행됩니다.');
  next();
}, (req, res) => {
  throw new Error('에러는 에러 처리 미들웨어로 갑니다.')
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
});
```

**형태**: `app.use((req, res, next) => { ...; next(); })`

**역할**: 요청과 응답 사이에 끼어 공통 로직을 실행

**실행 흐름**: 위에서 아래로 순서대로 실행됨 (등록 순서 = 실행 순서)

**next()**: 다음 미들웨어/라우터로 넘어가는 신호. `next()`를 호출하지 않으면 거기서 요청이 멈춤

**경로 필터링**

- `app.use(미들웨어)` - 모든 요청에 실행
- `app.use('/abc', 미들웨어)` - 경로가 `/abc`로 시작하는 요청에만 실행
- `app.post('/abc', 미들웨어)` - POST + `/abc`로 시작하는 요청에만 실행

### 에러 처리 미들웨어

형태: `(err, req, res, next)` - **반드시 4개의 매개변수**

위 체인에서 `throw`되거나 `next(err)`로 전달된 에러를 여기서 받아 응답 형식을 통일

```javascript
app.get('/', (req, res, next) => {
  try { throw new Error('문제 발생'); }
  catch (err) { next(err); }
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ message: '서버 에러' });
});
```

매개변수 3개짜리는 일반 미들웨어, 4개짜리는 에러 처리 미들웨어

보통 맨 아래(다른 미들웨어/라우터 아래)에 배치

### 자주 쓰는 미들웨어

```javascript
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const dotenv = require('dotenv');
const path = require('path');

dotenv.config();
const app = express();
app.set('port', process.env.PORT || 3000);

app.use(morgan('dev'));
app.use('/', express.static(path.join(__dirname, 'public')));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser(process.env.COOKIE_SECRET));
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: { httpOnly: true, secure: false },
  name: 'session-cookie',
}));
```

**dotenv.config()**

`.env` 파일을 읽어 `process.env`에 환경변수 주입

코드에 비밀키를 직접 쓰지 말고 `.env`로 분리. `.gitignore`에 `.env`를 꼭 추가

**morgan('dev')**

들어오는 요청의 메서드/경로/상태코드/응답시간 등을 콘솔에 출력

맨 앞에 두는 이유 - 가장 먼저 요청을 관찰해야 전체 흐름을 기록할 수 있음

**express.static(...)**

`/public` 폴더의 파일을 그대로 서빙

예: `/public/logo.png` → `GET /logo.png`로 접근 가능

라우터보다 위에 두면 정적 파일은 바로 응답되고 뒤 로직을 타지 않아 성능상 이점

**express.json(), express.urlencoded()**

요청 본문을 파싱해서 `req.body`에 넣어줌

- `json()` - `Content-Type: application/json`
- `urlencoded({ extended: false })` - 폼 전송(`application/x-www-form-urlencoded`)

이게 없으면 `req.body`가 `undefined`

바디를 쓰는 로그인/회원가입/POST 라우터보다 위에 둬야 함

**cookieParser(secret)**

요청 헤더의 쿠키를 읽어 `req.cookies`, 서명된 쿠키는 `req.signedCookies`에 넣어줌

`secret` 제공 시 쿠키 위변조 감지 가능

세션보다 먼저 두는 이유 - 세션 미들웨어가 내부적으로 쿠키(세션ID)를 사용하기 때문

**session({...})**

서버가 세션ID를 발급하고, 사용자별로 상태를 저장

주요 옵션:
- `secret` - 세션 쿠키 서명 키 (반드시 환경변수)
- `resave: false` - 매 요청마다 세션 저장하지 않음 (변경 시만)
- `saveUninitialized: false` - 초기 세션(내용 없음)은 저장하지 않음
- `cookie.httpOnly: true` - JS에서 쿠키 접근 불가 (XSS 완화)
- `cookie.secure: false` - HTTPS에서만 전송하려면 배포 시 true 권장
- `name` - 쿠키 이름 (기본 `connect.sid` 대신 커스텀)

### 미들웨어 순서

1. 로깅(morgan)
2. 정적 파일(express.static)
3. 바디 파서(express.json, urlencoded)
4. 쿠키 파서(cookieParser)
5. 세션(session)
6. 사용자 정의 미들웨어/라우터
7. 404/에러 핸들러

### multer - 파일 업로드

`multer`는 `multipart/form-data` 형식의 파일 업로드를 처리하는 미들웨어

```javascript
const multer = require('multer');
const path = require('path');

const upload = multer({
  storage: multer.diskStorage({
    destination(req, file, done) {
      done(null, 'uploads/');
    },
    filename(req, file, done) {
      const ext = path.extname(file.originalname);
      done(null, path.basename(file.originalname, ext) + Date.now() + ext);
    }
  }),
  limits: { fileSize: 5 * 1024 * 1024 }
});
```

**storage: multer.diskStorage({...})**

파일을 디스크(로컬 폴더)에 저장하겠다는 뜻

`diskStorage` 안에는 두 개의 필수 함수가 있음

| 함수 | 역할 |
| --- | --- |
| `destination(req, file, done)` | 업로드한 파일이 저장될 폴더 경로 지정 |
| `filename(req, file, done)` | 실제 저장될 파일 이름 규칙 지정 |

**destination(req, file, done)**

- 첫 번째 인자 `req` - 요청 정보
- 두 번째 인자 `file` - 업로드된 파일 정보 객체
- 세 번째 인자 `done` - 결과를 전달하는 콜백 함수

```javascript
destination(req, file, done) {
  done(null, 'uploads/');
}
```

`done(null, 'uploads/')` - 에러는 없으므로 첫 번째 인자는 `null`, 저장할 경로는 `'uploads/'`

**filename(req, file, done)**

실제 파일 이름을 정해주는 부분

```javascript
filename(req, file, done) {
  const ext = path.extname(file.originalname); // 확장자 추출 (.png)
  done(null, path.basename(file.originalname, ext) + Date.now() + ext);
}
```

사용자가 `dog.png`를 업로드했다면:
- `path.extname(file.originalname)` → `.png`
- `path.basename(file.originalname, ext)` → `dog`
- `Date.now()` → 현재시간(예: `1730000000000`)
- 최종 이름 → `dog1730000000000.png`

→ 이렇게 하면 이름이 겹치지 않음

**limits: { fileSize: 5 * 1024 * 1024 }**

업로드 파일의 크기 제한(바이트 단위)을 지정

`5 * 1024 * 1024` = 5MB

초과하면 Multer가 에러를 던짐

**upload 객체 사용**

| 메서드 | 설명 |
| --- | --- |
| `upload.single('fieldname')` | 하나의 파일만 업로드 (폼 필드명이 `'fieldname'`) |
| `upload.array('fieldname')` | 여러 파일 업로드 (같은 필드명으로 여러 개) |
| `upload.fields([{ name: 'profile' }, { name: 'banner' }])` | 여러 필드 각각의 파일 업로드 |
| `upload.none()` | 파일 없이 폼데이터(text만) 받을 때 |

**실제 사용 예시**

```javascript
const express = require('express');
const multer = require('multer');
const path = require('path');
const app = express();

app.post('/upload', upload.single('image'), (req, res) => {
  console.log(req.file);  // 업로드된 파일 정보
  res.send('업로드 성공!');
});
```

클라이언트가 `<input type="file" name="image" />`로 전송하면

→ multer가 요청을 처리하고, 파일을 uploads 폴더에 저장한 후 파일 정보(`req.file`)를 다음 라우터에 전달

**req.file / req.files 구조**

파일 업로드 후에는 다음 정보가 자동으로 담김

```javascript
{
  fieldname: 'image',
  originalname: 'dog.png',
  encoding: '7bit',
  mimetype: 'image/png',
  destination: 'uploads/',
  filename: 'dog1730000000000.png',
  path: 'uploads/dog1730000000000.png',
  size: 51234
}
```

**주의사항**

- 폴더가 미리 존재해야 함. `uploads/` 폴더가 없으면 에러 발생 → `fs.mkdirSync('uploads')`로 미리 생성
- 실제 서비스에서는 파일 이름을 UUID처럼 난수화하거나 클라우드 스토리지(S3, GCS)에 업로드하도록 설정
- `fileFilter` 옵션으로 업로드 허용 확장자 제한 가능

```javascript
fileFilter(req, file, cb) {
  if (file.mimetype.startsWith('image/')) cb(null, true);
  else cb(new Error('이미지만 업로드 가능합니다.'));
}
```

### 다양한 미들웨어 정리

| 미들웨어 | 핵심 역할 | 언제 쓰나 | `req`/`res`에 생기는 것 | 권장 순서 |
| --- | --- | --- | --- | --- |
| morgan | 요청/응답 로그 출력 | 개발/운영 로깅 | (없음) 콘솔 출력 | 1. 최상단 |
| static | 정적 파일 서빙 | 이미지/JS/CSS 공개 | 캐시/헤더 자동 처리 | 2. 로깅 다음 |
| body-parser | 요청 본문 파싱 | API의 JSON/폼 처리 | `req.body` | 3. 정적 다음, 라우터 이전 |
| cookie-parser | 쿠키 파싱/서명 검증 | 세션/인증/추적 | `req.cookies`, `req.signedCookies` | 4. 바디파서 뒤, 세션 이전 |
| express-session | 서버 세션 상태 유지 | 로그인/장바구니 등 | `req.session` | 5. 쿠키파서 다음 |
| multer | 파일 업로드 | 이미지/문서 업로드 | `req.file(s)` | 파일 업로드 라우트 직전 |

**기억할 것:**

- `.env`를 `.gitignore`에 추가
- `COOKIE_SECRET` 같은 키는 환경변수로 관리
- 미들웨어 순서 지키기 (특히 쿠키→세션)
- 에러 처리 미들웨어는 4개 인수 + 맨 아래
- `secure: true`는 HTTPS에서만 - 배포 환경에서 활성화
- 정적 파일 제공은 최대한 위쪽에서 빠르게 처리