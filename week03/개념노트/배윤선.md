# Ch5 패키지 매니저


# npm 알아보기

npm, ***Node Package Manager***

- 이름 그대로 **노드 패키지 매니저**를 의미함
- 고로 특정 기능을 하는 패키지가 필요하다면 npm에서 찾아 설치하면 됨

📌 패키지 : npm에 업로드된 노드 모듈

📌 npm서버가 느릴 경우 yarn이나 pnpm으로 패키지 매니저를 변경하는 걸 고려해볼 수도 있음

# package.json으로 패키지 관리하기

📢 5.3 패키지 버전 이해하기뿐만 아니라 5.4 기타 npm명령어 내용도 포함함

package.json : 설치한 패키지의 버전을 관리하는 파일임

서비스에 필요한 패키지를 하나둘 추가하다보면 언젠가 엄청나게 많아져버리게 되고 마는데… 이때 패키지 저마다의 고유한 버전이나 버전별 기능에 대한 기록을 해두지 않으면 문제가 생길 수 있음 고로 package.json을 통해 패키지 관리를 하는 것임. 

따라서 노드 프로젝트를 시작하기 전엔 꼭!!! 폴더 내부에 package.json부터 만들고 시작해야 함

## 1. pacakage.json 생성하기

**How**? 콘솔에서 `npm init`명령어를 사용한다

```bash
$ npm init
```

이 명령어는 `package.json` 파일을 생성하기 위한 유틸리티를 실행하며, 다음과 같은 기본 항목들을 물어봄

- **package name:** 패키지 이름 (`name` 속성)
- **version:** 패키지 버전 (`version` 속성)
- **description:** 프로젝트 설명 (`description` 속성)
- **entry point:** 자바스크립트 실행 파일 진입점 (`main` 속성)
- **test command:** 테스트 시 입력할 명령어 (`scripts.test` 속성)
- **git repository:** 깃 저장소 주소 (`repository` 속성)
- **keywords:** npm에서 패키지를 쉽게 찾기 위한 키워드 (`keywords` 속성)
- **author:** 작성자 (`author` 속성)
- **license:** 패키지 라이선스 (`license` 속성)

## 2. scripts속성

- scripts부분은 npm명령어를 저장해두는 곳임
- 다음 명령어로 실행할 수 있음

```bash
$ npm tun [스크립트 명령어]
```

📌 `start`나 `test` 같은 특정 스크립트는 `run`을 생략하고 `npm start`, `npm test`로 실행할 수 있음

## 3. 패키지 설치 및 관리

### 패키지 설치

```bash
$ npm install [패키지 이름]
```

### dependencies

- 패키지를 설치하면 `package.json`에 `dependencies` 속성이 자동으로 추가됨
- 설치된 패키지명과 버전이 기록됨

### node_modules

- 패키지를 설치하면 node_modules라는 폴더가 생성 → 설치한 패키지 및 해당 패키지가 의존하는 다른 모든 패키지들이 이 폴더 안에 저장
- 일반적으로 node.modules폴더는 깃git과 같은 버전관리시스템에 포함X

### package-lock.json

- `package-lock.json`은 `node_modules`에 설치된 패키지들의 **정확한 실제 버전과 패키지 간의 의존 관계**를 명시한 파일임
- 패키지를 설치, 수정, 삭제할 때마다 갱신됨
- 서비스 배포 시에는 `npm i` 대신 `npm ci` 명령어를 사용하며, 이는 `package-lock.json`에 명시된 버전과 구조를 그대로 설치하여 일관성을 보장함

## 의존성의 종류

### devDependencies

- 실제 배포 시엔 사용X 개발과정 중에만 사용됨
- `--save-dev` 또는 `-D` 옵션을 붙여 설치
- 설치 시 package.json의 devDependencies속성에 따로 기록됨

```bash
$ npm install --save-dev nodemon
```

### peerDependencies

- 해당 패키지가 **직접 사용(require/import)하지는 않지만, 특정 버전의 패키지가 설치되어 있다고 가정하고** 작성되었음을 명시함
    - 예: 라이브러리 A가 jQuery 3 버전을 `peerDependencies`로 명시했다면, A를 사용하는 프로젝트는 jQuery 3 버전을 직접 설치해야 합니다.
- 버전이 맞지 않으면 `ERESOLVE` 에러가 발생할 수 있음 ㅇㅇ

## 전역설치

- `npm install --global [패키지 이름]` (또는 `g`)로 설치함
- 현재 프로젝트의 `node_modules`가 아닌, 시스템의 공용 npm 폴더에 설치됨
- 주로 `rimraf`처럼 콘솔에서 명령어로 사용하기 위한 패키지를 설치할 때 사용
- `package.json`에 기록되지 않아 버전 관리가 어렵다는 단점이 있음

### npx

- `npx`는 패키지를 전역 설치하지 않고도, 로컬 `node_modules`에 설치된 패키지의 명령어를 실행할 수 있게 해줌
- 전역 설치를 기피하고 `package.json`을 통해 버전을 관리하고자 할 때 유용

```bash
# 1. rimraf를 개발용(로컬)으로 설치
$ npm install --save-dev rimraf

# 2. npx를 사용해 로컬에 설치된 rimraf 명령어 실행
$ npx rimraf node_modules
```

# 패키지 배포하기

패키지 배포하기란? 

→ 작성한 패키지를 npm레지스트리에 배포하는 과정을 말함 

## 0. 배포 전 준비사항

1. npm 회원가입
2. 이메일 인증
3. CLI 로그인 

```bash
$ npm login
```

## 1. 패키지 코드 작성

- 배포할 코드를 작성함
- 이때 package.json의 main속성에 지정된 파일이 패키지의 entry point가 됨

```bash
module.exports = () => {
  return 'hello package';
};
```

## 2. 패키지 배포 및 오류 처리

### 배포

```bash
$ npm publish
```

## 이름 중복 오류

만약 사용하려는 이름을 다른 사용자가 이미 쓰고 있다면 `E403 Forbidde`라는 메시지가 나타남

**Why**? npm은 패키지 이름의 중복을 허용하지 않기 때문임

고로 쓰려는 이름의 사용 여부를 확인하고자 한다면 → `npm info [패키지 이름]` 명령어로 확인 가능함

1. 정보가 나오면 이미 사용중인 이름임
2. E404에러가 발생하면 사용가능한 이름임

### 버전 중복 오류

이미 배포한 버전을 수정하고, 버전을 올리지 않은 채 다시 `npm publish`를 실행하면 E403에러가 발생함

어떻게 해결할 수 있을까?

→ `npm version`명령어를 사용해 pacakage.json버전을 올려야 함

## 3. 패키지 버전 관리

`npm version` 명령어를 사용하여 패키지의 버전을 업데이트할 수 있음 

- `patch` (세 번째 자리): `npm version patch` 실행 시 `v0.0.2`가 됩니다.
- `minor` (두 번째 자리): `npm version minor` 실행 시 `v0.1.0`이 됩니다.
- `major` (첫 번째 자리): `npm version major` 실행 시 `v1.0.0`이 됩니다.

## 4. 배포한 패키지 삭제

`npm unpublish` 명령어로 배포한 패키지를 삭제할 수 있습니다.

⚠️ 배포 후 72시간이 지나면 삭제할 수 없습니다.

- 삭제 시 `-force` 옵션이 필요합니다.
- `npm info [패키지 이름]`을 실행했을 때 `E404` 오류가 발생하면 성공적으로 삭제된 것입니다.

```bash
$ npm unpublish [패키지 이름] --force
```

## 배포 시 주의사항 🤯

- **개인정보 확인:** 코드를 세상에 공개하는 것이므로, 배포 전 코드에 개인정보나 서비스의 비밀 키 등이 포함되지 않았는지 반드시 확인해야 함
- **이름 선점 금지:** 실제로 사용할 패키지가 아님에도 불구하고 단순히 이름을 선점하는 행위는 지양해야 함


# Ch6 익스프레스 웹서버 만들기

# 6.1 익스프레스 프로젝트 시작하기

## 1. 프로젝트 초기 설정

1. 프로젝트 폴더 생성
2. npm init 또는 npm init -y 명령어를 통해 package.json파일을 생성함
3. package.json설정
    - `main` 항목은 `app.js`로 지정
    - `scripts`의 `start` 항목은 `nodemon app`으로 지정
    - `"start": "nodemon app"`: `npm start` 명령어 실행 시, `nodemon`이 `app.js` 파일을 실행하도록 설정 → `nodemon`은 서버 코드가 변경될 때마다 자동으로 서버를 재시작해 주어 개발에 편리함
    
    ```json
    {
      "name": "learn-express",
      "version": "0.0.1",
      "description": "익스프레스를 배우자",
      "main": "app.js",
      "scripts": {
        "start": "nodemon app"
      },
      "author": "ZeroCho",
      "license": "MIT"
    }
    ```
    

## 2. 핵심 패키지 설치

```bash
$ npm i express
$ npm i -D nodemon
```

- `express`: 런타임 의존성으로 설치
- `nodemon`: 개발용 의존성(`D` 또는 `-save-dev`)으로 설치

## 3. 기본 익스프레스 서버

package.json의 main으로 지정했던 app.js파일을 작성함

```jsx
const express = require('express');

const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
  res.send('Hello, Express');
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

## 4. 서버 실행

- package.json에 정의한 스크립트를 사용해 서버를 실행함
- 서버가 실행되면 콘솔창에 `3000 번 포트에서 대기 중` 메시지가 출력됨

```bash
$ npm start
```

## 5. HTML파일로 응답하기

단순한 문자열 대신 HTML 파일을 응답으로 보낼 수 있음.

- **`res.sendFile(경로)`**: 파일을 응답으로 보낼 때 사용
- **`path` 모듈**: 파일 경로를 정확하게 지정하기 위해 Node.js의 `path` 모듈을 사용함

→ app.js 파일 수정

```jsx
const express = require('express');
const path = require('path');

const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
  // res.send('Hello, Express');
  res.sendFile(path.join(__dirname, '/index.html'));
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

# 6.2 자주 사용하는 미들웨어

## morgan

→ HTTP요청에 대한 로그를 콘솔에 출력해주는 미들웨어임

- 요청과 응답에 대한 정보를 확인하기 위해 사용
- 형식 : `app.use(morgan('dev'));`

**< 모드 >**

- **dev**
    - 개발용
    - 형식 : [HTTP 메서드] [주소] [HTTP 상태 코드] [응답 속도] - [응답 바이트]
- **combined**
    - 배포 환경용 - 더 자세한 정보를 로그로 남김
- 기타 : common, short, tiny

## static

→ 정적인 파일을 제공하는 미들웨어임

- Express에 내장되어 있어 따로 설치할 필요X
- fs.readFile같은 번거로운 작업 없이 정적 파일을 쉽게 제공
- 형식 : `app.use('요청 경로', express.static('실제 경로'));`

```jsx
app.use('/', express.static(path.join(__dirname, 'public')));
```

- 동작방식 : `http://localhost:3000/stylesheets/style.css` 요청이 오면, 서버의 `public` 폴더를 기준으로 `public/stylesheets/style.css` 파일을 찾아 제공
- 요청 주소엔 public이 포함되지 않아, 서버의 실제 폴더 구조를 외부에 노출X
- 파일을 찾으면 응답을 보내고 미들웨어 흐름이 종료됨
- 파일을 못 찾으면 next를 호출 → 다음 미들웨어로 제어를 넘김

## body-parser

→ 요청의 body에 담긴 데이터를 해석해 req.body객체로 만들어준다

- 폼 데이터나 AJAX요청의 JSON데이터를 처리

```jsx
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
```

### 특징

- express.json() : JSON형식의 데이터를 해석함
- `express.urlencoded({ extended: false })`: `name=zerocho&book=nodejs`와 같은 URL-encoded 형식의 폼 데이터를 해석함
    - `extended: false`: Node.js에 내장된 `querystring` 모듈을 사용함
    - `extended: true`: `qs` 모듈(추가 설치 필요)을 사용하여 더 복잡한 객체 해석을 지원함
- 제한 : 멀티파트 데이터는 처리X → multer를 써야함
- `Raw` (버퍼 데이터)나 `Text` (텍스트 데이터) 형식을 처리해야 할 때는 `body-parser`를 설치해야 함
    
    설치코드 : $ npm i body-parser
    
    ```jsx
    const bodyParser = require('body-parser');
    app.use(bodyParser.raw());
    app.use(bodyParser.text());
    ```
    

## cookie-parser

→ 요청에 포함된 쿠키를 해석해서 req.cookie객체로 만듦

- 클라이언트가 보낸 쿠키를 서버에서 쉽게 읽을 수 있게 함
- 형식 : app.use(cookieParser(비밀 키));
- 비밀키
    - 쿠키 signing에 사용됨 → 클라이언트에서 쿠키를 위조하는 것을 방지함
    - req.cookie : 서명되지 않은 일반 쿠키가 객체 형태로 들어있음
    - req.signedCookies : 서명된 쿠키가 이 객체에 들어있음
- 쿠키 생성 및 제거
    - cookie-parsers는 쿠키를 생성X → 생성/제거는 res객체를 통해 수행함
    - signed: true옵션 → 비밀키를 이용해 서명된 쿠키 생성 완.

```jsx
res.cookie('name', 'zerocho', { 
  expires: new Date(Date.now() + 900000),
  httpOnly: true, 
  secure: true,
});
res.clearCookie('name', 'zerocho', { httpOnly: true, secure: true });
```

## express-session

- 세션관리용 미들웨어임
- 로그인 정보 등을 사용자별로 req.session객체에 저장하고 유지함
- 주로 사용자 로그인 상태유지 등을 위해 사용함
- 사용자별로 고유한 세션ID를 발급하고 이 ID를 세션쿠키로 클라이언트에 보냄

```jsx
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIE_SECRET,
  cookie: {
    httpOnly: true,
    secure: false,
  },
  name: 'session-cookie',
}));
```

| **옵션** | **설명** |
| --- | --- |
| `resave: false` | 요청이 와도 세션에 수정 사항이 없으면 다시 저장하지 않음 |
| `saveUninitialized: false` | 세션에 저장할 내용이 없으면 처음부터 세션을 생성하지 않음 |
| `secret` | 세션 쿠키를 서명하기 위한 비밀 키 (cookie-parser의 secret과 동일하게 설정 권장) |
| `cookie.httpOnly: true` | 클라이언트 JS에서 쿠키를 조작할 수 없게 함 |
| `cookie.secure: false` | HTTPS가 아닌 환경에서도 쿠키를 전송함 (배포 시에는`true`권장) |
| `store` | 세션 저장소. 기본값은 메모리(서버 재시작 시 초기화됨)이며, 배포 시에는 Redis 등을 연결함 |

### 세션 사용법

세션 쿠키 형태 : 서명된 세션 쿠키는 s:로 시작함 

```jsx
req.session.name = 'zerocho'; // 세션 등록
req.sessionID; // 세션 아이디 확인
req.session.destroy(); // 세션 모두 제거
```

## 미들웨어의 특성 활용하기

### 기본

- 미들웨어는 `(req, res, next)`를 매개변수로 갖는 함수
- 에러 처리 미들웨어는 `(err, req, res, next)`

### **흐름 제어**

- `next()`: 다음 미들웨어로 제어를 넘김
- `res.send()` / `res.sendFile()`: 응답을 보내고 흐름을 종료
- `next()`나 응답 전송 중 하나도 하지 않으면 클라이언트는 응답을 받지 못하고 대기함

### **특수 `next` 호출**

- `next('route')`: 다음 라우터로 제어를 넘김
- `next(err)`: 인수를 넣으면(단, 'route' 제외) 에러로 간주되어, 즉시 에러 처리 미들웨어로 이동함

### **미들웨어 간 데이터 전달**

- **`res.locals`**: **하나의 요청이 처리되는 동안** 미들웨어 간에 데이터를 공유할 때 사용합니다. 다음 요청이 오면 초기화됩니다.JavaScript
- **`app.set`**: 앱(App) 전역에서 사용되는 데이터를 저장합니다. 요청에 종속되는 데이터를 넣기에는 부적절합니다.
    
    ```jsx
    app.use((req, res, next) => {
      res.locals.data = '데이터 넣기';
      next();
    }, (req, res, next) => {
      console.log(res.locals.data); // 데이터 받기
      next();
    });
    ```
    

### **미들웨어 패턴 (조건부 실행)**

- 미들웨어 함수 내부에 다른 미들웨어를 넣어 조건에 따라 다르게 동작하게 할 수 있습니다.

```jsx
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production') {
    morgan('combined')(req, res, next);
  } else {
    morgan('dev')(req, res, next);
  }
});
```

## multer

- 파일 업로드(멀티파트 데이터)를 처리하기 위한 미들웨어
- `body-parser`가 처리하지 못하는 `enctype="multipart/form-data"` 폼을 해석함
- **설치**: `$ npm i multer`

### **핵심 설정**

- `storage`: 파일 저장 방식 설정
    - `destination`: 파일 저장 경로
    - `filename`: 파일 저장 이름. 이때, 중복 방지를 위해 `Date.now()` 등을 붙이는 것이 좋음
- `limits`: 파일 크기(`fileSize`) 등 업로드 제한 설정

### **실습 코드**

**기본 설정**

```jsx
const multer = require('multer');

const upload = multer({
  storage: multer.diskStorage({
    destination(req, file, done) {
      done(null, 'uploads/');
    },
    filename(req, file, done) {
      const ext = path.extname(file.originalname);
      done(null, path.basename(file.originalname, ext) + Date.now() + ext);
    },
  }),
  limits: { fileSize: 5 * 1024 * 1024 },
});
```

### **파일 업로드 종류**:

1. **`upload.single('fieldName')`**: 단일 파일 업로드JavaScript
    - 파일 정보는 `req.file` 객체에, 텍스트 데이터는 `req.body`에 저장됩니다.
    
    ```jsx
    app.post('/upload', upload.single('image'), (req, res) => {
      console.log(req.file, req.body);
      res.send('ok');
    });
    ```
    
2. **upload.arra`y('fieldName')`**: 여러 파일 업로드 (동일 필드명, `multiple` 속성)JavaScript
    - 파일 정보는 `req.files` 배열에 저장됩니다.
    
    ```jsx
    app.post('/upload', upload.array('many'), (req, res) => {
      console.log(req.files, req.body);
      res.send('ok');
    });
    ```
    
3. **`upload.fields([{ name: 'image1' }, ...])`**: 여러 파일 업로드 (다른 필드명)JavaScript
    - 파일 정보는 `req.files.image1`, `req.files.image2` 등으로 나뉘어 저장됩니다.
    
    ```jsx
    app.post('/upload',
      upload.fields([{ name: 'image1' }, { name: 'image2' }]),
      (req, res) => {
        console.log(req.files, req.body);
        res.send('ok');
      },
    );
    ```
    
4. **`upload.none()`**: 파일 없이 텍스트 데이터만 멀티파트로 전송 시JavaScript
    - `req.body`에 텍스트 데이터만 저장됩니다.
    
    ```jsx
    app.post('/upload',  upload.none(),  (req, res) => {
      console.log(req.body);
      res.send('ok');
    });
    ```