---
Author: CarefreeLife98
Date: 2025-10-20T14:22:00
Agenda:
tags:
  - TSBM_STUDIO
  - NodeJS
---
# REPL (Read, Eval, Print, Loop)
Javascript 는 스크립트 언어이므로 미리 컴파일 하지 않아도 즉석에서 코드를 실행할 수 있다.

![[Pasted image 20251018183023.png]]
`입력한 코드를 읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 때까지 반복한다(Loop)고 해서 REPL(Read Eval Print Loop)이라고 한다.`

```bash
$ node

Welcome to Node.js v18.7.0.
Type ".help" for more information.
>
```
`노드의 REPL - 1`

```bash
> const str = 'Hello world, hello node';
undefined
> console.log(str);
Hello world, hello node
undefined
>
```
`노드의 REPL - 2`

입력한 코드를 REPL이 읽고(Read) 해석한(Eval) 뒤 바로 결과물을 출력했다(Print).

# 모듈(Module)
노드는 코드를 모듈(Module) 로 만들 수 있다는 점에서 브라우저의 자바스크립트와 다르다.

> 모듈 (Module) 이란 특정한 기능을 하는 함수나 변수들의 집합을 말합니다.
> - 예를 들면 수학에 관련된 코드들만 모아서 모듈을 하나 만들 수 있습니다.

모듈은 자체로도 하나의 프로그램이면서, 다른 프로그램의 일부로도 사용할 수 있다.

![[Pasted image 20251018183533.png]]
`모듈과 프로그램`

노드에서는 두 가지 형식의 모듈을 사용한다.
- CommonJS 모듈
- ECMAScript 모듈

## CommonJS 모듈
CommonJS 모듈은 표준 자바스크립트 모듈은 아니지만, 노드 생태계에서 가장 널리 쓰이는 모듈이다. (표준이 나오기 전부터 사용됨)

### CommonJS 형식 모듈 만들기
```bash
구조

folder
ㄴ var.js
ㄴ func.js
ㄴ index.js
```

```javascript
// var.js
const odd = 'CJS 홀수입니다';
const even = 'CJS 짝수입니다';

module.exports = {
  odd,
  even,
};
```
- `var.js` 에 변수 두 개를 선언하고, `module.exports` 에 변수들을 담은 객체를 대입했다.
- 이제 이 `var.js` 는 변수들을 모아둔 모듈로서 기능한다.
	- 다른 파일에서 이 파일을 불러오면, `module.exports` 에 대입된 값을 사용할 수 있다.

```javascript
// func.js
const { odd, even } = require('./var');

function checkOddOrEven(num) {
  if (num % 2) { // 홀수이면
    return odd;
  }
  return even;
}

module.exports = checkOddOrEven;
```
- `require()` 함수 안에 불러올 모듈 파일의 경로를 적어 불러온다. (파일 확장자, index.js 생략 가능)
- `var.js` 모듈의 변수를 사용하는 함수를 만들고 이를 다시 모듈로 생성.
	- 다른 모듈을 사용하는 파일을 다시 모듈로 생성할 수 있다.
	- `module.exports` 에는 객체 대입 뿐 아니라, 함수 / 변수의 대입도 가능하다.

```javascript
//index.js
const { odd, even } = require('./var');
const checkNumber = require('./func');

function checkStringOddOrEven(str) {
  if (str.length % 2) { // 홀수이면
    return odd;
  }
  return even;
}

console.log(checkNumber(10));
console.log(checkStringOddOrEven('hello'));
```
- `index.js` 는 `var.js` 와 `func.js` 를 모두 참조한다.
	- 모듈 하나가 여러 개의 모듈을 사용할 수 있다.
- `var.js` 가 `func.js` 와 `index.js`  에 두 번 사용.
	- 모듈 하나가 여러 개의 모듈에 사용될 수 있다.

![[Pasted image 20251018185008.png]]
`require 과 module.exports 의 관계`

### 모듈 순환 참조 (Circular Dependency)
모듈을 사용할 때는 주의할 점이 있다. 만약 두 모듈 `dep1` 과 `dep2` 가 있고, 이 둘이 서로를 `require` 한다면 어떻게 될까?

```javascript
// dep1.js
const dep2 = require('./dep2');
console.log('require dep2', dep2);

module.exports = () => {
  console.log('dep2', dep2);
};
```
`dep1.js`

```javascript
// dep2.js
const dep1 = require('./dep1');
console.log('require dep1', dep1);

module.exports = () => {
  console.log('dep1', dep1);
};
```
`dep2.js`

```javascript
// dep-run.js
const dep1 = require('./dep1');
const dep2 = require('./dep2');

dep1();
dep2();
```
`dep-run.js`

dep-run.js 를 만들어 두 모듈을 실행.

1. 자바스크립트 코드가 위에서부터 실행되므로 `require('./dep1');` 이 먼저 실행.
2. dep1.js 에서 제일 먼저 `require('./dep2');` 가 실행.
3. dep2.js 에서는 다시 require('./dep1'); 이 실행.
4. ...

```bash
$ node dep-run

require dep1 {}
require dep2 [Function (anonymous)]
dep2 [Function (anonymous)]
dep1 {}
(node:29044) Warning: Accessing non-existent property 'Symbol(nodejs.util.inspect.custom)' of module exports inside circular dependency
(Use `node --trace-warnings ...` to show where the warning was created)
...
```
- 그 결과, **dep1 의 module.exports 가 함수가 아닌 빈 객체로 표시**된다.
	- 이러한 현상을 `순환 참조 (cirdular-dependency)` 라고 함.
	- 순환 참조가 있을 경우에 **순환 참조되는 대상을 빈 객체로 만든다.**

순환 참조가 발생된 경우, 에러가 발생하지 않고 빈 객체로 변경되니 예기치 못한 동작이 발생할 수 있어 주의해야 한다.


## ECMAScript 모듈
**ECMAScript 모듈 (ES Module) 은 공식적인 자바스크립트 모듈 형식.**
브라우저에서도 ES 모듈을 사용할 수 있어, **브라우저와 Node.js 모두에서 같은 모듈 형식을 사용할 수 있는 장점**이 있다.

### ESMAScript 형식 모듈 만들기

```javascript
// var.mjs
export const odd = 'MJS 홀수입니다';
export const even = 'MJS 짝수입니다';
```
`var.mjs`

```javascript
// func.mjs
import { odd, even } from './var.mjs';

function checkOddOrEven(num) {
  if (num % 2) { // 홀수이면
    return odd;
  }
  return even;
}

export default checkOddOrEven;
```
`func.mjs`

```javascript
// index.mjs
import { odd, even } from './var.mjs';
import checkNumber from './func.mjs';

function checkStringOddOrEven(str) {
  if (str.length % 2) { // 홀수이면
    return odd;
  }
  return even;
}

console.log(checkNumber(10));
console.log(checkStringOddOrEven('hello'));
```
`index.mjs`

```bash
$ node index.mjs
MJS 짝수입니다
MJS 홀수입니다
```

`require, exports, module.exports` 가 각각 `import, export, export default` 로 바뀌었다.
ES 모듈의 `import, export, export default` 는 CommonJS 모듈의 `require, module` 처럼 **함수나 객체가 아니라 문법 그 자체**이다.

파일 확장자도 `.js` 대신 `.mjs` 로 변경되었다.

> .js 확장자를 사용하면서 ES Module 을 사용하려면, package.json > type: "module" 속성을 추가해주면 된다.


## CommonJS 모듈과 ECMAScript 모듈의 차이 (표)
| **차이점**                                                         | **CommonJS 모듈**                                                                                                                                                               | **ECMAScript 모듈**                                                                                                                                                              |
| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **문법**                                                          | require('./a');<br><br>module.exports = A;<br><br>const A = require('./a');<br><br>exports.C = D;<br><br>const E = F; exports.E = E;<br><br>const { C, E } = require ('./b'); | import './a.mjs';<br><br>export default A;<br><br>import A from './a.mjs';<br><br>export const C = D;<br><br>const E = F; export { E };<br><br>import { C, E } from './b.mjs'; |
| **확장자**                                                         | js<br><br>cjs                                                                                                                                                                 | js(package.json에 type: "module" 필요)<br><br>mjs                                                                                                                                 |
| **확장자 생략**                                                      | 가능                                                                                                                                                                            | 불가능                                                                                                                                                                            |
| **다이내믹 임포트**                                                    | 가능(3.3.3절 참고)                                                                                                                                                                 | 불가능                                                                                                                                                                            |
| **인덱스(index) 생략**                                               | 가능(require('./folder'))                                                                                                                                                       | 불가능(import './folder/index.mjs')                                                                                                                                               |
| **top level await**                                             | 불가능                                                                                                                                                                           | 가능                                                                                                                                                                             |
| **\_\_filename, \_\_dirname, require, module.exports, exports** | 사용 가능(3.3.4절 참고)                                                                                                                                                              | 사용 불가능(\_\_filename 대신 import.meta.url 사용)                                                                                                                                     |
| **서로 간 호출**                                                     | 가능                                                                                                                                                                            | 가능                                                                                                                                                                             |

## 다이내믹 임포트 (Dynamic Import)
`다이내믹 임포트 (Dynamic Import)`: **조건부**로 모듈을 불러오는 것.

```javascript
// dynamic.js
const a = false;
if (a) {
	require('./func');
}
console.log('성공');
```

```bash
$ node dynamic
성공
```

위 예시인 `dynamic.js` 에서 `require('./func')` 는 실행되지 않지만, 이렇듯 **CommonJS 는 조건부로 모듈을 불러올 수 있다.**

```javascript
// dynamic.mjs
const a = false;
if (a) {
    import './func.mjs';
}
console.log('성공');
```
`코드`

```bash
$ node dynamic.mjs
file:///C:/Users/speak/WebstormProjects/nodejs-book/ch3/3.3/dynamic.mjs:3
    import './func.mjs';
           ^^^^^^^^^^^^

SyntaxError: Unexpected string
```
`실행 결과`

하지만 **ES 모듈은 if 문 안에서 import 하는 것이 불가능**하다. 이때 아래와 같이 `다이내믹 임포트`를 사용한다.

```javascript
// dynamic.mjs
const a = true;
if (a) {
    const m1 = await import('./func.mjs');
    console.log(m1);
    const m2 = await import('./var.mjs');
    console.log(m2);
}
```
`코드`

```bash
$ node dynamic.mjs
[Module: null prototype] { default: [Function: checkOddOrEven] }
[Module: null prototype] { even: 'MJS 짝수입니다', odd: 'MJS 홀수입니다' }
```
`실행 결과`

`import` 함수는 `Promise` 를 반환하기에, `await` 이나 `then` 을 붙여야 한다.
또한, `async` 함수 선언없이도 `await` 을 사용한 것을 볼 수 있는데, ES 모듈에서는 최상위 스코프에서 `async` 함수 선언없이 `await` 을 사용할 수 있다.

# Node.js 내장 객체
노드에서는 따로 설치하지 않아도 사용할 수 있는 **기본적인 내장 객체와 내장 모듈을 제공**한다.
- 브라우저의 `window` 객체와 비슷한 것으로 볼 수 있다.

## global 객체
브라우저의 `window` 객체와 같은 `전역 객체` 이며, 따라서 모든 파일에서 접근할 수 있다.
또한, `window.open` 메서드를 `open` 으로 호출 할 수 있는 것처럼, `global` 또한 생략 할 수 있다.
앞서 사용했던 `require` 함수 또한 `global.require` 에서 `global` 이 생략된 것.
- 사실 로그를 출력하기 위한 `console` 객체도 원래는 `global.console` 이다.

`global` 이 **전역 객체**라는 점을 이용해 간단한 데이터를 공유할 때 사용하기도 한다.

```javascript
// globalA.js
module.exports = () => global.message;
```

```javascript
// globalB.js
const A = require('./globalA');

global.message = '안녕하세요';
console.log(A());
```

```bash
$ node globalB
안녕하세요
```
1. `globalA` 모듈이 `export` 하는 함수는 `global.message` 값을 반환.
2. `globalB` 에서는 `global` 객체에 속성명이 `message` 인 값을 대입하고, `globalA` 모듈이 `export` 한 함수를 호출
3. `globalB` 에서 넣은 `global.message` 값을 `globalA` 에서도 접근 할 수 있음.

하지만 `global` 객체 속성에 값을 대입하여 파일 간 데이터를 공유하는 방식은 **어떤 파일에서 `global` 객체에 값을 대입했는지 찾기 힘들어 유지보수에 어려움**을 주므로 남용해서는 좋지 않다.

### global.process
`process` 객체는 **현재 실행되고 있는 노드 프로세스에 대한 정보**를 담고 있다.

#### process.env
**시스템의 환경 변수 정보**를 가지는 객체. 대표적으로 `UV_THREADPOOL_SIZE`,  `NODE_OPTIONS` 가 있다.
- `NODE_OPTIONS:` **노드를 실행할 때의 옵션을 입력**받는 환경 변수.
- `UV_THREADPOOL_SIZE:` **노드에서 기본적으로 사용하는 스레드 풀(libuv의 내부 스레드풀)의 스레드 개수를 조절**

**대표적인 NODE_OPTIONS 옵션 목록**

| 옵션                              | 설명                                                       | 예시                                             |
| ------------------------------- | -------------------------------------------------------- | ---------------------------------------------- |
| `--max-old-space-size`          | V8 힙 메모리 크기 제한(MB 단위). 메모리 부족(`Heap out of memory`) 방지용. | `NODE_OPTIONS="--max-old-space-size=8192"`     |
| `--trace-warnings`              | 경고 발생 시 스택 트레이스 출력                                       | `NODE_OPTIONS="--trace-warnings"`              |
| `--inspect`, `--inspect-brk`    | 디버거 연결용 포트 지정 / 브레이크 모드 시작                               | `NODE_OPTIONS="--inspect=9229"`                |
| `--require`                     | Node 시작 시 특정 모듈 자동 로드                                    | `NODE_OPTIONS="--require dotenv/config"`       |
| `--enable-source-maps`          | 소스맵 지원 활성화 (TypeScript 디버깅용)                             | `NODE_OPTIONS="--enable-source-maps"`          |
| `--trace-deprecation`           | Deprecated 경고가 발생할 때마다 추적 로그 출력                          | `NODE_OPTIONS="--trace-deprecation"`           |
| `--unhandled-rejections=strict` | Promise 미처리 거부를 예외로 처리                                   | `NODE_OPTIONS="--unhandled-rejections=strict"` |
| `--no-warnings`                 | 모든 경고 메시지 비활성화                                           | `NODE_OPTIONS="--no-warnings"`                 |
| `--heapsnapshot-signal`         | 특정 시그널(`SIGUSR2` 등) 수신 시 힙 덤프 생성                         | `NODE_OPTIONS="--heapsnapshot-signal=SIGUSR2"` |
| `--max-http-header-size`        | HTTP 헤더 크기 제한 변경 (기본 8KB)                                | `NODE_OPTIONS="--max-http-header-size=32768"`  |

**UV_THREADPOOL_SIZE 를 사용한 스레드풀 크기 조정 방법**
```bash
# 스레드풀을 8개로 늘림
export UV_THREADPOOL_SIZE=8
node app.js
```
- 기본 크기: **4개** 
- 최대 크기: **128개** (Node 12+ 기준)

`process.env`시스템 환경 변수 외에 아래와 같은 용도로 사용자가 임의로 환경 변수를 저장할 수 있다.
- 서비스의 중요한 키(secret)를 저장
- 개발, 스테이징, 프로덕션 등의 환경 별 변수 제어

```javascript
const secretId = process.env.SECRET_ID;
const secretCode = process.env.SECRET_CODE;
```


#### process.nextTick (call back)
**이벤트 루프**는 다른 콜백 함수들보다 **`nextTick` 의 콜백 함수를 우선으로 처리**하도록 한다.

```javascript
// nextTick.js
setImmediate(() => {
  console.log('immediate');
});
process.nextTick(() => {
  console.log('nextTick');
});
setTimeout(() => {
  console.log('timeout');
}, 0);
Promise.resolve().then(() => console.log('promise'));
```
- `process.nextTick` 은 `setImmediate` 나 `setTimeout` 보다 **먼저 실행**.
- 코드 맨 밑에 `Promise` 를 넣은 것은 **`resolve` 된 `Promise` 도 `nextTick` 처럼 다른 콜백들보다 우선시되기 때문.**
	- 그래서 `process.nextTick` 과 `Promise` 를 **마이크로태스크(microtask)** 라고 따로 구분함.

```bash
$ node nextTick
nextTick
promise
timeout
immediate
```
`실행 결과`

![[Pasted image 20251019023707.png]]
- 하지만 `process.nextTick` 을 남발하게 되면 시스템의 **다른 콜백 함수들보다 우선시되어 실행되기 때문에 다른 콜백 함수들의 실행에 방해**가 될 수 있으니 남용하는 것은 좋지 않다.

## 기타 내장 객체
`fetch` 를 노드에서도 사용할 수 있게 됨에 따라, **브라우저에 존재하던 객체들이 노드에도 동일하게 생성**되었다.
- `URL`, `URLSearchParams`
- `AbortController`, `FormData`, `fetch`, `Headers`, `Request`, `Response`, `Event`, `EventTarget`: 브라우저에서 사용하던 API가 노드에도 동일하게 생성.
- `TextDecoder`: Buffer를 문자열로 바꿉니다.
- `TextEncoder`: 문자열을 Buffer로 바꿉니다.
- `WebAssembly`: 웹어셈블리 처리를 담당합니다.


# Node.js 내장 모듈
## os
노드는 내장 `os` 모듈을 통해 **노드 프로세스가 실행되고 있는 환경의 운영체제 정보**를 가져올 수 있다.
- `require('os')`
- `require('node:os')`

```javascript
// os.js
const os = require('os');

console.log('운영체제 정보---------------------------------');
console.log('os.arch():', os.arch());
console.log('os.platform():', os.platform());
console.log('os.type():', os.type());
console.log('os.uptime():', os.uptime());
console.log('os.hostname():', os.hostname());
console.log('os.release():', os.release());

console.log('경로------------------------------------------');
console.log('os.homedir():', os.homedir());
console.log('os.tmpdir():', os.tmpdir());

console.log('cpu 정보--------------------------------------');
console.log('os.cpus():', os.cpus());
console.log('os.cpus().length:', os.cpus().length);

console.log('메모리 정보-----------------------------------');
console.log('os.freemem():', os.freemem());
console.log('os.totalmem():', os.totalmem());
```

## path
**폴더와 파일의 경로를 쉽게 조작**하도록 도와주는 모듈.

```javascript
// path.js
const path = require('path');

const string = __filename;

console.log('path.sep:', path.sep);
console.log('path.delimiter:', path.delimiter);
console.log('------------------------------');
console.log('path.dirname():', path.dirname(string));
console.log('path.extname():', path.extname(string));
console.log('path.basename():', path.basename(string));
console.log('path.basename - extname:', path.basename(string, path.extname(string)));
console.log('------------------------------');
console.log('path.parse()', path.parse(string));
console.log('path.format():', path.format({
  dir: 'C:\users\carefreelife98',
  name: 'path',
  ext: '.js',
}));
console.log('path.normalize():', path.normalize('C://users\\carefreelife98\\path.js'));
console.log('------------------------------');
console.log('path.isAbsolute(C:\):', path.isAbsolute('C:\'));
console.log('path.isAbsolute(./home):', path.isAbsolute('./home'));
console.log('------------------------------');
console.log('path.relative():', path.relative('C:\users\carefreelife98\path.js', 'C:\'));
console.log('path.join():', path.join(__dirname, '..', '..', '/users', '.', '/carefreelife98'));
console.log('path.resolve():', path.resolve(__dirname, '..', 'users', '.', '/carefreelife98'));
```


## url
**인터넷 주소를 쉽게 조작**하도록 도와주는 모듈

## crypto
**다양한 방식의 암호화**를 도와주는 모듈. 몇 가지 메서드는 익혀두면 실제 서비스에도 적용할 수 있어 유용.
- `crypto` 모듈은 `단방향 해시 암호화`, `양방향 비대칭형 암호화`, `HMAC` 등의 다양한 암호화를 제공

### 단방향 암호화 (해시)
노드에서 해시 함수는 다음과 같이 사용.

```javascript
// hash.js
const crypto = require('crypto');

console.log('base64:', crypto.createHash('sha512').update('비밀번호').digest('base64'));
console.log('hex:', crypto.createHash('sha512').update('비밀번호').digest('hex'));
console.log('base64:', crypto.createHash('sha512').update('다른 비밀번호').digest('base64'));
```

```bash
$ node hash
base64: dvfV6nyLRRt3NxKSlTHOkkEGgqW2HRtfu19Ou/psUXvwlebbXCboxIPmDYOFRIpqav2eUTBFuHaZri5x+usy1g==
hex: 76f7d5ea7c8b451b773712929531ce92410682a5b61d1b5fbb5f4ebbfa6c517bf095e6db5c26e8c483e60d8385448a6a6afd9e513045b87699ae2e71faeb32d6
base64: cx49cjC8ctKtMzwJGBY853itZeb6qxzXGvuUJkbWTGn5VXAFbAwXGEOxU2Qksoj+aM2GWPhc1O7mmkyohXMsQw==
```

![[Pasted image 20251019034345.png]]
- `createHash(알고리즘):` **사용할 해시 알고리즘**을 파라미터로 삽입. `md5, sha1, sha256, sha512` 등이 가능.
- `update(문자열):` **변환할 문자열**을 파라미터로 삽입.
- `digest(인코딩):` **인코딩할 알고리즘**을 파라미터로 삽입.` base64, hex, latin1` 이 주로 사용되며, 그중 base64가 결과 문자열이 가장 짧아서 애용. 결과물로 변환된 문자열을 반환.

`crypto.randomBytes` 와 `crypto.pbkdf2` 메서드와 같이 **내부적으로 스레드 풀을 사용해 멀티 스레딩으로 동작하는 메서드**들도 있다.

### 양방향 암호화
**암호화된 문자열을 복호화할 수 있으며, 키를 사용한다.**
대칭형 암호화에서는 암호를 복호화하려면 암호화할 때 사용한 키와 같은 키를 사용해야 한다.

## worker_threads
**노드에서 멀티 스레드 방식으로 작업하는 방법.**
아래는 간단한 사용 방법이다.

```javascript
// worker_threads.js
const {
  Worker, isMainThread, parentPort,
} = require('worker_threads');

if (isMainThread) { // 부모일 때
  const worker = new Worker(__filename);
  worker.on('message', message => console.log('from worker', message));
  worker.on('exit', () => console.log('worker exit'));
  worker.postMessage('ping');
} else { // 워커일 때
  parentPort.on('message', (value) => {
    console.log('from parent', value);
    parentPort.postMessage('pong');
    parentPort.close();
  });
}
```

```bash
$ node worker_threads
from parent ping
from worker pong
worker exit
```

`isMainThread` 를 통해 **현재 코드가 실행되고 있는 스레드를 구분.**
- 메인 스레드(기존에 동작하던 싱글 스레드를 메인 스레드 또는 부모 스레드라고 함)
- 워커 스레드

**메인 스레드**
- `new Worker` 를 통해 현재 파일(`__filename`)을 **워커 스레드**에서 실행. (현재 파일의 `else` 부분만)
- 워커 스레드 생성 후 `worker.postMessage` 로 **워커에 데이터를 보낼 수 있다.**
- `worker.on('message')` 로 메시지를 수신.

**워커 스레드**
- 워커는 `parentPort.on('message')` 이벤트 리스너로 메인 스레드로부터 메시지를 수신.
- `parentPort.postMessage` 로 메인 스레드에게 메시지를 전달.
- 워커에서 on 메서드를 사용할 때는 `parentPort.close()` 를 사용하여 직접 워커를 종료해야 함.

### 여러 개의 워커 스레드에 데이터를 전송하는 방법
![[Pasted image 20251019035817.png]]
`메인 스레드와 워커의 통신`

```javascript
//worker_data.js

const {
  Worker, isMainThread, parentPort, workerData,
} = require('worker_threads');

if (isMainThread) { // 부모일 때
  const threads = new Set();
  threads.add(new Worker(__filename, {
    workerData: { start: 1 },
  }));
  threads.add(new Worker(__filename, {
    workerData: { start: 2 },
  }));
  for (let worker of threads) {
    worker.on('message', message => console.log('from worker', message));
    worker.on('exit', () => {
      threads.delete(worker);
      if (threads.size === 0) {
        console.log('job done');
      }
    });
  }
} else { // 워커일 때
  const data = workerData;
  parentPort.postMessage(data.start + 100);
}
```

메인 스레드에서 `new Worker` 를 호출할 때 두 번째 인수의 `workerData` 속성으로 **원하는 데이터를 보낼 수 있다.**
- 워커에서는 `workerData` 를 통해 **메인 스레드로부터 데이터를 전달**받음.
- 현재 두 개의 워커가 돌아가고 있으며, 각각 메인 스레드로부터 숫자를 받아서 100을 더해 돌려준다.
	- **돌려주는 순간 워커가 종료**되어 `worker.on('exit')` 이 실행된다.
- 워커 두 개가 모두 종료되면 `job done` 이 로깅된다.

```bash
$ node worker_data
from worker 101
from worker 102
job done
```

## child_process
**노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용**하는 모듈.
- 다른 언어의 코드(파이썬 등)를 실행하고 결괏값을 받을 수 있다.

이름이 `child_process(자식 프로세스)` 인 이유는, **현재 노드 프로세스 외에 새로운 프로세스를 띄워서 명령을 수행하고 노드 프로세스에 수행 결과를 전달하기 때문.**


# 파일 시스템 접근
`fs 모듈` 은 **파일 시스템에 접근**하는 모듈.
- 파일 및 폴더를 생성하거나 삭제하고, 읽거나 쓸 수 있다.

```text
// readme.txt
My name is Carefreelife98
```

```javascript
// readFile.js
const fs = require('fs');

fs.readFile('./readme.txt', (err, data) => {
  if (err) {
    throw err;
  }
  console.log(data);
  console.log(data.toString());
});
```
- `fs` 모듈을 불러온 뒤 읽을 파일의 경로를 지정한다. (파일의 경로는 node 명령어를 실행하는 콘솔 기준)
- 파일을 읽은 후 실행될 콜백 함수도 `fs.readFile()` 메서드의 파라미터로 추가.
	- 콜백 함수의 파라미터는 에러 / 데이터

```bash
$ node readFile
<Buffer ec a0 80 eb a5 bc 20 ec 9d bd ec 96 b4 ec a3 bc ec 84 b8 ec 9a 94 2e>
My name is Carefreelife98
```
- `fs.readFile()` 의 결과물은 버퍼(Buffer) 라는 형식으로 제공됨.

`fs` 는 기본적으로 콜백 형식의 모듈. 실무에서 사용하기 불편하므로 아래와 같이 `Promise` 형식으로 바꿔 사용한다.

```javascript
// readFilePromise.js
const fs = require('fs').promises; // 프로미스 형식으로 변환!

fs.readFile('./readme.txt')
  .then((data) => {
    console.log(data);
    console.log(data.toString());
  })
  .catch((err) => {
    console.error(err);
  });
```

읽기 외에, 파일 쓰기도 가능하다.

```javascript
// writeFile.js
const fs = require('fs');

fs.writeFile('./writeme.txt', '글이 입력됩니다', (err) => {
  if (err) {
    throw err;
  }
  fs.readFile('./writeme.txt', (err, data) => {
    if (err) {
      throw err;
    }
    console.log(data.toString());
  });
});
```

## 동기와 비동기, 블로킹과 논블로킹
`동기와 비동기`, `블로킹과 논블로킹` 이라는 네 개의 용어가 노드에서 혼용되고 있는데, 용어가 서로 다른 만큼 의미상의 차이가 있다.

- `동기와 비동기:` 백그라운드 작업 완료 확인 여부
- `블로킹과 논블로킹:` 함수가 바로 `return` 되는지 여부

노드에서는 **동기-블로킹 방식** 과 **비동기-논블로킹** 방식이 대부분이다. 동기-논블로킹이나 비동기-블로킹은 없다고 봐도 된다.

![[Pasted image 20251019153329.png]]
- `동기-블로킹 방식:` **백그라운드 작업 완료 여부를 계속 확인**하며, 호출한 함수가 바로 return 되지 않고 **백그라운드 작업이 끝나야 return** 한다. 
- `비동기-논블로킹 방식:` **호출한 함수가 바로 return** 되어 다음 작업으로 넘어가고, **백그라운드 작업 완료 여부는 신경 쓰지 않고 나중에 백그라운드가 알림을 줄 때 비로소 처리**한다.

## 버퍼(Buffer)와 스트림(Stream)
파일을 읽거나 쓰는 방식에는 크게 두 가지 방식이 있다.
- 버퍼 (Buffer)
- 스트림 (Stream)

### 버퍼 (Buffer)
![[Pasted image 20251019153951.png]]
노드는 파일을 읽을 때 메모리에 파일 크기만큼의 공간을 미리 마련해둔후, 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 한다.
이때 메모리에 저장된 데이터가 바로 버퍼(Buffer) 이다.

노드에서는 버퍼를 직접 다룰 수 있는 `Buffer` 클래스를 제공한다.

```javascript
// buffer.js
const buffer = Buffer.from('저를 버퍼로 바꿔보세요');
console.log('from():', buffer);
console.log('length:', buffer.length);
console.log('toString():', buffer.toString());

const array = [Buffer.from('띄엄 ' ), Buffer.from('띄엄 ' ), Buffer.from('띄어쓰기')];
const buffer2 = Buffer.concat(array);
console.log('concat():', buffer2.toString());

const buffer3 = Buffer.alloc(5);
console.log('alloc():', buffer3);
```

```bash
$ node buffer
from(): <Buffer ec a0 80 eb a5 bc 20 eb b2 84 ed 8d bc eb a1 9c 20 eb b0 94 ea bf 94 eb b3 b4 ec 84 b8 ec 9a 94>
length: 32
toString(): 저를 버퍼로 바꿔보세요
concat(): 띄엄 띄엄 띄어쓰기
alloc(): <Buffer 00 00 00 00 00>
```
- `Buffer` 객체는 여러가지 메서드를 제공한다.
	- `from(문자열):` 문자열을 버퍼로 변환. length 속성은 버퍼의 크기를 제공. 바이트 단위.
	- `toString(버퍼):` 버퍼를 다시 문자열로 변환. 이때 `base64` 나 `hex` 를 인수로 넣으면 해당 인코딩으로도 변환 가능.
	- `concat(배열):` 배열 안에 든 버퍼들을 하나로 합친다.
	- `alloc(바이트):` 빈 버퍼를 생성. 바이트를 인수로 넣으면 해당 크기의 버퍼가 생성된다.

하지만 **버퍼는 파일 크기만큼의 메모리를 필수적으로 점유해야 한다는 점에서 문제가 발생**한다.
- 만약 **용량이 100MB 인 파일을 버퍼로 사용한다면, 이 작업을 동시에 열 개만 수행해도 약 1GB 의 메모리가 요구**된다.
	- 이는 대규모 트래픽이 발생하는 경우 메모리 부족 문제가 발생할 수 있다.

또한, 모든 데이터를 버퍼에 저장한 후 다음 동작으로 넘어가므로 **파일 읽기, 압축, 쓰기 등의 조작을 연달아 하는 경우 매번 전체 데이터를 버퍼로 처리하고 난 후에야 다음 단계로 넘어갈 수 있게 된다.**
- 따라서 버퍼의 크기를 작게 만들고, 여러번에 걸쳐 나누어 전송하는 `Stream` 방식이 등장.

### 스트림 (Stream)
![[Pasted image 20251019155504.png]]
> 1MB 크기의 버퍼를 만든 후 100MB 파일을 100번에 걸쳐 나누어 보내는 것.

파일을 읽는 스트림 메서드로는 `createReadStream` 이 있다.

```text
// readme3.txt
저는 조금씩 조금씩 나눠서 전달됩니다. 나눠진 조각을 chunk라고 부릅니다.
```
`파일`

```javascript
// createReadStream.js
const fs = require('fs');

// createReadStream으로 읽기 스트림 생성
// 첫 번째 인수: 읽을 파일 경로
// 두 번째 인수: 옵션 객체
// - highWaterMark: 버퍼의 크기(바이트 단위)를 정할 수 있는 옵션. (기본값은 64KB) 여러 번 나눠서 보내는 모습을 보여주기 위해 16B 로 설정.
const readStream = fs.createReadStream('./readme3.txt', { highWaterMark: 16 });
const data = [];

readStream.on('data', (chunk) => {
  data.push(chunk);
  console.log('data :', chunk, chunk.length);
});

readStream.on('end', () => {
  console.log('end :', Buffer.concat(data).toString());
});

readStream.on('error', (err) => {
  console.log('error :', err);
});
```
`코드`

```bash
$ node createReadStream
data : <Buffer ec a0 80 eb 8a 94 20 ec a1 b0 ea b8 88 ec 94 a9> 16
data : <Buffer 20 ec a1 b0 ea b8 88 ec 94 a9 20 eb 82 98 eb 88> 16
data : <Buffer a0 ec 84 9c 20 ec a0 84 eb 8b ac eb 90 a9 eb 8b> 16
data : <Buffer 88 eb 8b a4 2e 20 eb 82 98 eb 88 a0 ec a7 84 20> 16
data : <Buffer ec a1 b0 ea b0 81 ec 9d 84 20 63 68 75 6e 6b eb> 16
data : <Buffer 9d bc ea b3 a0 20 eb b6 80 eb a6 85 eb 8b 88 eb> 16
data : <Buffer 8b a4 2e> 3
end : 저는 조금씩 조금씩 나눠서 전달됩니다. 나눠진 조각을 chunk라고 부릅니다.
```
`실행 결과`

`fs.createWriteStream()` 을 사용해서 파일 쓰기도 가능하다.

```javascript
// createWriteStream.js
const fs = require('fs');

const writeStream = fs.createWriteStream('./writeme2.txt');
writeStream.on('finish', () => {
  console.log('파일 쓰기 완료');
});

writeStream.write('이 글을 씁니다.
');
writeStream.write('한 번 더 씁니다.');
writeStream.end();
```
`createWriteStream 메서드를 활용한 파일 쓰기`


#### 스트림 연결 (pipe)
`createReadStream` 으로 파일을 읽고 그 스트림을 전달받아 `createWriteStream` 으로 파일을 쓸 수도 있다.
이와 같이 스트림을 연결하는 것을 `파이핑 (pipe)` 한다고 하며 아래와 같이 사용할 수 있다.

```javascript
// pipe.js
const fs = require('fs');

const readStream = fs.createReadStream('readme4.txt');
const writeStream = fs.createWriteStream('writeme3.txt');
readStream.pipe(writeStream);
```
`pipe 메서드를 활용한 스트림 연결`

`stream` 모듈의 `pipeline` 메서드를 사용해 여러 개의 파이프를 연결하는 방법도 있다.

```javascript
// pipeline.mjs
import { pipeline } from 'stream/promises';
import zlib from 'zlib';
import fs from 'fs';

await pipeline(
  fs.createReadStream('./readme4.txt'),
  zlib.createGzip(),
  fs.createWriteStream('./readme4.txt.gz'),
);
```
`pipeline 메서드를 활용한 여러개의 파이프 연결`

`pipeline` 메서드를 사용하면 `AbortController` 를 활용하여 원할때 파이프를 중단할 수도 있다.

```javascript
// pipelineAbort.mjs
import { pipeline } from 'stream/promises';
import zlib from 'zlib';
import fs from 'fs';

const ac = new AbortController();
const signal = ac.signal;

setTimeout(() => ac.abort(), 1); // 1ms 뒤에 중단
await pipeline(
  fs.createReadStream('./readme4.txt'),
  zlib.createGzip(),
  fs.createWriteStream('./readme4.txt.gz'),
  { signal },
);
```
`pipeline 과 AbortController 를 활용한 파이프라인 중단`

- `pipeline` 의 마지막 인수로 `{ signal }` 을 추가.
- 원하는 시점에 `ac.abort()` 를 호출하면 **스트림 파이프 라인이 중단**된다.

## 기타 fs 메서드
- `fs.access(경로, 옵션, 콜백):` 
	- **폴더나 파일에 접근할 수 있는지 체크하는 메서드.**
	- 두 번째 인수: 상수
		- `F_OK:` 파일 존재 여부
		- `R_OK:` 읽기 권한 여부
		- `W_OK:` 쓰기 권한 여부
	- 파일/폴더나 권한이 없다면 에러가 발생.
		- 파일/폴더가 없을 때의 에러 코드는 `ENOENT`

- `fs.mkdir(경로, 콜백):`
	- **폴더를 만드는 메서드.**
	- 이미 폴더가 있다면 에러가 발생하므로 먼저 `access` 메서드를 호출해서 확인하는 것이 중요.

- `fs.open(경로, 옵션, 콜백):`
	- **파일의 아이디(fd 변수)를 가져오는 메서드.**
		- 파일이 없다면 파일을 생성한 뒤 그 아이디를 가져온다.
		- 가져온 아이디를 사용해 `fs.read` 또는 `fs.write` 로 읽거나 쓸 수 있다.
		- 두 번째 인수로 어떤 동작을 할 것인지를 설정. 
			- `w`: 쓰기
			- `r`: 읽기
			- `a`: 기존 파일에 추가

- `fs.rename(기존 경로, 새 경로, 콜백):`
	- **파일의 이름을 바꾸는 메서드.**

## 스레드 풀
`fs` 모듈 기반의 파일시스템을 사용한 I/O 작업은 노드의 `libuv` 라이브러리를 통해 내부 스레드 풀을 사용하여 **비동기-논블로킹** 형식으로 여러 작업을 동시에 처리할 수 있다.

이때, **기본적인 스레드 풀의 개수는 4개로 설정되어 있기에 최대 4개의 작업이 묶여 동시에 처리할 수 있게 된다.**
만약 컴퓨팅 리소스 (코어 수) 가 더 적거나 많은 경우에는 `UV_THREADPOOL_SIZE=(코어 수)` 라는 **환경변수 설정을 통해 최대 코어 수에 맞추어 조정하여 사용**할 수 있다.

# 이벤트(Event)
이벤트는 **자바스크립트 런타임 환경(runtime environment)** 에서 제공된다.

|구분|실행 환경|이벤트 제공 주체|이벤트 예시|
|---|---|---|---|
|**브라우저**|V8 + Web API|브라우저의 Web API (DOM, fetch, setTimeout 등)|`click`, `input`, `load`, `timeout`, `fetch` 등|
|**Node.js**|V8 + libuv + Node Core|Node.js의 **EventEmitter**, libuv의 I/O 이벤트 루프|`data`, `end`, `connect`, `close`, `error` 등|
Node.js는 **비동기 I/O 기반의 이벤트 루프(event loop)** 를 중심으로 동작한다.
이 구조는 `libuv`라는 C 라이브러리에서 구현되어 있다.

Node.js의 이벤트 관련 핵심 구성:
1. **libuv** – 실제 OS 레벨에서 파일, 네트워크 등의 I/O 이벤트를 감지하고 큐에 등록
2. **Event Loop** – 큐에 들어온 이벤트를 순차적으로 처리
3. **EventEmitter (JS 계층)** – 개발자가 직접 “이벤트 발생/리스너 등록” 기능을 사용할 수 있도록 제공하는 클래스

즉,

> `EventEmitter` 는 Node.js의 **상위 자바스크립트 인터페이스**로서, 내부적으로는 libuv의 **이벤트 루프와 콜백 큐 시스템**을 사용합니다.

우리는 이 `EventEmitter` 를 통해 커스텀 이벤트를 만들어 사용할 수 있다.

```javascript
// event.js
const EventEmitter = require('events');

const myEvent = new EventEmitter();
myEvent.addListener('event1', () => {
  console.log('이벤트 1');
});
myEvent.on('event2', () => {
  console.log('이벤트 2');
});
myEvent.on('event2', () => {
  console.log('이벤트 2 추가');
});
myEvent.once('event3', () => {
  console.log('이벤트 3');
}); // 한 번만 실행됨

myEvent.emit('event1'); // 이벤트 호출
myEvent.emit('event2'); // 이벤트 호출

myEvent.emit('event3');
myEvent.emit('event3'); // 실행 안 됨

myEvent.on('event4', () => {
  console.log('이벤트 4');
});
myEvent.removeAllListeners('event4');
myEvent.emit('event4'); // 실행 안 됨

const listener = () => {
  console.log('이벤트 5');
};
myEvent.on('event5', listener);
myEvent.removeListener('event5', listener);
myEvent.emit('event5'); // 실행 안 됨

console.log(myEvent.listenerCount('event2'));
```
`코드`

```bash
$ node event
이벤트 1
이벤트 2
이벤트 2 추가
이벤트 3
2
```
`실행 결과`

### EventEmitter 의 내장 메서드
- `on(이벤트명, 콜백):`
	- **이벤트 이름과 이벤트 발생 시의 콜백을 연결. (이벤트 리스닝)**
	- event2 처럼 이벤트 하나에 이벤트 여러 개를 달아줄 수도 있다.
- `addListener(이벤트명, 콜백):`
	- on과 기능이 같다.
- `emit(이벤트명):`
	- **이벤트를 호출하는 메서드.**
	- 이벤트 이름을 인수로 넣으면 미리 등록해뒀던 이벤트 콜백이 실행된다.
- `once(이벤트명, 콜백):`
	- **한 번만 실행되는 이벤트.**
	- `myEvent.emit('event3')` 을 두 번 연속 호출했지만 콜백이 한 번만 실행됨.
- `removeAllListeners(이벤트명):`
	- **이벤트에 연결된 모든 이벤트 리스너를 제거.**
	- event4 가 호출되기 전에 리스너를 제거했으므로 event4의 콜백은 호출되지 않는다.
- `removeListener(이벤트명, 리스너):`
	- **이벤트에 연결된 리스너를 하나씩 제거.**
	- 리스너를 넣어야 함. (필수)
- `off(이벤트명, 콜백):`
	- 노드 10 버전에서 추가된 메서드로, removeListener와 기능이 같다.
- `listenerCount(이벤트명):`
	- **현재 리스너가 몇 개 연결되어 있는지 확인.**

# 예외 처리 (Exception Handling)
노드에서는 예외 처리가 **정말, 매우, 특히** 중요하다.
예외란 보통 **처리하지 못한 에러**를 말한다. 이러한 예외들은 **실행 중인 노드 프로세스를 죽여버릴 수도 있다.**

멀티 스레드 프로그램에서는 스레드 하나가 멈추면 그 일을 다른 스레드가 대신할 수 있다.
하지만, **노드는 메인스레드가 하나 뿐이라 해당 스레드가 죽으면 노드 프로세스가 멈추고 서버로서의 기능을 하지 못하게 된다.**

## try-catch

```javascript
// error1.js

setInterval(() => {
  console.log('시작');
  try {
    throw new Error('서버를 고장내주마!');
  } catch (err) {
    console.error(err);
  }
}, 1000);
```

에러가 발생할 것 같은 부분을 `try-catch` 문으로 감싸고 `catch` 문에서 에러 로깅 및 후처리를 진행하면 된다.

## 노드 내장 모듈 에러

```javascript
// error2.js

const fs = require('fs');

setInterval(() => {
  fs.unlink('./abcdefg.js', (err) => {
    if (err) {
      console.error(err);
    }
  });
}, 1000);
```

**노드 내장 모듈에서 발생하는 에러는 실행중인 프로세스를 멈추게 하지 않는다.**

## 예측인 불가능한 에러 처리 (최후의 수단 - uncaughtException)

```javascript
// error4.js

process.on('uncaughtException', (err) => {
  console.error('예기치 못한 에러', err);
});

setInterval(() => {
  throw new Error('서버를 고장내주마!');
}, 1000);
setTimeout(() => {
  console.log('실행됩니다');
}, 2000);
```
`process 객체에 uncaughtException 이벤트 리스너를 등록`

1. `process` 객체에 `uncaughtException` 이벤트 리스너를 등록.
2. `try-catch` 문에 의해 처리되지 않은 에러가 발생하는 경우 해당 이벤트 리스너를 통해 에러를 처리.
3. 프로세스 유지.

`uncaughtException` 이벤트 리스너로 모든 에러를 처리할 수 있을 것으로 보인다.
하지만 노드 공식 문서에서는 `uncaughtException` 이벤트를 **최후의 수단으로 사용할 것**을 명시하고 있다.

**노드는 `uncaughtException` 이벤트 발생 후 다음 동작이 정상적으로 동작하는 것을 보증하지 않기 때문**이다.

# 요청과 응답 (feat. http 모듈)

![[Pasted image 20251020103129.png]]
`클라이언트 - 서버`

**클라이언트의 요청을 받아 내용을 읽고 그에 따른 처리를 수행하여 응답하는 주체를 서버**라고 한다.
따라서 서버에는 **요청을 받는 부분과 응답을 보내는 부분**이 있어야 한다. **Node.js 에서는 이를 이벤트 방식으로 처리**한다.
**클라이언트로부터 요청이 왔을 때, 어떤 작업을 수행할지 이벤트 리스너를 미리 등록**해두어야 한다.

## 이벤트 리스너를 가진 노드 서버 생성하기
```javascript
// createServer.js
const http = require('http');

http.createServer((req, res) => {
  // 여기에 어떻게 응답할지 적어준다.
});
```
`http 모듈 기반 서버 생성`

http 모듈에는 `createServer` 메서드가 있다. 파라미터로 요청에 대한 콜백 함수를 지정하면, `http` 요청이 들어올 때마다 해당 콜백 함수가 실행된다.
**따라서 이 콜백 함수에 응답을 적으면 된다.**

`createServer` 의 콜백 함수에는 `req(Request)` 와 `res(Response)` 파라미터가 존재한다.
- `req` : **요청 정보**를 담고 있음. `readStream` 형식.
- `res` : **응답 정보**를 담고 있음. `writeStream` 형식.,


```javascript
// server1.js
const http = require('http');

http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
})
  .listen(8080, () => { // 서버 연결
    console.log('8080번 포트에서 서버 대기 중입니다!');
});
```
`서버를 생성하고, 응답을 보내는 부분을 추가한 후 서버와 연결`

`createServer` 메서드에 `listen` 메서드를 사용하여 **클라이언트에 노출시킬 포트 번호**와 **포트 연결 완료 후 실행될 콜백 함수**를 넣는다.
`server1.js` 가 실행되면 **서버는 8080 포트에서 요청을 받을 준비가 된다.**

`res.writeHead` : **Response Header 를 보낸다.**
- `HTTP Code` : 200
- `Response Header` : Content-Type: text/html

`res.write` : **Response Body 를 보낸다.**
- text(html)
- buffer

`res.end` : **응답을 종료. 파라미터가 존재하면 해당 데이터도 클라이언트에 응답한 후 종료.**

![[Pasted image 20251020105537.png]]
`server1.js 동작 과정`

# RESTful API, 그리고 라우팅

> REST는 REpresentational State Transfer의 줄임말로, 서버의 자원을 정의하고 자원에 대한 주소를 지정하는 방법을 가리키는 일종의 약속이다.

주소는 그 의미를 명확히 하기 위해 **명사로 구성**된다.
- `/user` : 사용자 정보 관련 자원 요청 등으로 추측 가능.
- `/post` : 게시글 관련 자원 요청 등으로 추측 가능.

하지만 단순히 명사만으로는 그 의미를 추측하기 어려우므로, 우리는 `Http Method` 를 사용한다.

## HTTP Method
- `GET` : **서버 자원을 가져오고자 할 때 사용.** 요청의 본문(body)에 데이터를 넣지 않는다. 추가적인 데이터를 서버로 보내야 한다면 **쿼리스트링**을 사용한다.
- `POST` : **서버에 자원을 새로 등록하고자 할 때 사용.** 요청의 본문에 새로 등록할 데이터를 보낸다.
- `PUT` : **서버의 특정 자원을 요청에 들어 있는 자원으로 완전 변경하고자 할 때 사용.** 요청의 본문에 치환할 데이터를 넣어 보낸다.
- `PATCH` : **서버 특정 자원의 일부만 수정하고자 할 때 사용.** 요청의 본문에 치환할 데이터를 넣어 보낸다.
- `DELETE` : **서버의 특정 자원을 삭제하고자 할 때 사용.** 요청의 본문에 데이터를 넣지 않는다.
- `OPTIONS` : **요청을 하기 전에 통신 옵션을 설명하기 위해 사용.**

각 주소는 여러개의 `Http Method` 를 가질 수 있다.
- `GET - /user` : 사용자 정보를 가져오기
- `POST - /user` : 새로운 사용자 등록

이렇듯 주소와 `HTTP Method` 만 보고도 요청의 내용을 알아보거나 추측할 수 있다는 것이 REST 의 장점 중 하나이다.
`Node.js` 에서 **RESTful 한 서버**를 생성하는 코드 예시는 아래와 같다.

```javascript
// restServer.js
const http = require('http');
const fs = require('fs').promises;
const path = require('path');

http.createServer(async (req, res) => {
  try {
    console.log(req.method, req.url);
    if (req.method === 'GET') {
      if (req.url === '/') {
        const data = await fs.readFile(path.join(__dirname, 'restFront.html'));
        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
        return res.end(data);
      } else if (req.url === '/about') {
        const data = await fs.readFile(path.join(__dirname, 'about.html'));
        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' })
        return res.end(data);
      }
      // 주소가 /도 /about도 아니면
      try {
        const data = await fs.readFile(path.join(__dirname, req.url));
        return res.end(data);
      } catch (err) {
        // 주소에 해당하는 라우트를 찾지 못했다는 404 Not Found error 발생
      }
    }
    res.writeHead(404);
    return res.end('NOT FOUND');
  } catch (err) {
    console.error(err);
    res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
    res.end(err.message);
  }
})
  .listen(8082, () => {
    console.log('8082번 포트에서 서버 대기 중입니다');
  });
```
- `req.method` : **HTTP Method 구분**
- `req.url` : **요청 주소 구분**

> `return res.end` : return을 붙이지 않는 한 함수가 종료되지 않으므로 명시적으로 함수를 종료해주어야 서버에서의 처리가 완료됨.

# 쿠키 (Cookie) 와 세션 (Session)
## 쿠키 (Cookie)
**서버는 요청에 대한 응답을 할 때 인증 (Authentication) 절차를 거쳐 쿠키 (Cookie) 라는 것을 같이 보낸다.**
쿠키는 **유효 기간**이 있으며, `name=carefreelife98` 과 같이 단순한 `Key-Value` 쌍으로 구성된다.
서버로부터 쿠키를 받은 **브라우저는 쿠키를 저장해두었다가 매 요청시마다 해당 쿠키를 함께 서버로 보내어 인증 처리를 수행**한다.

![[Pasted image 20251020131634.png]]
`클라이언트 - 쿠키 - 서버`

- 쿠키는 **요청의 헤더 (Cookie) 에 담겨 전송**된다.
- **브라우저는 응답의 헤더 (Set-Cookie) 에 따라 쿠키를 저장**한다.

> 즉, 서버는 미리 클라이언트에 요청자를 추정할 만한 정보를 쿠키로 만들어 보내고, 그다음부터는 클라이언트로부터 쿠키를 받아 요청자를 파악합니다.

아래와 같이 간단한 쿠키를 서버에서 만들어 브라우저에 보낼 수 있다.

```javascript
// cookie.js
const http = require('http');

http.createServer((req, res) => {
  console.log(req.url, req.headers.cookie);
  res.writeHead(200, { 'Set-Cookie': 'mycookie=test' });
  res.end('Hello Cookie');
})
  .listen(8083, () => {
    console.log('8083번 포트에서 서버 대기 중입니다!');
  });
```

쿠키 `Key-Value` 쌍으로, **세미콜론을 통해 구분된 문자열 형식으로 존재**한다.
- `name=carefreelife98;year=1998`

`createServer` 메서드의 콜백에서는 아래와 같이 `req` 객체에 담겨 있는 쿠키를 가져올 수 있다.
- `req.headers.cookie`

**응답의 헤더에 쿠키를 기록**해야 하므로 `res.writeHead` 메서드를 사용.
`Set-Cookie` 는 브라우저한테 다음과 같은 값의 **쿠키를 저장하라는 의미**이다.
실제로 **응답을 받은 브라우저는 `mycookie=test` 라는 쿠키를 저장**하게 된다.

### 쿠키 (Cookie) 의 구성요소
- `쿠키명=쿠키값` : 기본적인 쿠키의 값. mycookie=test 또는 name=carefreelife98 과 같이 key=value 쌍으로 설정.
- `Expires=날짜` : 만료 기한. 이 기한이 지나면 쿠키가 제거된다. 기본값은 클라이언트가 종료될 때까지.
- `Max-age=초` : Expires 와 비슷하지만 날짜 대신 초를 입력할 수 있다. 해당 초가 지나면 쿠기가 제거. Expires보다 우선 순위가 높다.
- `Domain=도메인명` : 쿠키가 전송될 도메인을 특정할 수 있다. 기본값은 현재 도메인.
- `Path=URL` : 쿠키가 전송될 URL을 특정할 수 있다. 기본값은 ‘/’이고, 이 경우 모든 URL에서 쿠키를 전송할 수 있다.
- `Secure` : HTTPS일 경우에만 쿠키가 전송된다.
- `HttpOnly` : 설정 시 자바스크립트에서 쿠키에 접근할 수 없다. 쿠키 조작을 방지하기 위해 설정하는 것이 좋다.

## 세션 (Session)
하지만 위와 같이 **쿠키만으로 사용자를 인증하는 방식은 상당히 위험**하다.
브라우저의 `Application` 탭을 통해 **쿠키가 노출**되어 있고, 따라서 **쿠키가 조작될 위험**도 있다.
**이름 같은 민감한 개인정보를 쿠키에 넣어두는 것은 적절하지 못하다.**

아래와 같이 코드를 변경해보자.

```javascript
// session.js
const http = require('http');
const fs = require('fs').promises;
const path = require('path');

const parseCookies = (cookie = '') =>
  cookie
    .split(';')
    .map(v => v.split('='))
    .reduce((acc, [k, v]) => {
      acc[k.trim()] = decodeURIComponent(v);
      return acc;
    }, {});

const session = {};

http.createServer(async (req, res) => {
  const cookies = parseCookies(req.headers.cookie);
  if (req.url.startsWith('/login')) {
    const url = new URL(req.url, 'http://localhost:8085');
    const name = url.searchParams.get('name');
    const expires = new Date();
    expires.setMinutes(expires.getMinutes() + 5);
    const uniqueInt = Date.now();
    session[uniqueInt] = {
      name,
      expires,
    };
    res.writeHead(302, {
      Location: '/',
      'Set-Cookie': `session=${uniqueInt}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`,
    });
    res.end();
  // 세션 쿠키가 존재하고, 만료 기간이 지나지 않았다면
  } else if (cookies.session && session[cookies.session].expires > new Date()) {
    res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
    res.end(`${session[cookies.session].name}님 안녕하세요`);
  } else {
    try {
      const data = await fs.readFile(path.join(__dirname, 'cookie2.html'));
      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
      res.end(data);
    } catch (err) {
      res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
      res.end(err.message);
    }
  }
})
  .listen(8085, () => {
    console.log('8085번 포트에서 서버 대기 중입니다!');
  });
```
`이해를 위해 간단하게 구현한 세션`

쿠키에 이름을 담아서 보내는 대신, `uniqueInt` 라는 **고유 값**을 보냈다.
사용자의 이름과 만료 시간은 `uniqueInt` 하위에 있는 `session` 이라는 객체를 통해 **클라이언트가 아닌 다른 곳에 대신 저장**한다.

**이제 클라이언트에게 전달된 고유 값 (uniqueInt) 을 통해 `cookie.session` 변수에서 사용자 정보를 가져와 사용할 수 있게 되었다.**
이러한 방식이 바로 `세션 (Session)` 이다. **서버에 사용자 정보를 저장하고 클라이언트와는 세션 아이디로만 소통한다.**

# HTTPS 와 HTTP2
`https` 모듈은 웹 서버에 `SSL 암호화` 를 추가한다.
GET이나 POST 요청을 할 때 오가는 **데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없게 한다.**

**검증된 인증 기관에서 발급받은 인증서**가 있다면, 아래와 같이 적용해볼 수 있다.

```javascript
// server1-3.js
const https = require('https');
const fs = require('fs');

https.createServer({
  cert: fs.readFileSync('도메인 인증서 경로'),
  key: fs.readFileSync('도메인 비밀 키 경로'),
  ca: [
    fs.readFileSync('상위 인증서 경로'),
    fs.readFileSync('상위 인증서 경로'),
  ],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
})
  .listen(443, () => {
    console.log('443번 포트에서 서버 대기 중입니다!');
  });
```
`인증서를 구입하여 받은 파일들을 fs.readFileSync 메서드로 읽어서 cert, key, ca 옵션에 알맞게 넣으면 된다.`

노드의 `http2` 모듈은 **SSL 암호화와 더불어 최신 HTTP 프로토콜인 `http/2`를 사용할 수 있게 한다**

![[Pasted image 20251020134352.png]]
`HTTP/1.1과 HTTP/2의 비교`

# Cluster
`cluster` 모듈은 기본적으로 `싱글 프로세스`로 동작하는 노드가 **CPU 코어를 모두 사용할 수 있게 해주는 모듈**이다.
**포트를 공유하는 노드 프로세스를 여러 개** 둘 수도 있어, 요청이 많이 들어오는 경우 **병렬로 실행된 서버의 개수만큼 `로드밸런싱 (load balancing)`을 할 수도 있다.**

예를 들어, 노드 프로세스를 코어가 8개인 컴퓨터 (인스턴스) 에서 실행할 때, 노드는 **보통 그 중 하나의 코어만 사용**한다.
이때, `cluster` 모듈을 활용해 **코어 하나당 노드 프로세스 하나가 돌아가게 할 수 있다. (8 개의 노드 프로세스 생성)**
하지만 **서로 다른 프로세스이기 때문에, 각각의 노드 프로세스 간에 메모리를 공유 할 수 없다는 큰 단점**이 있다.
따라서 (그럴일은 없겠지만) 세션을 메모리에 저장하는 경우 이러한 클러스터링은 문제가 될 수 있다.

```javascript
// cluster.js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;
if (cluster.isMaster) {
  console.log(`마스터 프로세스 아이디: ${process.pid}`);
  // CPU 개수만큼 워커를 생산
  for (let i = 0; i < numCPUs; i += 1) {
    cluster.fork();
  }
  // 워커가 종료되었을 때
  cluster.on('exit', (worker, code, signal) => {
    console.log(`${worker.process.pid}번 워커가 종료되었습니다.`);
    console.log('code', code, 'signal', signal);
  });
} else {
  // 워커들이 포트에서 대기
  http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Cluster!</p>');
  }).listen(8086);

  console.log(`${process.pid}번 워커 실행`);
}
```
`cluster 모듈을 활용한 클러스터링 예시 코드`

`worker_threads` 의 예제와 모양이 비슷하지만, **스레드가 아니라 프로세스 단위이다.**
`cluster`는 **하나의 마스터 프로세스(Master)** 와 여러 개의 **워커 프로세스(Worker)** 로 구성.
- **Master**
    - 실제로는 요청을 직접 처리하지 않음
    - 포트를 열고, 들어온 요청을 적절한 워커에게 라우팅(분배)
    - 워커의 상태를 감시 (죽으면 `exit` 이벤트 발생)
    - 필요 시 자동으로 새 워커를 생성 → **장애 복구(자가 재시작)**
- **Worker**
    - 실제로 클라이언트 요청을 처리하는 프로세스
    - Node.js의 싱글 스레드 이벤트 루프 구조로 동작

![[Pasted image 20251020140537.png]]
`클러스터링`

# 의문점 - 클러스터를 통해 두 개의 노드 프로세스를 띄워 Master-Slave 형태로 장애 대응 시스템을 설계?
> 여러 개의 노드 프로세스를 띄우면 여러 개의 메인 스레드가 생성되고 각 프로세스 간에 메모리는 공유하지 못하지만,
> 노드의 약점인 단일 스레드가 죽어 서버가 다운되는 위험을 줄이기 위해 클러스터를 통해 두 개의 노드 프로세스를 띄워 Master-Slave 형태로 장애 대응 시스템을 설계 할 수는 있는건가?

라는 생각을 잠시 했는데, `cluster` 의 **Master 프로세스 또한 단일 스레드**로 이루어져 있어, **Master 프로세스가 죽으면 결국 전체 클러스터가 다운**된다.
또한, 워커 lifecycle을 세밀히 제어해야 하거나, 워커 간 IPC를 직접 구현하려는 경우가 아니라면 `cluster` 를 통해 이런 장애 대응 체계를 만드는 것보다,
이미 체계적으로 제공되고 있는 **`Pm2` 와 같은 프로세스 매니저**를 사용하는 것이 적절하다고 생각되었다.