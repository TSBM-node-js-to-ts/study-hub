## 목차

[1. React도 모듈화되는데?](#react도-모듈화되는데)

[2. var.js가 왜 객체지?](#varjs가-왜-객체지)

[3. argument란?](#argument란)

[4. Node에서의 this 바인딩은 브라우저와 어떻게 다른가?](#node에서의-this-바인딩은-브라우저와-어떻게-다른가)

[5. require.cache와 require.main](#requirecache와-requiremain)

[6. const dep1 = require('./dep1');가 실행되면 내부적으로 일어나는 일](#const-dep1--requiredep1가-실행되면-내부적으로-일어나는-일)

[7. Promise와 await, then](#promise와-await-then)

[8. setImmediate](#setimmediate)

[9. import()는 Promise를 반환한다?](#import는-promise를-반환한다)

[10. process.nextTick이 왜 가장 먼저 실행될까?](#processnexttick이-왜-가장-먼저-실행될까)

[11. 비동기 작업 처리 예제](#비동기-작업-처리-예제)

[12. 스레드 풀과 libuv](#스레드-풀과-libuv)

[13. 쿠키와 세션 이해하기](#쿠키와-세션-이해하기)

[14. HTTPS, HTTP/2](#https-http2)

[15. 클러스터를 이용한 멀티코어 활용](#클러스터를-이용한-멀티코어-활용)

[16. await을 fs.readFile에 붙이는 이유?](#await을-fsreadfile에-붙이는-이유)

---

## React도 모듈화되는데?

### 스레드 풀 동작 예시

```javascript
const crypto = require('crypto');

const pass = 'pass';
const salt = 'salt';
const start = Date.now();

for (let i = 1; i <= 8; i++) {
  crypto.pbkdf2(pass, salt, 1000000, 128, 'sha512', () => {
    console.log(i + ':', Date.now() - start);
  });
}
```

출력 예:

```
4: 1548
2: 1583
1: 1590
3: 1695
6: 3326
5: 3463
7: 3659
8: 3682
```

처음 4개 작업(1~4)은 약 1.5초 후에 완료되고, 나머지 4개(5~8)는 약 3초 후에 완료됩니다. 이는 스레드 풀이 기본적으로 4개의 스레드만 보유하기 때문입니다.

즉, 기본 스레드 풀 크기(4) 때문에 한 번에 4개씩만 병렬 처리된 거예요.

### 스레드 풀 크기 조정하기

Node.js의 기본 스레드풀 크기는 4개입니다. 하지만 환경 변수로 변경할 수 있어요.

**Windows:**

```bash
set UV_THREADPOOL_SIZE=1
node threadpool.js
```

**macOS / Linux:**

```bash
UV_THREADPOOL_SIZE=1 node threadpool.js
```

결과 비교:

| 설정 | 실행 패턴 |
|------|---------|
| `UV_THREADPOOL_SIZE=1` | 하나씩 순서대로 실행 (직렬 처리) |
| `UV_THREADPOOL_SIZE=4` | 4개씩 동시에 처리 (기본값) |
| `UV_THREADPOOL_SIZE=8` | 8개 전부 동시에 처리 가능 |

### 왜 1~4만 동시에 처리되나?

libuv(노드의 런타임 레벨)가 내부적으로 스레드풀 4개를 유지하기 때문이에요. 즉, 이런 구조입니다:

```
메인 스레드 (JS 실행)
      │
      ├── 스레드 1 ── pbkdf2(1)
      ├── 스레드 2 ── pbkdf2(2)
      ├── 스레드 3 ── pbkdf2(3)
      ├── 스레드 4 ── pbkdf2(4)
      └── (대기열) ── pbkdf2(5~8)
```

4개의 스레드가 모두 바쁘면, 나머지는 대기열에 있다가 스레드가 비면 실행됩니다.

### "싱글 스레드인데 병렬로 된다"는 뜻은?

Node.js의 메인 스레드는 1개라서 JS 코드 자체는 한 줄씩 순차적으로 실행됩니다. 하지만 스레드풀은 백그라운드에서 병렬 작업을 합니다. 그래서 JS 코드가 멈추지 않고 다른 일을 계속할 수 있습니다.

### 실무 적용

| 상황 | 설명 |
|------|------|
| 파일 입출력(fs) | 여러 파일을 동시에 읽을 때 — 스레드풀이 병렬로 처리 |
| 암호화/압축(crypto/zlib) | CPU 계산이 많은 작업 — 스레드풀이 부담 분산 |
| DNS 조회(dns.lookup) | 네트워크 대기 시간 — 스레드풀이 병렬로 처리 |

이 구조 덕분에 Node.js가 싱글 스레드임에도 "논블로킹, 고성능 서버"로 동작할 수 있는 거예요.

### 주의할 점

1. 스레드풀 개수를 너무 크게 하면 오히려 느려집니다. (문맥 전환 비용 증가, CPU 스케줄링 오버헤드)
2. CPU 개수(코어 수)보다 조금 큰 정도로 맞추는 게 일반적입니다. 예: 8코어 → `UV_THREADPOOL_SIZE=8~12`
3. `pbkdf2`처럼 CPU에 부하가 큰 함수는 스레드풀을 너무 크게 잡으면 CPU 100% 포화될 수 있습니다.

---

## 쿠키와 세션 이해하기

### HTTP의 한계

HTTP는 기본적으로 "Stateless(상태를 기억하지 않는)" 프로토콜이에요.

즉:
- 클라이언트가 서버에 "GET /home" 요청을 보냄
- 서버는 HTML을 보내줌
- 그다음 "GET /about" 요청을 보내면, 서버는 "이게 아까 그 사람이었는지, 새 손님인지" 전혀 모름

이게 HTTP의 기본 특성이에요. 매 요청(request)은 독립적이라 "이전 요청의 사용자"를 알 수 없습니다.

### 그럼 로그인은 어떻게 유지되나요?

우리가 로그인하면 한 번 인증만으로 계속 로그인 상태가 유지되죠? 그 비밀이 바로 쿠키(cookie)와 세션(session)입니다.

### 쿠키(Cookie)란?

쿠키는 브라우저에 저장되는 "작은 데이터 조각"이에요.

형식은 단순한 `키=값` 쌍으로 되어 있고, 서버가 브라우저에게 "이거 저장해 둬"라고 알려줍니다.

예:

```
Set-Cookie: user=zerocho; Expires=Wed, 23 Oct 2025 12:00:00 GMT;
```

이걸 브라우저가 저장해두면, 다음 요청부터는 자동으로 서버에 같이 보내요.

```
Cookie: user=zerocho
```

### 서버-브라우저 간 쿠키의 흐름

#### (1) 로그인 요청

```
POST /login HTTP/1.1
```

서버가 로그인 성공 후 응답할 때 이렇게 보냅니다:

```
HTTP/1.1 200 OK
Set-Cookie: sessionId=abc123; Expires=Wed, 23 Oct 2025 12:00:00 GMT;
```

브라우저는 이 응답에서 쿠키를 저장합니다.

#### (2) 다음 요청부터

```
GET /profile HTTP/1.1
Cookie: sessionId=abc123
```

서버는 `sessionId`를 보고 사용자를 식별합니다.

### 쿠키의 보안과 개인 정보

쿠키는 사용자 식별에 쓰이기 때문에 보안상 민감합니다.

- 광고 추적이나 행동 분석에 악용될 수 있음
- 다른 사람이 내 브라우저를 쓰면 내 쿠키로 로그인될 수도 있음
- 그래서 보안상 "쿠키를 주기적으로 삭제"하라고 하는 거예요

### 정리

| 구분 | 설명 |
|------|------|
| **쿠키(Cookie)** | 서버가 클라이언트(브라우저)에 저장시키는 작은 데이터 조각 |
| **저장 위치** | 클라이언트(브라우저) |
| **전송 방향** | 서버 → 클라이언트: `Set-Cookie` 헤더 / 클라이언트 → 서버: `Cookie` 헤더 |
| **목적** | 로그인 상태 유지, 사용자 식별, 설정 기억 등 |
| **형태** | `key=value` 형태 |
| **유효기간** | 서버가 설정 (`Expires` 또는 `Max-Age`) |

---

## HTTPS, HTTP/2

### HTTP의 한계

HTTP(하이퍼텍스트 전송 프로토콜)는 원래 암호화되지 않은 평문 통신이에요.

즉, 클라이언트(브라우저) ↔ 서버 사이의 데이터가 그냥 텍스트로 오가기 때문에 누구나 중간에서 볼 수 있습니다.

예를 들어 로그인할 때:

```
POST /login HTTP/1.1
username=ys&password=1234
```

이런 식으로 전송된다면, 네트워크를 도청하는 사람은 사용자의 아이디·비밀번호를 그대로 볼 수 있죠. 그래서 이걸 해결하려고 나온 게 바로 HTTPS입니다.

### HTTPS란?

**HTTPS = HTTP + SSL/TLS(암호화 계층)**

HTTPS는 클라이언트와 서버 사이에 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security)라는 암호화 계층을 추가합니다.

즉:
- 요청(Request)도 암호화되어 전송되고
- 응답(Response)도 암호화되어 돌아옵니다

이 덕분에:
- 중간자(해커)가 내용을 훔쳐봐도 알아낼 수 없고
- 데이터 변조(위조)도 어렵습니다

그래서 로그인·결제 등 민감한 요청에는 반드시 HTTPS가 필요합니다.

### SSL 인증서란?

HTTPS를 쓸 때는 "이 서버가 진짜 맞는지"를 증명할 인증서(certificate)가 필요합니다. 이 인증서는 공인된 인증 기관(CA, Certificate Authority)에서 발급받아요.

- `key`: 서버의 비밀 키(private key)
- `cert`: 서버의 인증서(public certificate)
- `ca`: 상위 인증서 (인증 기관 체인)

이 세 가지가 합쳐져서 "이 사이트는 진짜 이 도메인의 주인입니다"를 증명합니다.

### Node.js에서 HTTPS 서버 만들기

보통 HTTP 서버는 이렇게 만들죠:

```javascript
const http = require('http');

http.createServer((req, res) => {
  res.writeHead(200);
  res.end('Hello HTTP!');
}).listen(8080);
```

여기에 SSL 암호화(https 모듈)를 적용하면 이렇게 바뀝니다:

```javascript
const https = require('https');
const fs = require('fs');

https.createServer({
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  ca: [
    fs.readFileSync('chain1.pem'),
    fs.readFileSync('chain2.pem')
  ],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end('<h1>Hello HTTPS!</h1>');
})
.listen(443, () => console.log('443번 포트에서 HTTPS 서버 대기 중!'));
```

설명:
- `createServer()` 대신 `https.createServer()` 사용
- 첫 번째 인수: 인증서 옵션 객체 (`key`, `cert`, `ca`)
- 두 번째 인수: 일반적인 요청 처리 콜백
- 포트: HTTPS 기본 포트는 `443`

참고: HTTP는 80번 포트, HTTPS는 443번 포트를 씁니다.

### http/1.1 vs http/2 차이

HTTP/2는 2015년에 등장한 새로운 프로토콜이에요. Node.js에서는 `http2` 모듈로 지원합니다.

기존 HTTP/1.1은 요청당 하나의 연결(TCP connection)을 사용했습니다. 즉, 브라우저가 HTML, CSS, JS, 이미지 등 여러 파일을 한 번에 요청하려면 각 파일마다 새로운 연결을 만들어야 했어요. 비효율적이죠!

#### HTTP/1.1의 한계

```
Client ───req──▶ Server (index.html)
Client ───req──▶ Server (style.css)
Client ───req──▶ Server (main.js)
...
```

파일마다 요청/응답을 새로 시작해야 함 → 네트워크 지연(latency) 증가 → 헤더 중복 전송

#### HTTP/2의 개선점

1. **Multiplexing (멀티플렉싱)**
   하나의 TCP 연결에서 여러 요청을 동시에 보낼 수 있음. 즉, CSS, JS, 이미지 등을 병렬로 전송 가능.

2. **Header Compression (헤더 압축)**
   중복되는 헤더(`User-Agent`, `Accept` 등)을 압축해서 전송량 절감.

3. **Server Push**
   서버가 클라이언트가 아직 요청하지 않은 리소스도 미리 보내줄 수 있음. (예: HTML 응답 시 CSS/JS를 같이 push)

4. **Binary Framing Layer**
   데이터를 텍스트가 아닌 바이너리 프레임으로 전송해 효율 증가.

### Node.js http2 서버 예시

```javascript
const http2 = require('http2');
const fs = require('fs');

http2.createSecureServer({
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  ca: [fs.readFileSync('chain.pem')],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end('<h1>Hello HTTP/2!</h1>');
})
.listen(443, () => console.log('HTTP/2 서버 대기 중'));
```

### 차이점 정리

| 항목 | http | https | http2 |
|------|------|--------|---------|
| 모듈 | `http` | `https` | `http2` |
| 암호화 | 없음 | SSL/TLS | SSL/TLS 필수 |
| 성능 | 기본 | 암호화로 약간 느림 | 훨씬 효율적, 빠름 |
| 포트 | 80 | 443 | 443 |
| Node 메서드 | `createServer()` | `createServer()` | `createSecureServer()` |

### 실제 사용 예 (브라우저 표시)

- HTTP: 자물쇠 모양 없음, "주의 요함" 또는 "Not Secure" 경고 표시
- HTTPS: 자물쇠 모양 표시
- HTTP/2: 내부적으로만 적용 (브라우저 개발자 도구에서 `[h2]`로 표시됨)

---

## 클러스터를 이용한 멀티코어 활용

### Node.js의 기본 한계

Node.js는 기본적으로 싱글 프로세스로 동작하므로, CPU 여러 코어가 있더라도 그중 1개만 사용합니다. 예를 들어 8코어 CPU가 있어도 Node는 1코어만 사용하므로 자원이 낭비됩니다.

### 클러스터 모듈의 역할

클러스터 모듈은 Node.js가 여러 CPU 코어를 활용할 수 있도록 여러 프로세스를 띄워줍니다. 각 워커 프로세스가 같은 포트를 공유하고, OS가 자동으로 요청을 분산합니다.

핵심 아이디어:
- 하나의 서버 코드로 여러 개의 워커(worker) 프로세스를 띄움
- 각 워커가 같은 포트(예: 8086)를 공유
- 요청이 들어올 때 OS 레벨에서 자동으로 요청을 분산(로드 밸런싱)

### 클러스터 코드 예시

```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // 마스터 프로세스: 워커들을 관리
  console.log(`마스터 프로세스 아이디: ${process.pid}`);

  // CPU 개수만큼 워커 생성
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // 워커가 종료되었을 때 실행되는 이벤트
  cluster.on('exit', (worker, code, signal) => {
    console.log(`${worker.process.pid}번 워커 종료`);
    console.log('code', code, 'signal', signal);
  });

} else {
  // 워커 프로세스: 실제 서버 역할
  http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Cluster!</p>');
  }).listen(8086);

  console.log(`${process.pid}번 워커 실행`);
}
```

### 실행 흐름

1. Node 실행 시 `cluster.isMaster`가 true이면 마스터 프로세스로 시작
2. 마스터가 CPU 코어 수(`numCPUs`)만큼 `cluster.fork()` 호출 → 워커 프로세스 생성
3. 각 워커는 else 블록을 실행해서 동일한 포트(8086)에서 서버 시작
4. 요청이 들어오면 OS가 알아서 여러 워커에게 분산

### 실행 결과 예시 (8코어라면)

```
마스터 프로세스 아이디: 1234
5678번 워커 실행
5679번 워커 실행
5680번 워커 실행
5681번 워커 실행
...
```

8개의 워커가 동시에 8086 포트에서 요청 대기합니다.

### 요청이 들어올 때 어떤 일이 일어날까?

예를 들어 클라이언트 요청이 여러 번 들어오면:

| 요청 | 처리한 프로세스(pid) |
|------|------------------|
| 요청 1 | 5678 |
| 요청 2 | 5679 |
| 요청 3 | 5680 |
| 요청 4 | 5681 |

이런 식으로 요청이 워커들에게 나누어집니다. (load balancing)

따라서 CPU 여러 코어를 동시에 활용하게 되어 처리 속도가 개선됩니다.

### 왜 성능이 꼭 N배로 안 오르나?

- Node.js 내부 구조상 완벽 병렬 처리 아님 (I/O가 많으면 차이 적음)
- 워커 간 메모리를 공유하지 않음 → 데이터 복제 필요
- CPU 사용률 분배 및 OS 스케줄링 오버헤드 존재

그래서 "코어 수 = 속도 배수"는 아니지만, 병렬 요청 처리 성능이 확실히 좋아집니다.

### 클러스터의 단점과 해결책

| 문제점 | 설명 | 해결책 |
|-------|------|-------|
| **메모리 공유 불가** | 각 워커는 별도 프로세스이므로 변수/객체 공유 불가능 | Redis 등 외부 스토리지 사용 |
| **세션 관리 문제** | 로그인 세션을 메모리에 저장하면 다른 워커에서 인식 불가 | Redis/Memcached 같은 세션 서버 필요 |
| **복잡성 증가** | 워커 모니터링, 재시작 로직 필요 | PM2 같은 프로세스 매니저로 해결 |

### 실무에서의 사용

실제로는 cluster 모듈을 직접 쓰기보다, PM2 같은 Node 프로세스 매니저가 내부적으로 cluster 기능을 대신 써줍니다.

```bash
pm2 start app.js -i max
```

이 명령어는 CPU 코어 수만큼 자동으로 cluster 실행합니다.

---

## await을 fs.readFile에 붙이는 이유?

Node의 `fs.promises.readFile()`은 Promise를 반환하는 비동기 함수예요.

```javascript
// Promise 기반 함수
fs.readFile('파일경로')
  .then((data) => { ... })
  .catch((err) => { ... });
```

그래서 `await`을 붙이면 파일 읽기가 끝날 때까지 기다렸다가 그 결과(Buffer 또는 문자열)를 `data` 변수에 담습니다.

### 실행 흐름

```javascript
const filePath = path.join(__dirname, 'restFront.html');
const data = await fs.readFile(filePath);
res.end(data);
```

- 경로 결합(`path.join`)은 즉시 문자열 생성
- 파일 읽을 때까지 대기 (비동기) → `await` 필요
- 읽은 결과 전송

`await`은 "파일 읽기 완료를 기다리기 위한 키워드"예요. 경로 결합은 단순한 문자열 연산이라 기다릴 필요가 없습니다.

### 만약 await을 안 붙이면?

```javascript
const data = fs.readFile(path.join(__dirname, 'restFront.html'));
```

이 경우 `data`에는 Promise 객체가 들어옵니다. 즉, 파일 내용이 아니라 "나중에 결과를 줄 약속(Promise)"만 들어있는 상태죠.

`res.end(data)`를 하면 내용이 아니라 `[object Promise]` 같은 이상한 값이 전송될 겁니다.브라우저 자바스크립트의 한계

원래 자바스크립트는 HTML `<script>` 태그로 로드되는 단순 스크립트 언어였어요.

```html
<script src="a.js"></script>
<script src="b.js"></script>
```

이렇게 하면 두 파일이 전역 스코프에서 실행돼요. 즉, `a.js`에서 선언한 변수나 함수가 `b.js`에서도 바로 접근 가능했죠.

서로 간섭하기 쉽고, 충돌도 잦은 구조였습니다. 이 시절엔 모듈 시스템이 없었어요.

### Node.js에서의 모듈화

Node.js는 서버 환경에서 돌아가는 JS 런타임이에요. 그래서 브라우저에 종속되지 않고, 파일 단위로 코드를 독립적으로 실행할 수 있게 하는 모듈 시스템이 필요했죠.

그래서 Node는 자체적으로 CommonJS라는 모듈 시스템을 도입했어요.

```javascript
// math.js
function add(a, b) {
  return a + b;
}
module.exports = { add };

// app.js
const { add } = require('./math');
console.log(add(2, 3)); // 5
```

이렇게 `require`와 `module.exports`를 통해 파일을 독립적으로 분리할 수 있었죠. Node 런타임이 이를 처리합니다.

### React에서의 모듈화는 왜 가능하냐?

좋은 포인트입니다.

리액트는 브라우저에서 직접 실행되는 코드처럼 보이지만, 사실상 번들러(Webpack, Vite, Parcel, Next.js 등)가 개입합니다. 이런 번들러들이 ES Module 문법을 해석해서 하나의 번들 파일로 합쳐주기 때문에 모듈화가 가능한 거예요.

```javascript
// utils.js
export function add(a, b) {
  return a + b;
}

// App.jsx
import { add } from './utils';
console.log(add(2, 3));
```

이건 브라우저가 원래 바로 이해하는 문법이 아니었어요. 하지만 ES6 이후 JS 표준에서 `import/export`가 추가되었고, 현대 브라우저는 이제 이를 직접 지원합니다. 다만 React 프로젝트는 보통 빌드 단계에서 모듈을 합쳐서 최적화하죠.

### 정리

| 환경 | 모듈 시스템 | 문법 | 역할 |
|------|-----------|------|------|
| 옛날 브라우저 | 없음 | `<script>` | 전역 실행 |
| Node.js | CommonJS | `require`, `module.exports` | 파일 단위 모듈 |
| React (Vite/Webpack) | ES Module | `import`, `export` | 번들러가 모듈 합침 |
| 현대 브라우저 | ESM 지원 | `import/export` | 네이티브 지원 가능 |

핵심 정리:
- Node.js의 모듈화: 런타임 차원에서 제공 (CommonJS)
- React의 모듈화: ES Module 문법 + 번들러(빌드 도구) 덕분

---

## var.js가 왜 객체지?

> var.js(혹은 아무 js 파일)은 Node.js에서 "객체처럼 동작하는 모듈 객체"로 감싸져서 실행되기 때문이에요.

즉, Node는 JS 파일을 그냥 실행하지 않고, 자동으로 함수로 감싸서 실행합니다.

### Node.js는 파일을 "그냥 실행"하지 않는다

예를 들어 `var.js` 파일에 이렇게 써 있다고 해봅시다.

```javascript
// var.js
var a = 10;
console.log(a);
```

우리가 보기엔 그냥 전역 코드처럼 보이죠? 하지만 Node 내부에서는 실제로 이렇게 감싸서 실행합니다.

```javascript
(function (exports, require, module, __filename, __dirname) {
  var a = 10;
  console.log(a);
});
```

이걸 모듈 래퍼 함수라고 부릅니다.

### 그래서 var.js가 "객체처럼 동작하는 이유"

이 함수는 실행될 때 `module` 이라는 객체를 전달받아요. 즉, 내부적으로 이런 구조로 실행되는 거예요:

```javascript
// Node 내부 처리 예시
const module = { exports: {} };
(function (exports, require, module, __filename, __dirname) {
  // var.js 내용이 여기 들어감
  var a = 10;
  module.exports = { a };
})(module.exports, require, module, __filename, __dirname);
```

그래서 결국:
- `var.js` 파일은 내부적으로 하나의 함수(클로저)로 감싸지고
- 그 함수는 `module`, `exports`, `require` 같은 객체 인자를 받아서 실행돼요

즉, 파일 자체가 "객체"처럼 관리되는 구조입니다.

### 확인해보기

아래처럼 `console.log(arguments)`를 찍어보면 진짜 감싸져 있다는 걸 볼 수 있습니다.

```javascript
// test.js
console.log(arguments);
```

실행:

```
node test.js
```

출력 (Node 버전에 따라 비슷하게 나옴):

```javascript
[Arguments] {
  '0': {},
  '1': [Function: require],
  '2': Module { ... },
  '3': '/Users/.../test.js',
  '4': '/Users/...'
}
```

즉, Node가 파일을 실행할 때 자동으로 5가지 인자를 넘깁니다.

| 인자 이름 | 설명 |
|---------|------|
| `exports` | `module.exports`의 참조 (내보내기용) |
| `require` | 다른 모듈을 불러오는 함수 |
| `module` | 현재 모듈(파일)을 나타내는 객체 |
| `__filename` | 현재 파일의 절대 경로 |
| `__dirname` | 현재 파일이 속한 디렉토리 절대 경로 |

### 결론

Node.js에서 var.js는 단순한 스크립트가 아니라 내부적으로 `module` 객체에 감싸진 하나의 모듈 인스턴스(객체)입니다.

그래서 파일마다:
- 고유한 `module.exports` 객체를 가지고 있고
- `require()` 하면 그 객체가 반환돼요

한 줄 정리: 파일을 실행할 때 자동으로 함수로 감싸져서, 내부에 `module` 객체가 존재하고, 파일 전체가 "모듈 객체"로 취급됨

---

## argument란?

> argument(인자)는 함수를 호출할 때 전달하는 실제 값이에요.

예를 들어:

```javascript
function add(x, y) {
  return x + y;
}

add(2, 3);
```

여기서:
- `x`, `y`는 parameter(매개변수) — 함수가 받을 "자리 이름"
- `2`, `3`은 argument(인자) — 함수에 실제로 전달된 "값"

### 함수 내부에는 arguments라는 숨겨진 객체가 있다

JS의 모든 함수 안에는 자동으로 만들어지는 유사 배열 객체 `arguments`가 있어요. 이 객체에는 호출 시 전달된 모든 인자값이 순서대로 들어있어요.

```javascript
function show() {
  console.log(arguments);
}

show(10, 20, 30);
```

출력:

```
[Arguments] { '0': 10, '1': 20, '2': 30 }
```

즉, `arguments[0]` → `10`, `arguments[1]` → `20` 이런 식으로 접근 가능하죠.

### 예시로 동작 확인

```javascript
function addAll() {
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }
  return sum;
}

console.log(addAll(1, 2, 3, 4)); // 10
```

위 코드에서 `arguments.length`는 전달된 인자 개수(4개)를 알려줍니다.

### 단, 화살표 함수에는 arguments가 없음

중요 포인트예요.

```javascript
const show = () => {
  console.log(arguments); // ReferenceError
};
show(1, 2, 3);
```

화살표 함수는 자신만의 `arguments`를 갖지 않습니다. 대신 상위 스코프(부모 함수)의 `arguments`를 참조합니다.

그래서 보통 Rest Parameter 문법을 사용해요:

```javascript
const show = (...args) => {
  console.log(args); // [1, 2, 3]
};
show(1, 2, 3);
```

### 요약

| 구분 | 설명 | 예시 |
|------|------|------|
| `parameter` | 함수 선언 시 이름 붙인 변수 | `function add(x, y)` |
| `argument` | 함수 호출 시 전달된 실제 값 | `add(2, 3)` |
| `arguments` | 함수 내부 자동 생성 객체 | `arguments[0] === 2` |
| 화살표 함수 | `arguments` 없음 | 대신 `(...args)` 사용 |

Node.js 문맥에서 다시 연결하면, 아까 봤던 `console.log(arguments)`는 Node.js가 내부에서 함수를 감쌌기 때문에 생긴 `arguments` 객체예요. 즉, `exports`, `require`, `module`, `__filename`, `__dirname` 5가지 값이 들어있던 거라서 그렇게 나왔던 거예요.

---

## Node에서의 this 바인딩은 브라우저와 어떻게 다른가?

### 기본 코드 다시 보기

```javascript
// this.js
console.log(this);
console.log(this === module.exports);
console.log(this === exports);

function whatIsThis() {
  console.log('function', this === exports, this === global);
}
whatIsThis();
```

이걸 실행하면 콘솔에 대략 이런 출력이 나옵니다:

```
{}
true
true
function false true
```

이 결과를 해석하면서 `this` 개념을 완전히 정리해볼게요.

### 먼저 "Node.js의 파일 실행 구조" 이해하기

Node는 각 .js 파일을 함수로 감싸서 실행합니다. 즉, 네 코드가 실제로는 내부적으로 이렇게 감싸집니다:

```javascript
(function (exports, require, module, __filename, __dirname) {
  // 네 코드 전체가 이 안에서 실행됨
})();
```

이 함수가 바로 모듈 래퍼(wrapper function)입니다. 즉, 전역처럼 보여도 사실은 "모듈 함수 내부"예요.

그래서 파일 최상단의 `this`는 그 함수의 this를 가리킵니다.

→ Node에서는 이게 `module.exports` 객체로 초기화됩니다.

### 최상위(this)에서의 결과

```javascript
console.log(this); // {}
console.log(this === module.exports); // true
console.log(this === exports);        // true
```

| 항목 | 설명 |
|------|------|
| `this` | 현재 모듈(파일)의 `exports` 객체 |
| `module.exports` | 모듈이 외부로 내보내는 객체 |
| `exports` | `module.exports`의 별칭 (초기 상태에선 같은 객체) |

즉, Node에서 "파일 최상위 this" = "현재 모듈의 exports 객체"입니다. 그래서 위 세 줄은 전부 true가 나옵니다.

### 함수 내부에서의 결과

```javascript
function whatIsThis() {
  console.log('function', this === exports, this === global);
}
whatIsThis();
```

출력:

```
function false true
```

여기서 중요한 건, 함수 선언식 안에서의 this는 기본적으로 global 객체를 가리킨다는 점입니다.

Node.js에서의 `global`은 브라우저의 `window`와 비슷한 역할을 하는 전역 객체예요.

즉:
- `this === exports` → false (이제 모듈 객체 아님)
- `this === global` → true

### 하지만 함수 형태에 따라 달라진다

**일반 함수 호출:**

```javascript
function test() { console.log(this); }
test(); // global
```

**객체의 메서드로 호출:**

```javascript
const obj = { f() { console.log(this); } };
obj.f(); // obj
```

**화살표 함수:**

```javascript
const arrow = () => console.log(this);
arrow(); // 상위 스코프의 this를 그대로 사용 (lexical this)
```

Node에서는 파일 스코프의 `this`가 `exports`이므로, 화살표 함수 안의 `this`도 `exports`가 됩니다.

### 브라우저와 비교하면?

| 위치 | 브라우저 | Node.js |
|------|---------|---------|
| 전역 스코프 | `this === window` | `this === module.exports` |
| 함수 내부(일반) | `this === window` | `this === global` |
| 화살표 함수 | 상위 스코프 상속 | 상위 스코프 상속 |

### 정리

| 상황 | this가 가리키는 대상 | 비고 |
|------|------------------|------|
| 전역(파일 최상단) | `module.exports` | Node는 모듈 함수로 감싸서 실행 |
| 함수 선언 내부 | `global` | 전역 객체 |
| 객체의 메서드 내부 | 해당 객체 | 호출 주체에 따라 결정 |
| 화살표 함수 | 상위 스코프의 this | lexical binding |

핵심 요약:
- Node.js에서 파일 전체는 함수로 감싸져 실행된다
- 그래서 파일 최상단의 this는 exports 객체를 가리킨다
- 함수 내부에서 this는 기본적으로 global
- 화살표 함수는 상위 스코프의 this를 그대로 사용한다

---

## require.cache와 require.main

### require.cache — "이미 로드된 모듈의 저장소(Cache)"

Node.js에서 `require()`는 단순히 파일을 불러오는 함수가 아닙니다.

내부적으로 한 번 로드한 모듈을 메모리에 저장(cache)해둡니다. 이 캐시를 담고 있는 객체가 바로 `require.cache`입니다.

#### 예시

**a.js**

```javascript
console.log('a 모듈 실행');
module.exports = { name: 'A' };
```

**index.js**

```javascript
require('./a'); // 첫 번째 require
require('./a'); // 두 번째 require

console.log(require.cache);
```

출력:

```
a 모듈 실행
{ '/Users/.../a.js': Module { ... } }
```

→ `"a 모듈 실행"`은 한 번만 찍힙니다. 두 번째 `require('./a')`는 캐시에서 바로 가져오기 때문이에요.

#### 내부 동작 구조

`require()` 호출 시 Node는 아래 과정을 거칩니다:

1. 경로를 해석해 절대 경로 얻기
2. `require.cache`에 이미 로드된 모듈이 있는지 확인
3. 있다면 → 바로 반환
4. 없다면 → 새 `Module` 객체 생성 → 파일 실행 → 결과를 cache에 저장

즉, 캐시가 있기 때문에 성능이 좋아지고 중복 실행이 방지됩니다.

#### 캐시 삭제 (재로딩)

```javascript
delete require.cache[require.resolve('./a')];
require('./a'); // 다시 실행됨
```

`require.resolve('./a')`는 실제 절대 경로(`/Users/.../a.js`)를 반환해요. 그걸 `delete` 하면 캐시에서 제거되어, 다음 `require()` 시 다시 실행됩니다.

#### 요약

| 항목 | 설명 |
|------|------|
| 역할 | 이미 로드된 모듈들을 메모리에 캐싱 |
| 타입 | 객체 (key = 모듈 경로, value = Module 객체) |
| 특징 | 한 번 로드된 모듈은 재사용 |
| 캐시 삭제 | `delete require.cache[require.resolve(path)]` |

### require.main — "프로그램의 진입점(main module)"

Node.js는 실행 시 "어떤 파일이 프로그램의 시작점인가?"를 인식합니다. 이 첫 번째 실행 파일을 main module이라고 부릅니다. 그 정보를 담고 있는 게 `require.main`입니다.

#### 예시

**index.js**

```javascript
console.log(require.main);
console.log(require.main.filename);
```

실행:

```
node index.js
```

출력 예:

```
Module {
  id: '.',
  path: '/Users/.../project',
  exports: {},
  filename: '/Users/.../project/index.js',
  loaded: true,
  ...
}
```

- `require.main`은 `Module` 객체를 반환합니다
- `require.main.filename`은 프로그램의 시작 파일 경로를 반환합니다

#### 응용 — "현재 실행 중인 파일이 메인인지 확인하기"

이건 실무에서도 자주 씁니다:

```javascript
if (require.main === module) {
  console.log('이 파일이 직접 실행된 파일입니다!');
} else {
  console.log('다른 파일에서 import(require)된 파일입니다.');
}
```

- `node index.js`로 실행하면 → true
- `require('./index')`로 불러오면 → false

이 패턴은 흔히 테스트 코드, CLI 스크립트, 유틸 모듈에서 쓰입니다.

#### 요약

| 항목 | `require.cache` | `require.main` |
|------|----------------|----------------|
| 의미 | 로드된 모듈들의 캐시 목록 | 프로그램의 진입점(첫 실행 파일) |
| 타입 | 객체 `{ 경로: Module }` | Module 객체 |
| 역할 | 중복 로딩 방지 | 메인 모듈 확인용 |
| 실무 활용 | 핫리로드, 디버깅, 테스트 | CLI, 유틸 모듈의 직접 실행 체크 |

한 줄 정리:
- require.cache: 모든 로드된 모듈을 저장해두는 객체 (재실행 방지)
- require.main: 현재 프로그램의 "첫 실행 파일(Module)" 정보

---

## const dep1 = require('./dep1');가 실행되면 내부적으로 일어나는 일

### require()는 단순히 "파일 읽기"가 아니다

Node.js는 이 문장을 만나면 내부적으로 모듈 로더(Loader)를 작동시킵니다. 이 모듈 로더는 다음 단계를 수행합니다:

```
1. 경로 해석 → 2. 캐시 확인 → 3. 모듈 객체 생성 → 4. 코드 실행 → 5. export 반환
```

하나씩 뜯어볼게요.

### ① 경로 해석 (Path Resolution)

`require('./dep1')` → Node는 다음 순서로 파일을 찾습니다.

1. `dep1`이 내장 모듈인지 확인 (`fs`, `path`, `http` 등)
2. 상대 경로(`./dep1`)를 절대 경로로 변환
   → 예: `/Users/.../project/dep1.js`
3. `.js`, `.json`, `.node` 확장자를 순서대로 시도해서 파일 존재 여부 확인

결과: Node가 실제 파일을 찾으면 다음 단계로 넘어감.

### ② 캐시 확인 (require.cache)

Node는 모든 로드된 모듈을 `require.cache`에 저장해둡니다.

- 만약 `dep1`이 이미 로드되어 있다면
  → 다시 읽지 않고 캐시된 exports를 바로 반환

즉, 동일 파일이 두 번 실행되지 않습니다.

### ③ 새로운 Module 객체 생성

처음 로드하는 모듈이라면 Node는 내부적으로 이런 객체를 만듭니다:

```javascript
Module {
  id: '/Users/.../dep1.js',
  filename: '/Users/.../dep1.js',
  loaded: false,
  exports: {},
  parent: [호출한 모듈],
  children: [],
  paths: [모듈 탐색 경로들]
}
```

이 객체는 Node의 `Module` 클래스 인스턴스예요.

### ④ 파일 내용 읽기 + 감싸서 실행

Node는 해당 JS 파일을 읽고 자동으로 함수로 감쌉니다.

즉, `dep1.js`가 실제로는 이렇게 감싸져 실행됩니다:

```javascript
(function (exports, require, module, __filename, __dirname) {
  // dep1.js의 실제 코드 내용
})();
```

→ 이 함수 실행 시점에 `exports`, `require`, `module` 객체가 주입됩니다.

이게 바로 "모듈 스코프"가 생기는 이유예요. (전역 변수를 오염시키지 않음!)

### ⑤ 코드 실행

이제 dep1.js 내부의 코드가 실행됩니다.

예를 들어 `dep1.js`가 이렇게 생겼다고 합시다:

```javascript
console.log('dep1 실행됨');
module.exports = { value: 10 };
```

그럼 이 시점에서 콘솔에 `"dep1 실행됨"`이 찍히고, `module.exports` 객체가 `{ value: 10 }`으로 설정됩니다.

Node는 이 `module.exports` 객체를 `require('./dep1')`의 반환값으로 돌려줍니다.

### ⑥ 캐시에 저장하고 반환

실행이 끝나면:

```javascript
require.cache['/Users/.../dep1.js'] = module;
module.loaded = true;
```

그리고 `module.exports`의 내용을 반환합니다:

```javascript
const dep1 = require('./dep1'); // { value: 10 }
```

### 정리 — require() 내부에서 일어나는 일 5단계

| 단계 | 설명 |
|------|------|
| ① 경로 해석 | 파일 확장자, 절대경로 확인 |
| ② 캐시 확인 | `require.cache`에서 이미 로드된 모듈 재사용 |
| ③ Module 객체 생성 | 모듈 인스턴스 준비 (`exports`, `require`, `module`) |
| ④ 코드 실행 | 파일을 함수로 감싸서 실행 |
| ⑤ 반환 및 캐시 | `module.exports`를 반환하고 캐시에 저장 |

### 보너스 — 순환 참조 시 어떻게 되나?

만약 dep1이 다시 `require('./index')` 같은 걸 하면, Node는 캐시에 있는 미완성 모듈 객체를 임시로 반환합니다.

```javascript
// dep1.js
const dep2 = require('./dep2');
console.log(dep2);

// dep2.js
const dep1 = require('./dep1');
console.log(dep1);
```

→ 이런 경우 순환 참조(circular dependency)가 발생하지만, Node는 캐시 덕분에 에러 대신 "부분적으로 로드된 exports"를 반환합니다. 즉, 무한 루프 대신 중간 상태의 객체를 돌려주는 거예요.

한 줄 정리:
- require()는 "파일을 즉시 실행하고, 그 결과인 module.exports를 캐시 후 반환"하는 함수
- 한 번 로드된 모듈은 `require.cache`에 저장되어, 이후 호출 시 재사용된다

---

## Promise와 await, then

### 배경 — 자바스크립트는 싱글 스레드

자바스크립트는 한 번에 한 줄씩 순차적으로 실행해요.

그래서 이런 코드를 실행하면:

```javascript
console.log('A');
setTimeout(() => console.log('B'), 1000);
console.log('C');
```

결과는:

```
A
C
B
```

이렇게 돼요.

왜냐하면 setTimeout()은 "1초 후 실행해!"라고 비동기적으로 예약만 하고, 나머지 코드(`console.log('C')`)를 바로 실행하기 때문이에요. 이런 "나중에 실행될 일"을 다루기 위해 만들어진 게 바로 Promise야.

### Promise란?

"나중에 결과를 약속하는 객체"

지금은 값이 없지만, 나중에(비동기 작업이 끝나면) 값을 주겠다고 약속하는 객체입니다.

#### 기본 구조

```javascript
const promise = new Promise((resolve, reject) => {
  const success = true;

  if (success) resolve('성공!');
  else reject('실패!');
});
```

이 `promise` 객체는 두 가지 상태로 바뀔 수 있어요:

- **fulfilled (성공)** → `resolve(결과값)`
- **rejected (실패)** → `reject(에러)`

#### 결과 꺼내기 (then / catch)

Promise의 결과를 처리하려면 then 또는 catch를 붙여야 해요.

```javascript
promise
  .then((result) => {
    console.log('결과:', result);
  })
  .catch((error) => {
    console.error('에러:', error);
  });
```

#### 예시

```javascript
const p = new Promise((resolve) => {
  setTimeout(() => resolve('3초 후 완료'), 3000);
});

console.log('시작');
p.then((msg) => console.log(msg));
console.log('끝');
```

출력:

```
시작
끝
3초 후 완료
```

`.then()`은 그 결과가 도착했을 때 실행할 콜백을 등록합니다.

### await — Promise를 동기처럼 기다리는 문법

`await`은 Promise의 결과를 기다리는 문법입니다. `.then()`을 더 간결하게 표현할 수 있습니다.

```javascript
function waitThreeSeconds() {
  return new Promise((resolve) => {
    setTimeout(() => resolve('3초 후 완료'), 3000);
  });
}

async function run() {
  console.log('시작');
  const result = await waitThreeSeconds();
  console.log(result);
  console.log('끝');
}

run();
```

출력:

```
시작
3초 후 완료
끝
```

`await`을 쓰면 비동기 코드를 순서대로 작성할 수 있습니다. 단, `await`은 반드시 `async` 함수 안에서만 사용 가능합니다.

### then vs await 비교

| 구분 | then | await |
|------|------|-------|
| 문법 | 함수 체인 | 동기식처럼 보이는 문법 |
| 에러 처리 | `.catch()` | `try...catch` |
| 위치 | 어디든 가능 | async 함수 안에서만 |
| 반환값 | 새로운 Promise | Promise의 실제 값 |

#### then 방식

```javascript
getUser()
  .then((user) => getPosts(user.id))
  .then((posts) => console.log(posts))
  .catch(console.error);
```

#### await 방식

```javascript
async function main() {
  try {
    const user = await getUser();
    const posts = await getPosts(user.id);
    console.log(posts);
  } catch (err) {
    console.error(err);
  }
}
```

`await`이 훨씬 가독성 좋고, 동기 코드처럼 보이죠.

### Promise의 상태

| 상태 | 설명 |
|------|------|
| **pending** | 아직 결과가 결정되지 않음 |
| **fulfilled** | 성공적으로 완료되어 resolve 호출됨 |
| **rejected** | 실패하여 reject 호출됨 |

```javascript
const p = new Promise((resolve, reject) => {
  setTimeout(() => resolve(42), 1000);
});

console.log(p); // Promise { <pending> }

setTimeout(() => console.log(p), 2000);
// Promise { 42 }
```

### 핵심 요약

| 개념 | 역할 |
|------|------|
| **Promise** | 비동기 작업의 결과를 나타냄 |
| **then** | 성공 시 실행할 콜백 등록 |
| **await** | Promise의 결과를 기다림 |

---

## setImmediate

### 핵심 요약

setImmediate()는 "즉시 실행"이라는 이름과 달리, "지금 바로" 실행되는 게 아니에요. 이벤트 루프의 다음 사이클(check phase)에 실행돼요.

즉, `clearImmediate()`가 같은 tick 안에서 먼저 실행되면, 해당 콜백은 큐에 들어가기도 전에 제거돼서 결국 실행되지 않습니다.

### 이벤트 루프에서 일어나는 실제 순서

Node.js의 이벤트 루프는 아래 단계로 돌아가요:

1. **timers phase** (setTimeout, setInterval 등 실행)
2. **I/O callbacks phase**
3. **poll phase** (파일 읽기 등 I/O 대기)
4. **check phase** (setImmediate 실행)
5. **close callbacks phase**

### 네 코드에서 일어난 일

```javascript
const immediate2 = setImmediate(() => {
  console.log('실행되지 않습니다');
});

clearImmediate(immediate2);
```

여기서는 이렇게 진행돼요:

1. **`setImmediate()`** 호출 → Node가 "check phase에서 이 콜백을 실행해야겠다" 하고 큐에 등록함. (하지만 아직 실행되지 않음)
2. **바로 이어서 `clearImmediate()` 호출** → 등록된 `immediate2`를 큐에서 제거함
3. 다음 이벤트 루프 사이클에서 check phase 도달 → 실행할 콜백이 없음 (이미 clear됨) → 실행 안 됨

### 쉽게 말하면

`setImmediate()`는 "이벤트 루프 한 바퀴 돈 후 실행"이고, `clearImmediate()`는 "그 전에 지워버리는 명령"입니다.

그래서 "즉시 실행"처럼 보이지만 사실은 "조금 뒤에 실행될 것"을 예약하는 거예요.

#### 예시로 비교해볼까?

**실행되지 않는 경우:**

```javascript
const immediate2 = setImmediate(() => console.log('X'));
clearImmediate(immediate2);
```

→ `clearImmediate()`가 같은 tick 안에서 실행돼서 "X" 출력 안 됨

**실행되는 경우:**

```javascript
setImmediate(() => console.log('Y'));
```

→ check phase에서 "Y" 출력

**실행되는 경우 2:**

```javascript
const immediate2 = setImmediate(() => console.log('Z'));
setTimeout(() => clearImmediate(immediate2), 0);
```

→ "Z" 출력 (왜냐하면 clear는 너무 늦게 실행됨)

### 정리

| 함수 | 실행 타이밍 | clear 가능 여부 |
|------|-----------|-----------------|
| `setTimeout(fn, 0)` | 다음 이벤트 루프의 **timers phase** | 가능 |
| `setImmediate(fn)` | 다음 이벤트 루프의 **check phase** | 가능 |
| `clearImmediate()` | check phase 전에 호출되면 콜백 제거됨 | ✔ |

### 결론

setImmediate()는 "즉시 실행"이 아니라 "이벤트 루프 한 바퀴 후(check phase) 실행" 예약이고, `clearImmediate()`가 그 전에 실행되면 콜백은 큐에서 제거되어 절대 실행되지 않습니다.

이 코드:

```javascript
const immediate2 = setImmediate(() => {
  console.log('실행되지 않습니다');
});
console.log('뭐가먼저일까나');
```

의 실행 결과는 다음과 같아요:

```
뭐가먼저일까나
실행되지 않습니다
```

`console.log('뭐가먼저일까나')`가 먼저 실행되고, 그 다음 이벤트 루프 사이클에서 `setImmediate` 콜백이 실행돼요.

#### 왜 그런가?

setImmediate()의 실행 시점은 "이벤트 루프 한 바퀴를 돈 뒤(check phase)"에 실행되는 함수예요. 이름 때문에 "즉시 실행"처럼 보이지만, 사실은 그렇지 않습니다.

Node.js의 이벤트 루프 순서:

| 순서 | Phase 이름 | 실행되는 콜백 |
|-----|-----------|-------------|
| 1 | **timers** | `setTimeout`, `setInterval` |
| 2 | **I/O callbacks** | 비동기 I/O 관련 콜백 |
| 3 | **poll** | 새 이벤트 기다리는 구간 |
| 4 | **check** | `setImmediate` 실행 |
| 5 | **close callbacks** | 닫기 이벤트 등 |

#### 지금 코드의 실행 순서

```javascript
// 1. setImmediate 등록 → check phase에 예약됨
const immediate2 = setImmediate(() => {
  console.log('실행되지 않습니다');
});

// 2. 지금은 동기 코드. 즉시 실행됨.
console.log('뭐가먼저일까나');
```

1. JS 엔진은 먼저 `setImmediate` 콜백을 등록만 하고, 아직 실행은 안 함
2. 그다음 바로 아래의 `console.log('뭐가먼저일까나')`는 동기 코드이므로 즉시 실행
3. 이벤트 루프가 한 바퀴 돈 후, check phase 도달 → 그때 `setImmediate` 콜백 실행

---

## import()는 Promise를 반환한다?

### 예제 코드 먼저 보기

**var.js**

```javascript
const odd = 'CJS 홀수입니다';
const even = 'CJS 짝수입니다';

export default {
  odd,
  even,
};
```

`export default` 사용 → ESM 모듈임. 이 모듈을 `import('./var.js')`하면 Promise가 resolve될 때 "모듈 네임스페이스 객체"가 반환됩니다. 즉, 단순히 객체가 아니라 "특수한 모듈 래퍼"예요.

**func.js**

```javascript
const { odd, even } = await import('./var.js');

function checkOddOrEven(num) {
  if (num % 2) return odd;
  return even;
}

export default checkOddOrEven;
```

여기도 ESM. `await import()`를 사용해서 `var.js`를 동적으로 불러옵니다.

**dynamic.js**

```javascript
const a = true;

if (a) {
  const m1 = await import('./func.js');
  console.log(m1);
  const m2 = await import('./var.js');
  console.log(m2);
}
console.log('s');
```

여기서 핵심은 이 부분:

```javascript
const m1 = await import('./func.js');
```

### ESM의 import()는 항상 Promise<ModuleNamespaceObject>를 반환함

`import()`로 가져오면 단순히 export된 값이 아니라 "모듈 네임스페이스 객체"가 반환됩니다. 이 객체는 "읽기 전용 export 모음"이며, 모든 export를 `m.default`, `m.someExport` 식으로 접근해야 합니다.

#### 실제 반환 형태

```javascript
const m1 = await import('./func.js');
console.log(m1);
```

결과:

```
[Module: null prototype] { default: [Function: checkOddOrEven] }
```

- `m1`은 일반 JS 객체가 아니라 "ES 모듈 네임스페이스 객체"
- default export는 `m1.default`로 접근해야 함

```javascript
console.log(m1.default(3)); // "CJS 홀수입니다"
```

#### 두 번째 import 예시

```javascript
const m2 = await import('./var.js');
console.log(m2);
```

결과:

```
[Module: null prototype] {
  default: { odd: 'CJS 홀수입니다', even: 'CJS 짝수입니다' }
}
```

- `m2.default`가 실제 export된 객체
- `m2.default.odd`로 접근하면 값을 얻을 수 있음

#### 정리

| 코드 | 실제 값 |
|------|--------|
| `m1` | `{ default: [Function: checkOddOrEven] }` |
| `m1.default` | `checkOddOrEven(num)` |
| `m2` | `{ default: { odd: 'CJS 홀수입니다', even: 'CJS 짝수입니다' } }` |
| `m2.default` | `{ odd: 'CJS 홀수입니다', even: 'CJS 짝수입니다' }` |

---

## process.nextTick이 왜 가장 먼저 실행될까?

### 동기 코드부터 비동기 코드까지의 흐름

"동기 코드 → 비동기 코드 예약 → 이벤트 루프 실행"순서로 돌아가요.

Node.js는 이벤트 루프를 기반으로 비동기 작업을 순서대로 처리합니다.

아래 4줄은 동기적으로 실행됩니다. 그 안에 넘긴 콜백 함수가 나중에 비동기적으로 실행되는 거예요.

```javascript
setImmediate(() => {
  console.log('immediate');
});
process.nextTick(() => {
  console.log('nextTick');
});
setTimeout(() => {
  console.log('timeout');
}, 0);
Promise.resolve().then(() => console.log('promise'));
```

1. setImmediate 등록 (동기)
2. process.nextTick 등록 (동기)
3. setTimeout 등록 (동기)
4. Promise.then 등록 (동기)

이제 동기 코드가 끝났으니, 이벤트 루프가 시작됩니다:

5. nextTick 큐 처리
6. Promise microtask 처리
7. timer 큐 처리 (setTimeout)
8. check 단계 (setImmediate)

### 두 가지 종류의 "작업 큐(queue)"

이벤트 루프는 크게 두 가지 종류의 작업 큐를 다룹니다.

| 큐 종류 | 예시 함수 | 실행 시점 | 특징 |
|--------|----------|---------|------|
| **태스크 큐 (Task Queue)** | `setTimeout`, `setInterval`, `setImmediate` | 각 이벤트 루프 단계마다 실행 | 일반적인 비동기 작업 |
| **마이크로태스크 큐 (Microtask Queue)** | `process.nextTick`, `Promise.then` | 각 단계가 끝난 직후, 즉시 실행 | 매우 우선순위 높음 |

Node.js는 다음 순서로 코드를 처리합니다.

#### (1) 동기 코드 먼저 실행

```javascript
setImmediate(...)
process.nextTick(...)
setTimeout(...)
Promise.resolve().then(...)
```

이들은 모두 "비동기 예약"만 하고, 즉시 실행은 되지 않습니다.

#### (2) 마이크로태스크 (microtask) 먼저 실행

Node는 이벤트 루프의 각 단계가 끝날 때마다, 마이크로태스크 큐에 있는 작업을 전부 처리한 후 다음 단계로 넘어갑니다.

- `process.nextTick()` → Node.js가 가장 먼저 처리 (특수 케이스)
- `Promise.then()` → 그 다음

결과:

```
nextTick
promise
```

#### (3) 태스크 큐 (task) 실행

이제 이벤트 루프의 다음 단계로 넘어가서 태스크를 처리합니다.

**① `setTimeout(..., 0)`**

타이머 단계에서 실행됩니다.

**② `setImmediate(...)`**

check 단계에서 실행됩니다. 타이머보다 한 루프 뒤에 실행되는 경우가 많아요.

결과적으로 다음 순서:

```
timeout
immediate
```

### 핵심 정리

Node.js는 이벤트 루프의 각 단계가 끝날 때마다, 마이크로태스크 큐에 있는 작업을 전부 처리한 후 다음 단계로 넘어갑니다.

1. 동기 코드 먼저 실행 (4개 콜백 등록)
2. 마이크로태스크 큐 처리 (process.nextTick, Promise.then)
3. 이벤트 루프의 timers 단계 (setTimeout)
4. 이벤트 루프의 check 단계 (setImmediate)

최종 실행 순서:

```
nextTick
promise
timeout
immediate
```

`process.nextTick()`은 Node.js가 가장 먼저 처리하는 마이크로태스크입니다.

### 마이크로태스크 재귀 호출 주의

이 부분이 중요한데요.

"마이크로태스크를 재귀 호출하게 되면 이벤트 루프는 다른 콜백 함수보다 마이크로태스크를 우선해 처리하므로 콜백 함수들이 실행되지 않을 수도 있습니다."

예를 들어 이런 코드가 있으면:

```javascript
function recursive() {
  process.nextTick(recursive);
}
recursive();
```

이건 이벤트 루프가 다음 단계로 절대 못 넘어갑니다. nextTick 큐가 계속 차서, `setTimeout`이나 `setImmediate` 같은 다른 비동기 콜백은 영원히 실행되지 않아요.

그래서 `process.nextTick`을 남용하면 프로그램이 멈춘 것처럼 보일 수 있습니다.

### 핵심 정리

1. Node.js는 마이크로태스크(microtask)를 태스크(task)보다 항상 먼저 처리합니다
2. `process.nextTick` → `Promise.then` → `setTimeout` → `setImmediate` 순으로 실행됩니다
3. `nextTick`은 너무 강력해서 재귀 호출 시 이벤트 루프를 막을 위험이 있습니다

---

## 비동기 작업 처리 예제

### 비동기 읽기

비동기 메서드들은 요청만 계속하고 다음 작업으로 넘어갑니다. 따라서 파일 읽기 요청만 세 번을 보냅니다.

```javascript
const fs = require('fs');

console.log('시작');
fs.readFile('./readme.txt', (err, data) => {
  if (err) {
    throw err;
  }
  console.log('1번', data.toString());
});
fs.readFile('./readme.txt', (err, data) => {
  if (err) {
    throw err;
  }
  console.log('2번', data.toString());
});
fs.readFile('./readme.txt', (err, data) => {
  if (err) {
    throw err;
  }
  console.log('3번', data.toString());
});
console.log('끝');
```

출력 예:

```
시작
끝
2번 저를 여러 번 읽어보세요.
3번 저를 여러 번 읽어보세요.
1번 저를 여러 번 읽어보세요.
```

백그라운드에서는 요청 세 개를 거의 동시에 실행합니다.

비동기 메서드들은 백그라운드에 해당 파일을 읽으라고만 요청하고 다음 작업으로 넘어갑니다. 따라서 파일 읽기 요청만 세 번을 보내고 `console.log('끝')`을 찍습니다. 나중에 읽기가 완료되면 백그라운드가 다시 메인 스레드에 알립니다. 메인 스레드는 그제서야 등록된 콜백 함수를 실행합니다.

### 동기 읽기

순서대로 출력하고 싶다면 동기 방식을 사용해야 합니다:

```javascript
const fs = require('fs');

console.log('시작');
let data = fs.readFileSync('./readme2.txt');
console.log('1번', data.toString());
data = fs.readFileSync('./readme2.txt');
console.log('2번', data.toString());
data = fs.readFileSync('./readme2.txt');
console.log('3번', data.toString());
console.log('끝');
```

---

## 스레드 풀과 libuv

### Node.js의 기본 한계: 싱글 프로세스 구조

Node.js는 기본적으로 싱글 스레드, 싱글 프로세스로 동작합니다. 즉, 서버를 하나 띄우면 CPU 코어 여러 개가 있더라도 그중 1개만 사용합니다. 예를 들어 8코어 CPU가 있어도, Node는 그중 1코어만 쓰는 거예요.

그래서 멀티코어 서버 환경에서는 자원이 낭비됩니다.

### Node.js의 멀티스레드 구조

Node.js는 자바스크립트 엔진이 싱글 스레드로 동작하지만, 백그라운드에서는 여러 스레드가 동시에 일합니다. 이 백그라운드 스레드들을 관리하는 것이 libuv의 스레드 풀입니다.

| 구성 요소 | 설명 |
|---------|------|
| 메인 스레드 | 자바스크립트 코드 실행, 콜백 처리 |
| 스레드 풀 | 오래 걸리는 I/O나 CPU 작업을 비동기로 수행 |

메인 스레드는 1개이지만, 스레드 풀은 기본적으로 4개의 스레드를 유지합니다.

### 스레드 풀이 처리하는 작업

다음 작업들은 Node.js가 스레드 풀을 사용하여 병렬 처리합니다:

- `fs` 모듈의 비동기 메서드 (readFile, writeFile 등)
- `crypto` (해싱, 난수 생성 등)
- `zlib` (압축/해제)
- `dns.lookup`
