# Node.js 학습 정리

## 목차
- [JavaScript 모듈 시스템](#javascript-모듈-시스템)
- [Node.js 파일 실행 구조](#nodejs-파일-실행-구조)
- [this 바인딩과 arguments](#this-바인딩과-arguments)
- [require 내부 동작](#require-내부-동작)
- [Promise와 비동기](#promise와-비동기)
- [이벤트 루프](#이벤트-루프)
- [비동기 작업 실전](#비동기-작업-실전)
- [HTTP와 웹 보안](#http와-웹-보안)
- [서버 성능 최적화](#서버-성능-최적화)

---

## JavaScript 모듈 시스템

### React도 모듈화되는데?

원래 브라우저 자바스크립트는 `<script>` 태그로 여러 파일을 로드하면 모두 전역 스코프에서 실행됩니다. 이는 변수와 함수 충돌이 발생하기 쉬운 구조였습니다.

Node.js는 서버 환경에서 필요한 모듈 시스템을 제공합니다. `require()`와 `module.exports`를 통해 파일을 독립적으로 분리하며, Node는 런타임 단계에서 이를 처리합니다.

React는 어떻게 모듈화될까요? React는 번들러(Webpack, Vite, Parcel, Next.js)를 통해 ES Module 문법(`import/export`)을 처리합니다. 번들러가 빌드 단계에서 모듈을 합쳐주기 때문에 모듈화가 가능한 것입니다.

| 환경 | 모듈 시스템 | 처리 주체 |
|------|-----------|---------|
| Node.js | CommonJS | 런타임 |
| React | ES Module | 번들러 |
| 브라우저 | ES Module | 네이티브 지원 |

---

## Node.js 파일 실행 구조

### var.js가 왜 객체지?

Node.js는 각 .js 파일을 그냥 실행하지 않습니다. 내부적으로 함수로 감싸서 실행합니다.

```javascript
(function (exports, require, module, __filename, __dirname) {
  // 파일의 실제 코드
});
```

이렇게 감싸는 이유는 전역 스코프의 오염을 방지하고, 각 파일에 독립적인 스코프를 제공하기 위함입니다. 이 함수는 5개의 인자를 받습니다

| 인자 | 설명 |
|------|------|
| exports | module.exports의 참조 |
| require | 다른 모듈을 불러오는 함수 |
| module | 현재 모듈을 나타내는 객체 |
| __filename | 현재 파일의 절대 경로 |
| __dirname | 현재 디렉토리의 절대 경로 |

각 파일은 고유한 `module.exports` 객체를 가지고 있으므로, 파일 자체가 "객체처럼 관리"되는 모듈 인스턴스가 되는 것입니다.

### arguments란?

모든 함수에는 자동으로 생성되는 `arguments` 객체가 있습니다. 함수에 전달된 모든 인자를 순서대로 담는 유사 배열입니다.

```javascript
function show() {
  console.log(arguments);
}
show(10, 20, 30);
// [Arguments] { '0': 10, '1': 20, '2': 30 }
```

화살표 함수는 자신만의 `arguments`를 갖지 않으므로 상위 스코프의 `arguments`를 참조합니다. 대신 rest parameter 문법(`...args`)을 사용하면 됩니다.

```javascript
const show = (...args) => {
  console.log(args); // [1, 2, 3]
};
show(1, 2, 3);
```

| 구분 | 설명 | 예시 |
|------|------|------|
| parameter | 함수 선언 시 이름 붙인 변수 | function add(x, y) |
| argument | 함수 호출 시 전달된 실제 값 | add(2, 3) |
| arguments | 함수 내부 자동 생성 객체 | arguments[0] === 2 |
| 화살표 함수 | arguments 없음 | 대신 (...args) 사용 |

---

## this 바인딩과 arguments

### Node에서의 this 바인딩은 브라우저와 어떻게 다른가?

파일 최상단에서 `this`는 `module.exports`를 가리킵니다.

```javascript
console.log(this);
console.log(this === module.exports); // true
console.log(this === exports);        // true
```

이는 파일이 모듈 함수로 감싸져 실행되기 때문입니다. Node는 각 .js 파일을 함수로 감싸서 실행합니다

```javascript
(function (exports, require, module, __filename, __dirname) {
  // 파일 최상단의 this는 이 함수의 this
  // Node에서는 이게 module.exports 객체로 초기화됨
})();
```

그러나 함수 선언식 내부에서 `this`는 다릅니다.

```javascript
function whatIsThis() {
  console.log(this === global); // true
}
whatIsThis();
```

브라우저에서는 함수 내부의 `this`가 `window`를 가리키지만, Node.js에서는 `global`을 가리킵니다. 화살표 함수는 상위 스코프의 `this`를 상속받으므로, 파일 스코프의 `this`가 `exports`라면 화살표 함수 안의 `this`도 `exports`가 됩니다.

| 위치 | 브라우저 | Node.js |
|------|---------|--------|
| 전역 스코프 | this === window | this === module.exports |
| 함수 내부(일반) | this === window | this === global |
| 화살표 함수 | 상위 스코프 상속 | 상위 스코프 상속 |

---

## require 내부 동작

### require.cache와 require.main은 뭐지?

`require.cache`는 이미 로드된 모듈들을 저장해두는 객체입니다. 한 번 로드한 모듈은 메모리에 저장되므로, 동일 파일의 재요청 시 캐시에서 바로 가져옵니다. 이는 중복 실행을 방지하고 성능을 향상시킵니다.

```javascript
require('./a'); // 첫 번째 require - "a 모듈 실행" 출력
require('./a'); // 두 번째 require - 캐시에서 가져옴, 실행 안 됨
```

`require()` 호출 시 Node는 다음 과정을 거칩니다

1. 경로를 해석해 절대 경로 얻기
2. `require.cache`에 이미 로드된 모듈이 있는지 확인
3. 있다면 → 바로 반환
4. 없다면 → 새 `Module` 객체 생성 → 파일 실행 → 결과를 cache에 저장

캐시를 수동으로 삭제하면 모듈을 재로드할 수 있습니다

```javascript
delete require.cache[require.resolve('./a')];
require('./a'); // 다시 실행됨
```

`require.main`은 프로그램의 진입점(main module)을 나타냅니다. 현재 실행 중인 파일이 메인인지 확인할 수 있습니다.

```javascript
if (require.main === module) {
  console.log('이 파일이 직접 실행된 파일입니다!');
} else {
  console.log('다른 파일에서 import(require)된 파일입니다.');
}
```

- `node index.js`로 실행하면 → true
- `require('./index')`로 불러오면 → false

이 패턴은 CLI 스크립트나 유틸 모듈에서 자주 사용됩니다.

| 항목 | require.cache | require.main |
|------|-------------|------------|
| 의미 | 로드된 모듈들의 캐시 목록 | 프로그램의 진입점(첫 실행 파일) |
| 타입 | 객체 { 경로: Module } | Module 객체 |
| 역할 | 중복 로딩 방지 | 메인 모듈 확인용 |
| 실무 활용 | 핫리로드, 디버깅, 테스트 | CLI, 유틸 모듈의 직접 실행 체크 |

### const dep1 = require('./dep1')이 실행되면 내부적으로 일어나는 일

`require()` 호출 시 Node는 5단계를 거칩니다.

**①경로 해석 (Path Resolution)**: `require('./dep1')` → Node는 다음 순서로 파일을 찾습니다. `dep1`이 내장 모듈인지 확인, 상대 경로를 절대 경로로 변환(예: `/Users/.../project/dep1.js`), `.js`, `.json`, `.node` 확장자를 순서대로 시도해서 파일 존재 여부 확인.

**②캐시 확인 (require.cache)**: Node는 모든 로드된 모듈을 `require.cache`에 저장해둡니다. 만약 `dep1`이 이미 로드되어 있다면, 다시 읽지 않고 캐시된 exports를 바로 반환합니다. 즉, 동일 파일이 두 번 실행되지 않습니다.

**③새로운 Module 객체 생성**: 처음 로드하는 모듈이라면 Node는 내부적으로 다음과 같은 객체를 만듭니다

```javascript
Module {
  id: '/Users/.../dep1.js',
  filename: '/Users/.../dep1.js',
  loaded: false,
  exports: {},
  parent: [호출한 모듈],
  children: [],
  paths: [모듈 탐색 경로들]
}
```

**④파일 내용 읽기 + 감싸서 실행**: Node는 해당 JS 파일을 읽고 자동으로 함수로 감쌉니다. 즉, `dep1.js`가 실제로는 이렇게 감싸져 실행됩니다.

```javascript
(function (exports, require, module, __filename, __dirname) {
  // dep1.js의 실제 코드 내용
})();
```

이 함수 실행 시점에 `exports`, `require`, `module` 객체가 주입됩니다. 이게 바로 "모듈 스코프"가 생기는 이유예요. (전역 변수를 오염시키지 않음!)

**⑤코드 실행**: 이제 dep1.js 내부의 코드가 실행됩니다. 예를 들어 `dep1.js`가 이렇게 생겼다고 합시다.

```javascript
console.log('dep1 실행됨');
module.exports = { value: 10 };
```

그럼 이 시점에서 콘솔에 `"dep1 실행됨"`이 찍히고, `module.exports` 객체가 `{ value: 10 }`으로 설정됩니다. Node는 이 `module.exports` 객체를 `require('./dep1')`의 반환값으로 돌려줍니다.

**⑥캐시에 저장하고 반환**: 실행이 끝나면:

```javascript
require.cache['/Users/.../dep1.js'] = module;
module.loaded = true;

const dep1 = require('./dep1'); // { value: 10 }
```

| 단계 | 설명 |
|------|------|
| ① 경로 해석 | 파일 확장자, 절대경로 확인 |
| ② 캐시 확인 | require.cache에서 이미 로드된 모듈 재사용 |
| ③ Module 객체 생성 | 모듈 인스턴스 준비 (exports, require, module) |
| ④ 코드 실행 | 파일을 함수로 감싸서 실행 |
| ⑤ 반환 및 캐시 | module.exports를 반환하고 캐시에 저장 |

순환 참조 시, Node는 캐시에 있는 미완성 모듈 객체를 임시로 반환합니다. 이는 무한 루프 대신 중간 상태의 객체를 돌려주는 방식으로 순환 참조를 처리합니다.

---

## Promise와 비동기

### Promise와 await의 관계

자바스크립트는 한 번에 한 줄씩 순차적으로 실행됩니다. 그래서 이런 코드를 실행하면:

```javascript
console.log('A');
setTimeout(() => console.log('B'), 1000);
console.log('C');
// 출력: A → C → B
```

setTimeout()은 "1초 후 실행해!"라고 비동기적으로 예약만 하고, 나머지 코드를 바로 실행하기 때문입니다. 이런 "나중에 실행될 일"을 다루기 위해 만들어진 게 바로 Promise입니다.

Promise는 "나중에 결과를 약속하는 객체"입니다. 지금은 값이 없지만, 나중에(비동기 작업이 끝나면) 값을 주겠다고 약속합니다.

```javascript
const promise = new Promise((resolve, reject) => {
  const success = true;
  if (success) resolve('성공!');
  else reject('실패!');
});

promise
  .then((result) => console.log('결과:', result))
  .catch((error) => console.error('에러:', error));
```
Promise는 두 가지 상태로 바뀔 수 있습니다.
- **fulfilled (성공)** → `resolve(결과값)`
- **rejected (실패)** → `reject(에러)`

`await`은 Promise를 동기식처럼 기다리는 문법입니다. 코드가 더 직관적이고 읽기 쉬워집니다.

```javascript
async function run() {
  console.log('시작');
  const result = await promise;
  console.log(result);
  console.log('끝');
}
run();
// 출력: 시작 → (1초 대기) → 성공! → 끝
```

| 비교 항목 | then | await |
|---------|------|-------|
| 문법 | 함수 체인 | 동기식처럼 보이는 문법 |
| 에러 처리 | .catch() | try...catch |
| 위치 | 어디든 가능 | async 함수 안에서만 |
| 반환값 | 새로운 Promise | Promise의 실제 값 |

### import()는 Promise를 반환한다?

동적 모듈 로드에 사용되는 `import()`는 항상 Promise를 반환합니다. 반환값은 모듈 네임스페이스 객체로, 모든 export된 값이 프로퍼티로 들어있습니다.

```javascript
const m1 = await import('./func.js');
console.log(m1);
// [Module: null prototype] { default: [Function: checkOddOrEven] }
```

- `m1`은 일반 JS 객체가 아니라 "ES 모듈 네임스페이스 객체"
- 이 안에는 default export가 들어있어서, 실제 함수는 `m1.default`로 접근해야 함

```javascript
console.log(m1.default(3)); // 함수 실행
```

Node.js가 내부적으로 이 네임스페이스 객체를 특수 객체로 만들기 때문에 `[Module: null prototype]`이 붙습니다. 프로토타입이 `null`인 immutable namespace object로, 일반 JS 객체처럼 수정할 수 없게 되어 있습니다.

### await을 fs.readFile에 붙이는 이유?

Node의 `fs.promises.readFile()`은 Promise를 반환하는 비동기 함수입니다. `await`을 붙이면 파일 읽기가 끝날 때까지 기다렸다가 그 결과(Buffer 또는 문자열)를 `data` 변수에 담습니다.

```javascript
const filePath = path.join(__dirname, 'restFront.html');
const data = await fs.readFile(filePath); // 파일 읽을 때까지 대기
res.end(data);
```

경로 결합(`path.join`)은 즉시 문자열 생성이고, 파일 읽을 때까지 대기(비동기)→ `await` 필요합니다.

만약 `await`을 안 붙이면 `data`에는 Promise 객체가 들어옵니다. 즉, 파일 내용이 아니라 "나중에 결과를 줄 약속(Promise)"만 들어있는 상태죠. `res.end(data)`를 하면 내용이 아니라 `[object Promise]` 같은 이상한 값이 전송될 겁니다.

---

## 이벤트 루프

### 마이크로태스크와 태스크 큐

Node.js의 이벤트 루프는 두 가지 큐를 관리합니다.

| 큐 종류 | 포함 함수 | 실행 시점 |
|--------|---------|---------|
| 마이크로태스크 | process.nextTick, Promise.then | 각 단계 완료 직후 |
| 태스크 | setTimeout, setInterval, setImmediate | 각 이벤트 루프 단계 |

### setImmediate가 왜 지연될까?

`setImmediate()`는 이름과 달리 "즉시 실행"이 아닙니다. 이벤트 루프의 check phase에서 실행되도록 예약됩니다. `clearImmediate()`가 같은 tick 내에서 실행되면 콜백은 큐에 들어가기 전에 제거됩니다.

```javascript
const immediate2 = setImmediate(() => {
  console.log('실행되지 않습니다');
});

clearImmediate(immediate2);
// immediate2는 check phase 전에 제거되므로 실행되지 않음
```

Node.js의 이벤트 루프는 아래 단계로 돌아갑니다.

1. **timers phase** (setTimeout, setInterval 실행)
2. **I/O callbacks phase**
3. **poll phase** (파일 읽기 등 I/O 대기)
4. **check phase** (setImmediate 실행)
5. **close callbacks phase**

`setImmediate()`는 "이벤트 루프 한 바퀴 돈 후 실행"이고, `clearImmediate()`는 "그 전에 지워버리는 명령"입니다. 그래서 "즉시 실행"처럼 보이지만 사실은 "조금 뒤에 실행될 것"을 예약하는 거예요.

### process.nextTick이 왜 가장 먼저 실행될까?

`process.nextTick()`은 가장 먼저 처리됩니다. Node.js는 각 단계가 끝난 직후 마이크로태스크 큐를 비우는데, `nextTick` 큐가 가장 먼저 비워집니다.

```javascript
setImmediate(() => console.log('immediate'));
process.nextTick(() => console.log('nextTick'));
setTimeout(() => console.log('timeout'), 0);
Promise.resolve().then(() => console.log('promise'));

// 출력: nextTick → promise → timeout → immediate
```

Node.js는 다음 순서로 코드를 처리합니다.


1. **동기 코드** 먼저 실행 - 위 4줄은 모두 "비동기 예약"만 하고, 즉시 실행되지 않음
2. **마이크로태스크** 처리 - process.nextTick() → Node.js가 가장 먼저 처리, 그 다음 Promise.then()
3. **태스크 큐** 실행 - setTimeout → setImmediate 순으로 실행

주의할 점은 재귀적으로 `nextTick`을 호출하면 이벤트 루프가 다음 단계로 진행하지 못합니다. 마이크로태스크 큐가 계속 차기 때문에 `setTimeout`이나 `setImmediate` 같은 다른 비동기 콜백은 영원히 실행되지 않을 수 있습니다.

```javascript
function recursive() {
  process.nextTick(recursive);
}
recursive();
// 이벤트 루프가 다음 단계로 절대 못 넘어감
```

---

## 비동기 작업 실전

### 비동기 작업은 요청만 보낸다?

비동기 메서드들은 요청만 계속하고 다음 작업으로 넘어갑니다. 따라서 파일 읽기 요청만 여러 번을 보내고, 실제 읽기는 백그라운드에서 진행됩니다.

```javascript
console.log('시작');
fs.readFile('./readme.txt', (err, data) => console.log('1번', data.toString()));
fs.readFile('./readme.txt', (err, data) => console.log('2번', data.toString()));
fs.readFile('./readme.txt', (err, data) => console.log('3번', data.toString()));
console.log('끝');

// 출력 예:
// 시작
// 끝
// 2번 저를 여러 번 읽어보세요.
// 3번 저를 여러 번 읽어보세요.
// 1번 저를 여러 번 읽어보세요.
```

비동기 메서드들은 백그라운드에 파일을 읽으라고만 요청하고 다음 작업으로 넘어갑니다. 파일 읽기 요청만 세 번을 보내고 `console.log('끝')`을 찍습니다. 나중에 읽기가 완료되면 백그라운드가 메인 스레드에 알립니다. 메인 스레드는 그제서야 등록된 콜백 함수를 실행합니다.

순서대로 처리하고 싶다면 `fs.readFileSync()`를 사용해야 합니다. 동기 메서드는 파일 읽기가 완료될 때까지 다음 줄의 코드를 실행하지 않습니다.

### Thread pool이란?

Node.js의 JavaScript 엔진은 싱글 스레드이지만, libuv 라이브러리가 내부적으로 스레드 풀을 관리합니다. 파일 I/O, 암호화 등 무거운 작업은 이 스레드 풀에서 병렬 처리됩니다.

| 구성 요소 | 설명 |
|---------|------|
| 메인 스레드 | 자바스크립트 코드 실행, 콜백 처리 |
| 스레드 풀 | 오래 걸리는 I/O나 CPU 작업을 비동기로 수행 |

기본 스레드 풀 크기는 4이므로, 8개의 암호화 작업을 동시에 요청하면 처음 4개는 병렬로 실행되고, 나머지 4개는 큐에서 대기합니다.

#### 스레드 풀 동작 예시

```javascript
const crypto = require('crypto');

const pass = 'pass';
const salt = 'salt';
const start = Date.now();

for (let i = 1; i <= 8; i++) {
  crypto.pbkdf2(pass, salt, 1000000, 128, 'sha512', () => {
    console.log(i + ':', Date.now() - start);
  });
}
```

출력 예:

```
4: 1548
2: 1583
1: 1590
3: 1695
6: 3326
5: 3463
7: 3659
8: 3682
```

처음 4개 작업(1~4)은 약 1.5초 후에 완료되고, 나머지 4개(5~8)는 약 3초 후에 완료됩니다. 이는 스레드 풀이 기본적으로 4개의 스레드만 보유하기 때문입니다.

#### 스레드 풀 크기 조정하기

Node.js의 기본 스레드풀 크기는 4개입니다. 환경 변수로 변경할 수 있어요.

**Windows:**

```bash
set UV_THREADPOOL_SIZE=1
node threadpool.js
```

**macOS / Linux:**

```bash
UV_THREADPOOL_SIZE=1 node threadpool.js
```

| 설정 | 실행 패턴 |
|------|---------|
| UV_THREADPOOL_SIZE=1 | 하나씩 순서대로 실행 (직렬 처리) |
| UV_THREADPOOL_SIZE=4 | 4개씩 동시에 처리 (기본값) |
| UV_THREADPOOL_SIZE=8 | 8개 전부 동시에 처리 가능 |

#### 왜 1~4만 동시에 처리되나?

libuv(노드의 런타임 레벨)가 내부적으로 스레드풀 4개를 유지하기 때문이에요. 즉, 이런 구조입니다.
```
메인 스레드 (JS 실행)
      │
      ├── 스레드 1 ── pbkdf2(1)
      ├── 스레드 2 ── pbkdf2(2)
      ├── 스레드 3 ── pbkdf2(3)
      ├── 스레드 4 ── pbkdf2(4)
      └── (대기열) ── pbkdf2(5~8)
```

4개의 스레드가 모두 바쁘면, 나머지는 대기열에 있다가 스레드가 비면 실행됩니다.

#### "싱글 스레드인데 병렬로 된다"는 뜻은?

Node.js의 메인 스레드는 1개라서 JS 코드 자체는 한 줄씩 순차적으로 실행됩니다. 하지만 스레드풀은 백그라운드에서 병렬 작업을 합니다. 그래서 JS 코드가 멈추지 않고 다른 일을 계속할 수 있는 거예요.


| 상황 | 설명 |
|------|------|
| 파일 입출력(fs) | 여러 파일을 동시에 읽을 때 — 스레드풀이 병렬로 처리 |
| 암호화/압축(crypto/zlib) | CPU 계산이 많은 작업 — 스레드풀이 부담 분산 |
| DNS 조회(dns.lookup) | 네트워크 대기 시간 — 스레드풀이 병렬로 처리 |

이 구조 덕분에 Node.js가 싱글 스레드임에도 "논블로킹, 고성능 서버"로 동작할 수 있는 거예요.

#### 주의할 점

1. 스레드풀 개수를 너무 크게 하면 오히려 느려집니다 (문맥 전환 비용 증가, CPU 스케줄링 오버헤드)
2. CPU 개수(코어 수)보다 조금 큰 정도로 맞추는 게 일반적입니다. 예: 8코어 → UV_THREADPOOL_SIZE=8~12
3. pbkdf2처럼 CPU에 부하가 큰 함수는 스레드풀을 너무 크게 잡으면 CPU 100% 포화될 수 있습니다

---

## HTTP와 웹 보안

### 쿠키와 세션 이해하기

HTTP는 기본적으로 "Stateless(상태를 기억하지 않는)" 프로토콜입니다.

즉:
- 클라이언트가 서버에 "GET /home" 요청을 보냄
- 서버는 HTML을 보내줌
- 그다음 "GET /about" 요청을 보내면, 서버는 "이게 아까 그 사람이었는지, 새 손님인지" 전혀 모름

이게 HTTP의 기본 특성입니다. 매 요청(request)은 독립적이라 "이전 요청의 사용자"를 알 수 없습니다.

우리가 로그인하면 한 번 인증만으로 계속 로그인 상태가 유지되죠? 그 비밀이 바로 쿠키(cookie)와 세션(session)입니다.

쿠키는 브라우저에 저장되는 "작은 데이터 조각"이에요. 형식은 단순한 `키=값` 쌍으로 되어 있고, 서버가 브라우저에게 "이거 저장해 둬"라고 알려줍니다.

예:

```
Set-Cookie: user=zerocho; Expires=Wed, 23 Oct 2025 12:00:00 GMT;
```

이걸 브라우저가 저장해두면, 다음 요청부터는 자동으로 서버에 같이 보내요.

```
Cookie: user=zerocho
```

#### 서버-브라우저 간 쿠키의 흐름

**로그인 요청:**

```
POST /login HTTP/1.1
```

서버가 로그인 성공 후 응답할 때 이렇게 보냅니다.

```
HTTP/1.1 200 OK
Set-Cookie: sessionId=abc123; Expires=Wed, 23 Oct 2025 12:00:00 GMT;
```

브라우저는 이 응답에서 쿠키를 저장합니다.

**다음 요청부터:**

```
GET /profile HTTP/1.1
Cookie: sessionId=abc123
```

서버는 `sessionId`를 보고 사용자를 식별합니다.

#### 쿠키의 보안과 개인 정보

쿠키는 사용자 식별에 쓰이기 때문에 보안상 민감합니다.

- 광고 추적이나 행동 분석에 악용될 수 있음
- 다른 사람이 내 브라우저를 쓰면 내 쿠키로 로그인될 수도 있음
- 그래서 보안상 "쿠키를 주기적으로 삭제"하라고 하는 거예요

| 구분 | 설명 |
|------|------|
| 저장 위치 | 클라이언트(브라우저) |
| 전송 방식 | Set-Cookie 헤더(서버→클라이언트) / Cookie 헤더(클라이언트→서버) |
| 용도 | 로그인 상태 유지, 사용자 식별, 설정 기억 등 |
| 형태 | key=value 형태 |
| 유효기간 | 서버가 설정 (Expires 또는 Max-Age) |
| 주의사항 | 개인 정보 포함 시 암호화 필요, HttpOnly와 Secure 플래그 권장 |

### HTTPS, HTTP/2는 뭐지?

HTTP는 암호화되지 않은 평문 통신이에요. 즉, 클라이언트(브라우저) ↔ 서버 사이의 데이터가 그냥 텍스트로 오가기 때문에 누구나 중간에서 볼 수 있습니다.

예를 들어 로그인할 때:

```
POST /login HTTP/1.1
username=ys&password=1234
```

이런 식으로 전송된다면, 네트워크를 도청하는 사람은 사용자의 아이디·비밀번호를 그대로 볼 수 있죠. 그래서 이걸 해결하려고 나온 게 바로 HTTPS입니다.

#### HTTPS란?

**HTTPS = HTTP + SSL/TLS(암호화 계층)**

HTTPS는 클라이언트와 서버 사이에 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security)라는 암호화 계층을 추가합니다.

즉:
- 요청(Request)도 암호화되어 전송되고
- 응답(Response)도 암호화되어 돌아옵니다

이 덕분에:
- 중간자(해커)가 내용을 훔쳐봐도 알아낼 수 없고
- 데이터 변조(위조)도 어렵습니다

그래서 로그인·결제 등 민감한 요청에는 반드시 HTTPS가 필요합니다.

#### SSL 인증서란?

HTTPS를 쓸 때는 "이 서버가 진짜 맞는지"를 증명할 인증서(certificate)가 필요합니다. 이 인증서는 공인된 인증 기관(CA, Certificate Authority)에서 발급받아요.

- `key`: 서버의 비밀 키(private key)
- `cert`: 서버의 인증서(public certificate)
- `ca`: 상위 인증서 (인증 기관 체인)

이 세 가지가 합쳐져서 "이 사이트는 진짜 이 도메인의 주인입니다"를 증명합니다.

#### Node.js에서 HTTPS 서버 만들기

보통 HTTP 서버는 이렇게 만들죠:

```javascript
const http = require('http');

http.createServer((req, res) => {
  res.writeHead(200);
  res.end('Hello HTTP!');
}).listen(8080);
```

여기에 SSL 암호화(https 모듈)를 적용하면 이렇게 바뀝니다.

```javascript
const https = require('https');
const fs = require('fs');

https.createServer({
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  ca: [
    fs.readFileSync('chain1.pem'),
    fs.readFileSync('chain2.pem')
  ],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end('<h1>Hello HTTPS!</h1>');
})
.listen(443, () => console.log('443번 포트에서 HTTPS 서버 대기 중!'));
```

설명:
- `createServer()` 대신 `https.createServer()` 사용
- 첫 번째 인수: 인증서 옵션 객체 (`key`, `cert`, `ca`)
- 두 번째 인수: 일반적인 요청 처리 콜백
- 포트: HTTPS 기본 포트는 `443`

참고: HTTP는 80번 포트, HTTPS는 443번 포트를 씁니다.

#### http/1.1 vs http/2 차이

HTTP/2는 2015년에 등장한 새로운 프로토콜이에요. Node.js에서는 `http2` 모듈로 지원합니다.

기존 HTTP/1.1은 요청당 하나의 연결(TCP connection)을 사용했습니다. 즉, 브라우저가 HTML, CSS, JS, 이미지 등 여러 파일을 한 번에 요청하려면 각 파일마다 새로운 연결을 만들어야 했어요. 비효율적이죠!

**HTTP/1.1의 한계:**

```
Client ───req──▶ Server (index.html)
Client ───req──▶ Server (style.css)
Client ───req──▶ Server (main.js)
```

파일마다 요청/응답을 새로 시작해야 함 → 네트워크 지연(latency) 증가 → 헤더 중복 전송

**HTTP/2의 개선점:**

1. **Multiplexing (멀티플렉싱)**: 하나의 TCP 연결에서 여러 요청을 동시에 보낼 수 있음. 즉, CSS, JS, 이미지 등을 병렬로 전송 가능
2. **Header Compression (헤더 압축)**: 중복되는 헤더(User-Agent, Accept 등)을 압축해서 전송량 절감
3. **Server Push**: 서버가 클라이언트가 아직 요청하지 않은 리소스도 미리 보내줄 수 있음 (예: HTML 응답 시 CSS/JS를 같이 push)
4. **Binary Framing Layer**: 데이터를 텍스트가 아닌 바이너리 프레임으로 전송해 효율 증가

#### Node.js http2 서버 예시

```javascript
const http2 = require('http2');
const fs = require('fs');

http2.createSecureServer({
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  ca: [fs.readFileSync('chain.pem')],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end('<h1>Hello HTTP/2!</h1>');
})
.listen(443, () => console.log('HTTP/2 서버 대기 중'));
```

#### 차이점 정리

| 항목 | http | https | http2 |
|------|------|-------|--------|
| 모듈 | http | https | http2 |
| 암호화 | 없음 | SSL/TLS | SSL/TLS 필수 |
| 성능 | 기본 | 암호화로 약간 느림 | 훨씬 효율적, 빠름 |
| 포트 | 80 | 443 | 443 |
| Node 메서드 | createServer() | createServer() | createSecureServer() |

#### 실제 사용 예 (브라우저 표시)

- HTTP: 자물쇠 모양 없음, "주의 요함" 또는 "Not Secure" 경고 표시
- HTTPS: 자물쇠 모양 표시
- HTTP/2: 내부적으로만 적용 (브라우저 개발자 도구에서 `[h2]`로 표시됨)

---

## 서버 성능 최적화

### Cluster는 뭐지?

Node.js는 기본적으로 싱글 프로세스로 동작하므로, CPU 여러 코어가 있더라도 그중 1개만 사용합니다. 예를 들어 8코어 CPU가 있어도 Node는 1코어만 사용하므로 자원이 낭비됩니다.

Cluster 모듈은 Node.js가 여러 CPU 코어를 활용할 수 있도록 여러 프로세스를 띄워줍니다. 각 워커 프로세스가 같은 포트를 공유하고, OS가 자동으로 요청을 분산합니다.

핵심 아이디어:
- 하나의 서버 코드로 여러 개의 워커(worker) 프로세스를 띄움
- 각 워커가 같은 포트(예: 8086)를 공유
- 요청이 들어올 때 OS 레벨에서 자동으로 요청을 분산(로드 밸런싱)

#### 클러스터 코드 예시

```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // 마스터 프로세스: 워커들을 관리
  console.log(`마스터 프로세스 아이디: ${process.pid}`);

  // CPU 개수만큼 워커 생성
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  // 워커가 종료되었을 때 실행되는 이벤트
  cluster.on('exit', (worker, code, signal) => {
    console.log(`${worker.process.pid}번 워커 종료`);
    console.log('code', code, 'signal', signal);
  });

} else {
  // 워커 프로세스: 실제 서버 역할
  http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Cluster!</p>');
  }).listen(8086);

  console.log(`${process.pid}번 워커 실행`);
}
```

#### 실행 흐름

1. Node 실행 시 `cluster.isMaster`가 true이면 마스터 프로세스로 시작
2. 마스터가 CPU 코어 수(`numCPUs`)만큼 `cluster.fork()` 호출 → 워커 프로세스 생성
3. 각 워커는 else 블록을 실행해서 동일한 포트(8086)에서 서버 시작
4. 요청이 들어오면 OS가 알아서 여러 워커에게 분산

#### 실행 결과 예시 (8코어라면)

```
마스터 프로세스 아이디: 1234
5678번 워커 실행
5679번 워커 실행
5680번 워커 실행
5681번 워커 실행
...
```

8개의 워커가 동시에 8086 포트에서 요청 대기합니다.

#### 요청이 들어올 때 어떤 일이 일어날까?

예를 들어 클라이언트 요청이 여러 번 들어오면:

| 요청 | 처리한 프로세스(pid) |
|------|------------------|
| 요청 1 | 5678 |
| 요청 2 | 5679 |
| 요청 3 | 5680 |
| 요청 4 | 5681 |

이런 식으로 요청이 워커들에게 나누어집니다 (load balancing). 따라서 CPU 여러 코어를 동시에 활용하게 되어 처리 속도가 개선됩니다.

#### 왜 성능이 꼭 N배로 안 오르나?

- Node.js 내부 구조상 완벽 병렬 처리 아님 (I/O가 많으면 차이 적음)
- 워커 간 메모리를 공유하지 않음 → 데이터 복제 필요
- CPU 사용률 분배 및 OS 스케줄링 오버헤드 존재

그래서 "코어 수 = 속도 배수"는 아니지만, 병렬 요청 처리 성능이 확실히 좋아집니다.

#### 클러스터의 단점과 해결책

| 문제점 | 설명 | 해결책 |
|-------|------|-------|
| 메모리 공유 불가 | 각 워커는 별도 프로세스이므로 변수/객체 공유 불가능 | Redis 등 외부 스토리지 사용 |
| 세션 관리 문제 | 로그인 세션을 메모리에 저장하면 다른 워커에서 인식 불가 | Redis/Memcached 같은 세션 서버 필요 |
| 복잡성 증가 | 워커 모니터링, 재시작 로직 필요 | PM2 같은 프로세스 매니저로 해결 |

#### 실무에서의 사용

실제로는 cluster 모듈을 직접 쓰기보다, PM2 같은 Node 프로세스 매니저가 내부적으로 cluster 기능을 대신 써줍니다.

```bash
pm2 start app.js -i max
```

이 명령어는 CPU 코어 수만큼 자동으로 cluster 실행합니다.