# REPL 사용하기

입력한 코드를 읽고*READ*, 해석하고*EVAL*, 결과물을 반환하고,*Print* 종료할 때까지 반복한다*Loop* → **REPL**


- 한 두 줄짜리 코드를 테스트해보는 용도로는 좋지만 여러 줄의 코드를 실행하기엔 불편함
- 긴 코드는 그냥 JS파일로 만든 후 파일을 통째로 실행하는 걸 추천
- `Ctrl + C` 2번 누르면 REPL종료

# 모듈로 만들기

- **모듈** : 특정한 기능을 하는 함수나 변수들의 집합
- 모듈로 만들어두면 재사용이 쉬움
- **CommonJS**와 **ECMAScript**가 있음

## CommonJS

<모듈을 만들기 위한 준비물>

1. 모듈이 될 파일 

```jsx
const odd = 'CJS홀수입니다';
const even = 'CSJ짝수입니다';

module.exports = {
    odd,
    even,
};
```

- module.exports에 변수들을 담은 객체를 대임 → 이 파일은 이제 모듈로써 기능함
- 다른 파일에서 이 파일을 불러오면 modile.exports에 대입된 값을 사용할 수 있음
- module.exports = {
    odd,
}; 를 `exports.odd = ‘ … ’;` 처럼 쓸 수도 있음
1. 모듈을 불러와서 사용할 파일 

```jsx
const {odd, even} = require('./var');

function checkOddEven(num){
    if(num%2){
        return odd;
    } 
    return even;
}

module.exports = checkOddEven;
```

- require함수를 이용해 var.js에 있던 값을 불러오고 있음
- const {odd, even} : 구조분해할당 이용
- var.js에서 변수를 불러온 뒤, 숫자의 홀짝을 판별하는 함수 선언 → module.exports에 다시 함수 대입

```jsx
const {odd, even} = require('./var');
const checkNumber = require('./func');

function checkStringOddEven(str){
    if (str.length % 2){
        return odd;
    }
    return even;
}

console.log(checkNumber(10));
console.log(checkStringOddEven('hello'));
```

- 모듈 하나에 여러개의 모듈을 사용할 수도 있음
- 근데 모듈이 많아지고 모듈 간의 관계가 얽히게 되면 구조를 파악하는 게 어려워질 수도 있긴 함

### require

- 아무곳에나 사용가능
- require.cache에 한번 require한 모듈에 대한 캐쉬 정보가 들어있음
- require.module : 노드 실행 시 첫 모듈

### 순환참조

```jsx
const dep2 = require('./dep2');
console.log('require dep2', dep2);
module.exports = () => {
  console.log('dep2', dep2);
};
```

```jsx
const dep1 = require('./dep1');
console.log('require dep1', dep1);
module.exports = () => {
  console.log('dep1', dep1);
};
```

```jsx
const dep1 = require('./dep1');
const dep2 = require('./dep2');

dep1();
dep2();
```

→ 순환참조 : 두 개 이상의 모듈이 서로를 직간접적으로 참조하는 상황을 말함

- 순환참조가 있을 땐 순환참조되는 대상을 빈 객체로 만듦

⚠️ 이때 에러가 발생하지 않고 조용히 빈 객체로 변경되므로 예기피 못한 동작이 발생할 수 있음… 

## ECMAScript

- JS의 공식적인 표준 모듈 형식
- Node.js에서는 아직 CommonJS가 많이 쓰이지만, ES 모듈 사용이 증가하는 추세
- 가장 큰 장점은 **브라우저와 Node.js 양쪽에서 동일한 모듈 형식**을 사용할 수 있다는 점…

### CommonJS모듈과의 주요 차이점

CommonJS의 `require`, `module.exports`, `exports`가 ES 모듈에서는 `import`, `export default`, `export` 문법으로 변경됨

```jsx
//var.mjs

export const odd = 'MJS 홀수입니다';
export const even = 'MJS 짝수입니다';
```

```jsx
//func.mjs

import { odd, even } from './var.mjs';

function checkOddOrEven(num) {
  if (num % 2) { // 홀수이면
    return odd;
  }
  return even;
}

export default checkOddOrEven;
```

```jsx
//index.mjs

import { odd, even } from './var.mjs';
import checkNumber from './func.mjs';

function checkStringOddOrEven(str) {
  if (str.length % 2) { // 홀수이면
    return odd;
  }
  return even;
}

console.log(checkNumber(10));
console.log(checkStringOddOrEven('hello'));
```

**파일 확장자 및 설정**

- ES 모듈은 **`.mjs`** 확장자를 사용함
- 만약 `.js` 확장자를 그대로 사용하려면, `package.json` 파일에 **`"type": "module"`** 속성을 반드시 추가해야됨
    
    ⚠️ 이 설정이 없으면 `.js` 파일에서 `import` 사용 시 `SyntaxError` 발생
    ****
    

**모듈 경로 (Import Paths)**

- 확장자 생략 불가능: `import` 시 `.mjs`나 `.js` 같은 파일 확장자를 생략할 수 없음
    - CommonJS: `require('./folder/var')` → 가능
    - ES 모듈: `import { odd } from './var.mjs'` → 확장자 필수
- 인덱스 파일 생략 불가능: 폴더 내의 `index.mjs` 파일을 생략할 수 없음
    - CommonJS: `require('./folder')` → 가능
    - ES 모듈: `import './folder/index.mjs'` → 저체 경로 필수

## 다이내믹 임포트

### 다이내믹 임포트란?

- 조건부로 모듈을 불러오는 것
- 코드 실행 흐름에 따라 필요한 시점에 모듈을 로드할 수 있게 해줌

### CommonJS / ES 모듈

1. CommonJS
- CommonJS의 `require` 함수는 다이내믹 임포트를 지원
- `if`문 같은 조건문 안에서 `require`를 사용해도 문제없이 동작함

```jsx
// dynamic.js
const a = false;
if (a) {
  require('./func'); 
console.log('성공');

/*
콘솔 출력:
$ node dynamic
성공
*/
```

1. ECMAScript 모듈
- ES 모듈의 `import` 문법은 조건문 안에서 사용할 수 없음
- `import` 문은 파일의 최상위 스코프에서만 사용가능

```jsx
// dynamic.mjs
const a = false;
if (a) {
  import './func.mjs'; // 이 문법 자체가 에러임
}
console.log('성공');

/*
콘솔 출력:
$ node dynamic.mjs
SyntaxError: Unexpected string
*/
```

따라서 ES모듈에서 다이내믹 임포트를 구현하려면 **import()함수**를 사용해야됨

```jsx
// dynamic.mjs (수정ver)
const a = true;
if (a) {
  // await를 사용하여 Promise가 완료되길 기다림
  const m1 = await import('./func.mjs');
  console.log(m1);
  const m2 = await import('./var.mjs');
  console.log(m2);
}
```

- `import()` 함수는 **Promise를 반환**
- 따라서 `await` 키워드나 `.then()` 메서드를 사용해 비동기적으로 모듈을 받아와야 됨

## _filename, _dirname

- 상기 키워드로 경로에 대한 정보를 제공함
- 파일에 _filename, _dirname를 넣어두면 실행 시 현재 파일명과 경로로 바뀜

### CommonJS모듈

- CommonJS 환경에서는 `__filename`과 `__dirname`이라는 내장 키워드를 바로 사용할 수 있음
- `__filename`: 현재 실행 중인 파일의 전체 경로와 파일명까지 포함
- `__dirname`: 현재 실행 중인 파일이 위치한 디렉터리의 전체 경로

### ES모듈

- ES 모듈 환경에서는 `__filename`과 `__dirname`을 사용할 수 없음 → 사용 시 `ReferenceError` 오류가 발생
    
    그렇기에, `import.meta.url` 사용
    

# 노드 내장 객체 알아보기

- 노드에선 기본적으로 내장객체/모듈을 지원함
- 따로 설치 없이 바로 사용 가능

## global

- Node.js의 전역객체
- 모든 파일에서 접근할 수 있음
- global키워드 자체는 생략 가능 (`console.log()`는 사실 `global.console.log()`임)
- `require` 함수나 `console` 객체도 모두 `global` 객체의 속성임

## console

- `console` 객체 역시 `global` 객체 안에 있으며, 주로 디버깅을 위해 사용
- console.time(레이블): console.timeEnd(레이블)과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정합니다.
- console.log(내용): 평범한 로그를 콘솔에 표시합니다. console.log(내용, 내용, …)처럼 여러 내용을 동시에 표시할 수도 있습니다.
- console.error(에러 내용): 에러를 콘솔에 표시합니다.
- console.table(배열): 배열의 요소로 객체 리터럴을 넣으면, 객체의 속성들이 테이블 형식으로 표현됩니다. 아래 결과를 확인해보세요.
- console.dir(객체, 옵션): 객체를 콘솔에 표시할 때 사용합니다. 첫 번째 인수로 표시할 객체를 넣고, 두 번째 인수로 옵션을 넣습니다. 옵션의 colors를 true로 하면 콘솔에 색이 추가되어 보기가 한결 편해집니다. depth는 객체 안의 객체를 몇 단계까지 보여줄지를 결정합니다. 기본값은 2입니다.
- console.trace(레이블): 에러가 어디서 발생했는지 추적할 수 있게 합니다. 보통은 에러 발생 시 에러 위치를 알려주므로 자주 사용하지 않지만, 위치가 나오지 않는다면 사용할 만합니다.

## 타이머

- global객체에 포함
- 웹브라우저에서 자주 사용됨
- **`setTimeout(콜백 함수, 밀리초)`**
    - 주어진 `밀리초` 이후에 콜백 함수를 **한 번** 실행.
- **`setInterval(콜백 함수, 밀리초)`**
    - 주어진 `밀리초`마다 콜백 함수를 **반복 실행**.
- **`setImmediate(콜백 함수)`**
    - 콜백 함수를 **즉시 실행**합니다. (이벤트 루프 내에서 우선순위가 있음.)
- **`clearTimeout(아이디)`**: `setTimeout`을 취소
- **`clearInterval(아이디)`**: `setInterval`을 취소
- **`clearImmediate(아이디)`**: `setImmediate`를 취소

## process

- process객체  : 현재 실행 중인 노드 프로세스에 대한 정보를 담고 있음
- 📌 global의 속성이므로 require없이 바로 사용가능함
- 운영체제나 실행 환경에 따라 다른 동작을 수행해야 할 때 유용하게 사용됨

| **속성/메서드** | **설명** |
| --- | --- |
| `process.version` | 설치된 노드의 버전 (예:`v18.7.0`) |
| `process.arch` | 프로세서 아키텍처 (예:`x64`) |
| `process.platform` | 운영체제 플랫폼 (예:`win32`,`linux`,`darwin`) |
| `process.pid` | 현재 프로세스의 고유 아이디(PID) |
| `process.uptime()` | 프로세스가 시작된 후 흐른 시간 (초) |
| `process.execPath` | 노드 실행 파일의 경로 |
| `process.cwd()` | 현재 프로세스가 실행되는 위치 (Current Working Directory) |
| `process.cpuUsage()` | 현재 CPU 사용량 |

### propcess.env

- 시스템 환경 변수 정보가 담긴 객체임
- `NODE_OPTIONS`나 `UV_THREADPOOL_SIZE` 같은 환경 변수는 노드 동작에 직접 영향을 주기도 함

***보안 키 저장** →*

- 민감한 정보는 코드에 직접 하드코딩하면 안됨(아무래도 당연함)
- 이러한 정보(서버 비밀번호, API키 등)는 `process.env`를 사용해 환경 변수로 저장하고, 코드에서는 이를 참조하는 방식을 사용해야함

```jsx
// 코드에 비밀번호를 직접 쓰는 대신 변수에 저장해서 사용
const secretId = process.env.SECRET_ID;
const secretCode = process.env.SECRET_CODE;
```

📌 `dotenv` 같은 라이브러리를 사용하면 이를 쉽게 관리할 수 있음

### process.nextTick

- 이벤트 루프가 다른 콜백 함수들보다 **우선적으로 처리**할 콜백을 등록하는 메서드임

**마이크로태스크란**?

- `process.nextTick`과 `Promise`의 콜백(resolved된 `.then()`)은 **마이크로태스크**로 분류
- 마이크로태스크는 `setTimeout(..., 0)`이나 `setImmediate` 같은 태스크보다 항상 먼저 실행
- 실행순서 : nextTick → Promise → setTimeout(0) → setImmediate

### process.exit

- 실행 중인 노드 프로세스를 즉시 종료시키는 메서드임
- 서버가 아닌 독립적인 스크립트나 배치 프로그램에서 작업을 완료하고 수동으로 프로세스를 멈출 때 사용함
    
    Q. 왜 서버에선 안 쓰지? : 서버 환경에서 이 함수를 호출하면 **서버가 멈추므로** 특별한 경우가 아닌 이상 사용하지 않음
    
- 종료 코드
    - `process.exit(0)` (또는 인수 없음): **정상 종료**
    - `process.exit(1)`: **비정상 종료** (에러가 발생했음을 알림)
    
    ```jsx
    // 예시) 5초 뒤 종료
    let i = 1;
    setInterval(() => {
      if (i === 5) {
        console.log('종료!');
        process.exit(); // 0(정상 종료)과 동일
      }
      console.log(i);
      i += 1;
    }, 1000);
    ```
    

## 기타

*fetch를 노드에서도 쓸 수 있게 됨에 따라 브라우저에 존재하던 객체들이 노드에도 동일하게 생성됨…*

- URL, URLSearchParams: 3.5.3절에서 다룹니다.
- AbortController, FormData, fetch, Headers, Request, Response, Event, EventTarget: 브라우저에서 사용하던 API가 노드에도 동일하게 생성되었습니다.
- TextDecoder: Buffer를 문자열로 바꿉니다.
- TextEncoder: 문자열을 Buffer로 바꿉니다.
- WebAssembly: 웹어셈블리 처리를 담당합니다.

# 노드 내장 모듈 사용하기

- global객체 외에도 다양한 기능들을 별도의 **내장모듈**로 제공함
- require키워드를 이용해 다음 모듈들을 불러와 사용할 수 있음…

## OS

- require(’OS’)로 불러옴
- 현재 실행 중인 컴퓨터의 운영체제(OS)와 관련된 정보를 가져올 수 있음

### 주요 메서드 및 속성

| **메서드** | **설명** | **예시** |
| --- | --- | --- |
| `os.arch()` | 프로세서 아키텍처 | 'x64' |
| `os.platform()` | 운영체제 플랫폼 | 'win32' |
| `os.type()` | 운영체제 타입 | 'Windows_NT' |
| `os.uptime()` | 운영체제 부팅 후 흐른 시간 (초) |  |
| `os.hostname()` | 컴퓨터의 호스트 이름 |  |
| `os.release()` | 운영체제 버전 |  |
| `os.homedir()`/`os.tmpdir()` | 홈 디렉터리와 임시 파일 디렉터리 경로 |  |
| `os.cpus().length` | CPU 코어 개수 |  |
| `os.freemem()`/`os.totalmem()` | 사용 가능한 메모리 / 전체 메모리 |  |

```jsx
//예시
const os = require('os'); 

console.log('os.arch():', os.arch());// 'x64'
console.log('os.platform():', os.platform()); // 'win32'
console.log('os.cpus().length:', os.cpus().length); 
console.log('os.totalmem():', os.totalmem()); 
```

## Path

- `require('path')`로 불러옴
- 파일이나 폴더 경로를 다룰 때 매우 유용함
- 특히 운영체제별로 경로 구분자가 다른 문제(`\` vs. `/`)를 효과적으로 해결해줄 수 있음

| **메서드/속성** | **설명** | **예시** |
| --- | --- | --- |
| `path.sep` | 경로 구분자 | Windows:`\`, POSIX:`/` |
| `path.delimiter` | 환경 변수 구분자 | Windows:`;`, POSIX:`:` |
| `path.basename(경로)` | 파일명(확장자 포함) 반환 |  |
| `path.dirname(경로)` | 파일을 제외한 폴더 경로 반환 |  |
| `path.extname(경로)` | 파일의 확장자 반환 |  |
| `path.isAbsolute(경로)` | 절대 경로인지 확인 | `C:\`는 true |
| `path.join(경로1, 경로2, ...)` | 여러 경로 조각을 OS에 맞게 합침.`..`같은 상위 경로도 처리 |  |
| `path.resolve(경로1, 경로2, ...)` | `join`과 비슷하지만, 최종적으로**절대 경로**를 반환 |  |

## url

- `require('url')`로 불러옴
- URL 문자열을 파싱(해석)하거나 조작할 때 사용
- WHATWG 방식의 `URL` 객체 사용이 권장됨

| **메서드/속성** | **설명** |
| --- | --- |
| `new URL(urlString)` | URL 문자열을 파싱하여 URL 객체를 생성 |
| `url.protocol` | 프로토콜 (예: 'http:') |
| `url.href` | 전체 URL 문자열 |
| `url.searchParams` | URL의 쿼리 스트링(`?key=value`)을 쉽게 다룰 수 있는 객체 |
| `searchParams.get(key)` | 키에 해당하는 값을 가져옴 |
| `searchParams.append(key, value)` | 키-값을 추가 |
| `searchParams.delete(key)` | 키-값을 삭제 |

## dns

- `require('dns/promises')`를 사용하면 `async/await`와 함께 편리하게 사용가능
- 도메인 이름을 IP주소로 변환하는 등 DNS관련 작업을 수행함
- 

| **메서드** | **설명** | **예시/설명** |
| --- | --- | --- |
| `dns.lookup(도메인)` | 도메인을 IP 주소로 변환 | `{ address: '49.236.151.4', family: 4 }` |
| `dns.resolve(도메인, 'A')` | IPv4 주소 조회 |  |
| `dns.resolve(도메인, 'MX')` | 메일 서버 조회 |  |
| `dns.resolve(도메인, 'CNAME')` | 도메인 별칭 조회 |  |
| `dns.resolve(도메인, 'SOA')` | 도메인 권한 정보 조회 |  |
| `dns.resolve(도메인, 'ANY')` | 모든 레코드 조회 |  |

```jsx
//  예
import dns from 'dns/promises'; 
const ip = await dns.lookup('www.gilbut.co.kr'); 
console.log('IP', ip); 

const mxRecords = await dns.resolve('www.gilbut.co.kr', 'MX'); 
console.log('MX', mxRecords); 
```

## crypto

암호화…

- `require('crypto')`로 불러옴
- 해시(Hash), 암호화/복호화(Cipher) 등 암호 관련 기능을 제공함

### 단방향 암호화

- `crypto.createHash('sha512')`:  해시 알고리즘(sha512, md5, sha1 등)을 선택
- 
    
    `.update(데이터)`: 해시할 데이터를 추가함
    
- 
    
    `.digest('hex')`: 해시 결과를 'hex'(16진수) 형식으로 출력함 
    

### 키 스트레칭

- 비밀번호 저장용
- `crypto.randomBytes(바이트수, 콜백)`: 암호학적으로 안전한 난수(salt)를 생성
- `crypto.pbkdf2(비밀번호, salt, 반복횟수, 키길이, 알고리즘, 콜백)`: 비밀번호 기반 키 도출 함수. 비밀번호를 안전하게 해시할 때 사용

### 양방향 암호화

- `crypto.createCipheriv(알고리즘, key, iv)`: 암호화 객체를 생성. (예: 'aes-256-cbc')
- `cipher.update(평문, 'utf8', 'hex')` / `cipher.final('hex')`: 암호화를 수행하고 결과를 hex로 출력.
- `crypto.createDecipheriv(알고리즘, key, iv)`: 복호화 객체를 생성.
- `decipher.update(암호문, 'hex', 'utf8')` / `decipher.final('utf8')`: 복호화를 수행하고 결과를 utf8로 출력함

## util

- `require('util')`로 불러옴
- 노드 개발 시 도움이 되는 보조 기능들을 제공함

| **메서드** | **설명** |
| --- | --- |
| **`util.deprecate(함수, 경고메시지)`** | 함수를 'deprecated' (더 이상 사용되지 않음)로 표시 |
| **`util.promisify(콜백함수)`** | 콜백(callback) 스타일의 비동기 함수를 Promise를 반환하는 함수로 변환. (`async/await`사용 가능) |
| **`util.callbackify(프로미스함수)`** | 반대로 Promise 함수를 콜백 스타일로 변환 |

```jsx
// util.deprecate 예
const util = require('util'); 

const dontUseMe = util.deprecate((x, y) => { 
  return x + y;
}, '이 함수는 2025-10-19 부로 사용되지 않습니다!'); 

dontUseMe(1, 2); // (node:...) DeprecationWarning: 이 함수는... 

// util.promisify 예
const randomBytesPromise = util.promisify(crypto.randomBytes);
randomBytesPromise(64)
  .then((buf) => { /* ... */ }) 
  .catch((err) => { /* ... */ });
```

## worker_threads

- `require('worker_threads')`로 불러
- Node.js는 싱글 스레드지만, 이 모듈을 통해 **멀티 스레딩**을 구현할 수 있음
- 주로 CPU 집약적인 작업에 사용

| **메서드/속성** | **설명** |
| --- | --- |
| `isMainThread` | 현재 코드가 메인 스레드인지 워커 스레드인지 판별 |
| `parentPort` | 워커 스레드에서 메인 스레드와 통신하는 포트임 |
| `Worker` | 메인 스레드에서 새 워커를 생성함 |
| `postMessage(데이터)`/`on('message', ...)` | 스레드 간 데이터를 주고받음 |

## child_process

- `require('child_process')`로 불러옴
- 현재 노드 프로세스 외에 새로운 프로세스를 생성하여 외부 명령어(예: `python` 스크립트 실행, 셸 명령어 `dir` 또는 `ls` 실행)를 수행할 때 사용함
- 

| **메서드** | **설명** | **예시** |
| --- | --- | --- |
| `exec(명령어)` | 셸을 실행하여 명령어를 수행하고, 결과를 버퍼에 담아 한 번에 반환함 (간단한 명령어에 적합) | `exec('dir')`,`exec('ls -l')` |
| `spawn(명령어, [인수배열])` | 새 프로세스를 생성하고,`stdout`/`stderr`등과 스트림(stream) 방식으로 통신함(대용량 데이터 처리에 유리) | `spawn('python', ['test.py'])` |

```jsx
// exec 예
const { exec, spawn } = require('child_process'); 

exec('dir', (err, stdout, stderr) => { 
  if (err) {
    console.error(stderr);
    return;
  }
  console.log(stdout); 
});

// spawn 예 (파이썬 스크립트 실행)
// test.py: print('hello python')
const py = spawn('python', ['test.py']); 

py.stdout.on('data', (data) => { 
  console.log(data.toString());
});

py.stderr.on('data', (data) => { 
  console.error(data.toString());
});
```

## 기타 모듈들

| **모듈** | **설명** |
| --- | --- |
| `async_hooks` | 비동기 코드의 흐름을 추적할 수 있는 실험적인 모듈임 |
| `dgram` | UDP와 관련된 작업을 할 때 사용함 |
| `net` | HTTP보다 로우 레벨인 TCP나 IPC 통신을 할 때 사용함 |
| `perf_hooks` | 성능 측정을 할 때 console.time보다 더 정교하게 측정함 |
| `querystring` | URLSearchParams가 나오기 이전에 쿼리스트링을 다루기 위해 사용했던 모듈임. 요즘은 URLSearchParams를 사용하는 것을 권장함 |
| `string_decoder` | 버퍼 데이터를 문자열로 바꾸는 데 사용함 |
| `tls` | TLS와 SSL에 관련된 작업을 할 때 사용함 |
| `tty` | 터미널과 관련된 작업을 할 때 사용함 |
| `v8` | v8 엔진에 직접 접근할 때 사용함 |
| `vm` | 가상 머신에 직접 접근할 때 사용함 |
| `wasi` | 웹어셈블리를 실행할 때 사용하는 실험적인 모듈임 |

# 파일 시스템 접근하기

- Node.js는 `fs`라는 내장 모듈을 통해 파일 시스템에 접근할 수 있음
- `fs` 모듈은 비동기 메서드, 동기 메서드, 그리고 Promise 기반의 메서드를 모두 제공함

## 동기 메서드와 비동기 메서드

- `fs`의 메서드들은 기본적으로 비동기(non-blocking)임
- 콜백 함수나 Promise를 사용하며, 파일 I/O 작업이 진행되는 동안 메인 스레드는 다른 작업을 계속할 수 있는 거임

## 버퍼와 스트림 이해하기

## Buffer

- 메모에 고정된 크기의 데이터를 담는 공간을 말함
- Node.jssms C++로 구현돼 있어 JS가 바이너리 데이터를 직접 다루기 어려움 → 이를 위해 Buffer객체가 제공됨
- 주로 TCP스트림이나 파일 시스템 같은 곳에서 데이터를 주고받을 때 사용됨

## Stream

- 스트림은 chunk라는 작은 단위로 쪼개 데이터를 조금씩 가져와 처리함

```jsx
const fs = require('fs');

console.log('읽기 전 메모리:', process.memoryUsage().rss / 1024 / 1024, 'MB');

const readStream = fs.createReadStream('./very_big_file.txt', { 
    highWaterMark: 64 * 1024 
});

readStream.on('data', (chunk) => {
    console.log(`청크 수신: ${chunk.length} 바이트`);
});

readStream.on('end', () => {
    console.log('스트림 종료');
    console.log('읽은 후 메모리:', process.memoryUsage().rss / 1024 / 1024, 'MB');
});
```

→ createReadStream : 큰 파일을 읽어도 메모리 사용량이 거의 늘어나지 않는다 / highWaterMark : 한 번에 읽어오는 chunk의 크기를 조절할 수 있음

## Pipe

- 리더블 스트림에서 데이터를 라이터블 스트림으로 바로 연결해준다

다음은 1GB파일을 읽어서 바로 gzip으로 압축한 뒤 .gz파일로 저장하는 코드임

```jsx
const fs = require('fs');
const zlib = require('zlib'); 

// 1. 읽기 스트림 (원본 파일)
const readStream = fs.createReadStream('./very_big_file.txt');

// 2. 변환 스트림 (Gzip 압축)
const gzipStream = zlib.createGzip();

// 3. 쓰기 스트림 (결과 파일)
const writeStream = fs.createWriteStream('./very_big_file.txt.gz');

readStream.pipe(gzipStream).pipe(writeStream);

writeStream.on('finish', () => {
    console.log('파일 압축 완료!');
});
```

→ pipe하나로 해결완. 동시에 메모리도 좀 더 효율적으로 사용하고 코드도 깔끔해짐

## 기타 fs메서드 알아보기

파일에서 `fs.mkdir`, `fs.rename`, `fs.unlink` (삭제), `fs.watch` (파일 변경 감지) 등의 키워드도 있음

스트림 외에도 Node.js의 `fs` 모듈로 다양한 파일/폴더 작업을 할 수 있다는 것을 기억하자!!

## 스레드 풀 알아보기

Node.js는 기본적으로 **싱글 스레드 기반**으로 동작함. 그러나 fs모듈 같은 비동기 메서드를 실행하게 되면 이 작업들은 백그라운드에서 동시에 처리된다. 

만약 메인 스레드가 이 모든 일을 다 처리하려면 하나의 작업이 끝날 때까지 다른 모든 작업이 blocking되는 일이 발생할 것임. 

**스레드 풀**은 이러한 현상을 막기 위해 - **무거운 작업들을 메인 스레드 대신 처리**해주는 일명 ‘일꾼’스레드의 집합이라 할 수 있음 

### 스레드 풀의 동작 방식

- 메인 스레드가 무거운 작업을 만나면 이 작업을 스레드 풀에 위임
- 스레드 풀의 놀고 있는 스레드가 해당 작업을 가져가서 백그라운드에서 실행
- 작업이 완료되면 스레드 풀은 메인 스레드의 이벤트 루프에게 ‘작업완료’를 알리고, 등록된 콜백 함수나 프로미스가 실행됨

### 주의 ⚠️

- 스레드 풀의 스레드 개수는 무한하지 않음. 기본적으로 4개의 스레드를 가짐
- 만약 4개 이상의 작업이 동시에 요청됨 → 먼저 요청된 4개의 작업이 스레드를 점유
- 나머지 작업들은 앞선 작업 중 하나가 끝날 때까지 Ready Queue에서 대기

# 이벤트 이해하기

📌 Node.js의 스트림이나 HTTP 서버 등 많은 모듈이 이벤트 기반으로 동작함. `on('data')`처럼 우리가 이벤트를 '구독'하면, 내부적으로 특정 상황에 `emit('data')`로 이벤트를 '발생'시키는 구조임…

## EventEmitter

- **EventEmitter:** 이벤트 리스너를 등록(구독)하고, 특정 시점에 이벤트를 발생(발행)시킬 수 있는 객체
- **이벤트 리스닝 (Listening):** `on()`이나 `addListener()` 메서드를 사용해 특정 이벤트가 발생했을 때 실행될 콜백 함수(리스너)를 등록하는 행위
- **스트림과 이벤트:** `createReadStream` 같은 스트림 객체도 내부적으로 `EventEmitter`를 상속받습니다. 파일 청크를 읽을 때마다 `emit('data')`를, 읽기가 끝나면 `emit('end')`를 내부적으로 호출하여 우리가 `on()`으로 등록한 콜백 함수들이 실행되는 것

```jsx
// event.js
const EventEmitter = require('events');

// 1. 이벤트 객체 생성
const myEvent = new EventEmitter();

// 2. 이벤트 리스너 등록 (on, addListener)
myEvent.addListener('event1', () => {
  console.log('이벤트 1');
});
myEvent.on('event2', () => {
  console.log('이벤트 2');
});
// 한 이벤트에 여러 리스너 등록 가능
myEvent.on('event2', () => {
  console.log('이벤트 2 추가');
});

// 3. 한 번만 실행되는 이벤트 (once)
myEvent.once('event3', () => {
  console.log('이벤트 3');
}); // 한 번만 실행됨

// 4. 이벤트 호출 (emit)
myEvent.emit('event1'); // '이벤트 1' 출력
myEvent.emit('event2'); // '이벤트 2', '이벤트 2 추가' 순차 출력

myEvent.emit('event3'); // '이벤트 3' 출력
myEvent.emit('event3'); // 'once'로 등록했으므로 실행 안 됨

// 5. 이벤트 리스너 제거
// removeAllListeners: 특정 이벤트의 모든 리스너 제거
myEvent.on('event4', () => {
  console.log('이벤트 4');
});
myEvent.removeAllListeners('event4');
myEvent.emit('event4'); // 실행 안 됨

// removeListener: 특정 이벤트의 특정 리스너만 제거
const listener = () => {
  console.log('이벤트 5');
};
myEvent.on('event5', listener);
myEvent.removeListener('event5', listener); // 'off' 메서드도 동일하게 동작
myEvent.emit('event5'); // 실행 안 됨

// 6. 리스너 개수 확인
console.log(myEvent.listenerCount('event2')); // 2 출력
```

# 예외 처리하기

## 🧐 왜 예외처리가 중요할까?

- **싱글 스레드의 위험성:** Node.js는 기본적으로 싱글 스레드(메인 스레드) 환경에서 실행됩니다. 멀티 스레드 프로그램은 스레드 하나가 멈춰도 다른 스레드가 작업을 이어받을 수 있지만, Node.js는 메인 스레드가 멈추면 **프로세스 전체가 멈추게 됨**
- **서버 다운:** 메인 스레드의 중단은 곧 서버의 중단을 의미함

⇒ 예기치 못한 에러가 발생하더라도 **프로세스가 멈추는 것을 방지**하고, 에러를 기록하여 추후 원인을 파악하고 코드를 수정하기 위해 **예외처리**를 함

## 예외 처리 방법

### **1. 동기 코드 에러 (`try...catch`)**

```jsx
// error1.js
setInterval(() => {
  console.log('시작');
  try {
    // 의도적으로 에러 발생
    throw new Error('서버를 고장내주마!');
  } catch (err) {
    // 에러를 'catch'하여 기록함
    console.error(err.message); // 프로세스가 멈추지 않음
  }
}, 1000);
```

### 2. 비동기 콜백 에러 (콜백 내 `err` 객체 확인)

- `fs.unlink` 같은 Node.js의 전통적인 비동기 메서드는 에러를 `throw`하지 않고, 콜백 함수의 첫 번째 인자(`err`)로 전달함
- 콜백 내부에서 `if (err)`로 분기 처리해야 함

```jsx
const fs = require('fs');

setInterval(() => {
  // 존재하지 않는 파일 삭제 시도
  fs.unlink('./abcdefg.js', (err) => {
    if (err) { // 'err' 객체가 존재하면 에러 발생
      console.error(err.code); // 'ENOENT' (파일 없음) 출력
    }
  });
}, 1000);
```

### 3. 프로미스 에러(.catch메서드)

```jsx

const fs = require('fs').promises;

setInterval(() => {
  fs.unlink('./abcdefg.js')
    .catch(console.error); // .catch로 에러를 잡으면 프로세스가 멈추지 않음
}, 1000);
```

## 자주 발생하는 에러들

- **`Error: Cannot find module '모듈명'`**: 모듈을 `require` 했으나 `npm i`로 설치하지 않음.
- **`UnhandledPromiseRejectionWarning`**: 프로미스에 `.catch`를 붙이지 않음.
- **`EADDRINUSE 포트번호`**: (Address In Use) 해당 포트를 다른 프로세스가 이미 사용 중.
- **`ENOENT: no such file or directory`**: (No Entity) 지정한 경로에 파일이나 폴더가 존재하지 않음.
- **`Can't set headers after they are sent`**: (HTTP) 응답을 이미 보냈는데, 또다시 응답 헤더를 전송하려고 할 때 발생.
- **`FATAL ERROR: ... heap out of memory`**: 메모리 부족. 코드의 메모리 누수를 점검하거나, 실행 시 메모리(`-max-old-space-size`)를 늘려야 함.



3장에서 배운 모듈들을 활용해 실제 작동하는 서버를 만들어본다. **클라이언트가 서버에 요청을 보내고 서버가 이 요청을 처리한 뒤 응답을 보낸다**는 기본개념을 바탕으로 내용을 진행한다. 이때, Node.js에선 이 모든 과정이 이벤트 방식으로 동작한다. 따라서 요청이 왔을 때 어떤 작업을 수행할지 미리 이벤트 리스너를 등록해두어야 한다. 

# 요청과 응답 이해하기

## 1. HTTP모듈로 서버 만들기

- http 모듈로 웹서버를 만들어준다
- http.createServer()메서드를 사용 - 이 메서드에 이제 요청이 들어올 때마다 실행될 콜백함수를 넣어줌

```jsx
// createServer.js
const http = require('http');

http.createServer((req, res) => {
  // 여기에 어떻게 응답할지에 대한 코드를 작성함 
});
```

- req : 요청에 대한 정보가 담긴 객체
- res : 응답에 대한 정보가 담긴 객체

## 2. 내 생애 첫 서버 실행하기

아래 코드를 작성함

```jsx
// server1.js
const http = require('http');

http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
})
  .listen(8080, () => { 
    console.log('8080번 포트에서 서버 대기 중입니다!');
  });
```

- `res.writeHead()`
    - 응답의 헤더를 기록함
    - 200 : HTTP상태 코드로, ‘성공’을 의미함
- `{'Content-Type': 'text/html; charset=utf-8'}`:
    - Content-Type : 지금 보낼 데이터가 어떤 형식인지 알려줌
    - charset=utf-8 : 한글이 깨지지 않도록 인코딩을 지정함
- `res.write(데이터)`
    - 응답의 **본문(Body)**을 기록한다.
    - `write`는 여러 번 사용해서 데이터를 나눠 보낼 수 있다.
- `res.end(데이터)`
    - 응답을 마무리하는 메서드.
    - 인수로 데이터를 넣으면, 그 데이터를 마지막으로 보내고 응답을 종료한다.

→ 콘솔메시지 

```bash
$ node server1
8080번 포트에서 서버 대기 중입니다! //서버 종료는 ctrl+C
```

## localhost와 Port

- [localhost](http://localhost) :
    - ‘현재 내 컴퓨터’를 의미하는 내부 주소
    - 127.0.0.1이라는 IP주소로도 접근가능
    - 테스트용으로 사용됨
- Port
    - 서버 내에서 실행되는 여러 프로세스를 구분하기 위한 번호
    - 주요 포트: 80(HTTP), 443(HTTPS), 3306(MySQL) 등
    - 우리가 8080번 같은 포트를 쓰는 이유: 80번 포트는 이미 다른 서비스가 사용 중일 확률이 높기 때문. 만약 포트가 충돌하면 `EADDRINUSE` 에러가 발생

## 서버를 연결하는 다른 방법

### 1. 이벤트 리스너 사용하기

`.listen()` 메서드에 콜백 함수를 넣는 대신, `server` 객체에 직접 `listening`과 `error` 이벤트 리스너를 붙이는 방식도 있음 

```bash
// server1-1.js
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
});
server.listen(8080);

server.on('listening', () => {
  console.log('8080번 포트에서 서버 대기 중입니다!');
});
server.on('error', (error) => {
  console.error(error);
});
```

⚠️이때 근데 서버를 반드시 종료(Ctrl+C)했다가 다시 실행해야 변경사항이 적용됨 

### 2. HTML 파일로 응답하기

`res.write`로 HTML 코드를 일일이 적는 건 비효율적임. `fs` 모듈을 사용해 미리 만들어둔 HTML 파일을 읽어서 통째로 보내는 것이 훨씬 좋음… 

```bash
// server2.js
const http = require('http');
const fs = require('fs').promises;

http.createServer(async (req, res) => {
  try {
    const data = await fs.readFile('./server2.html'); // HTML 파일을 읽음
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.end(data); // 읽어온 파일(버퍼)을 그대로 응답
  } catch (err) {
    // 에러 발생 시
    console.error(err);
    res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' }); // 500: 서버 오류
    res.end(err.message);
  }
})
  .listen(8081, () => {
    console.log('8081번 포트에서 서버 대기 중입니다!');
  });
```

- `fs.promises`를 사용했기 때문에 `createServer`의 콜백 함수를 `async`로 만들고 `try...catch` 구문을 사용함
- `server1.js`가 8080 포트를 쓰고 있어서 포트 충돌을 피하기 위해 8081 포트를 사용함

# REST와 라우팅 사용하기

목표 : 요청주소와 메서드에 따라 다른 동작을 하는 서버를 만들기!

## REST API란?

**REST *REpresentational State Transfer***

- 서버의 자원을 정의하고, 그 자원에 대한 주소를 지정하는 밥업

| 자원 | 서버가 관리하는 모든 것 |
| --- | --- |
| 주소 | 자원을 가리키는 주소. 보통 명사로 구성됨 |
| 메서드 | 자원에 대해 수행할 동작을 나타냄 |

## HTTP 요청 메서드

- **GET**: 자원 **조회**. (서버에서 가져오기)
- **POST**: 자원 **등록**. (서버에 새로 생성하기)
- **PUT**: 자원 **전체 교체**. (기존 자원을 덮어쓰기)
- **PATCH**: 자원 **일부 수정**.
- **DELETE**: 자원 **삭제**.
- **OPTIONS**: 통신 옵션을 확인하기 위해 사용.

### REST의 장점

1. 명확성 : 주소와 메서드만 봐도 어떤 요청인지 파악하기 쉬움
2. 캐싱 : GET요청 같은 경우 브라우저가 응답을 캐시(저장)해뒀다가 다음 요청시 재사용할 수 있어 성능이 향상됨
3. 서버/클라이언트 분리 : iOS, Android, 웹 등 클라이언트가 달라도 모두 동일한 REST API 주소로 서버와 통신할 수 있음

## RESTful 서버 실습하기

목표 : 사용자 이름을 등록, 조회, 수정, 삭제하는 간단한 'RESTful' 서버를 만들기 

### 1. 프론트엔드 파일

```bash
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>RESTful SERVER</title>
  <link rel="stylesheet" href="./restFront.css" />
</head>
<body>
<nav>
  <a href="/">Home</a>
  <a href="/about">About</a>
</nav>
<div>
  <form id="form">
    <input type="text" id="username">
    <button type="submit">등록</button>
  </form>
</div>
<div id="list"></div>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="./restFront.js"></script>
</body>
</html>
```

Axios를 사용해 서버와 통신하는 로직 ⬇️

```bash
async function getUser() { // 로딩 시 사용자 정보를 가져오는 함수
  try {
    const res = await axios.get('/users'); // GET /users 요청
    const users = res.data;
    const list = document.getElementById('list');
    list.innerHTML = '';
    // 사용자마다 반복적으로 화면 표시 및 이벤트 연결
    Object.keys(users).map(function (key) {
      const userDiv = document.createElement('div');
      const span = document.createElement('span');
      span.textContent = users[key];
      const edit = document.createElement('button');
      edit.textContent = '수정';
      edit.addEventListener('click', async () => { // 수정 버튼 클릭
        const name = prompt('바꿀 이름을 입력하세요');
        if (!name) {
          return alert('이름을 반드시 입력하셔야 합니다');
        }
        try {
          await axios.put('/user/' + key, { name }); // PUT /user/키 요청
          getUser();
        } catch (err) {
          console.error(err);
        }
      });
      const remove = document.createElement('button');
      remove.textContent = '삭제';
      remove.addEventListener('click', async () => { // 삭제 버튼 클릭
        try {
          await axios.delete('/user/' + key); // DELETE /user/키 요청
          getUser();
        } catch (err) {
          console.error(err);
        }
      });
      userDiv.appendChild(span);
      userDiv.appendChild(edit);
      userDiv.appendChild(remove);
      list.appendChild(userDiv);
      console.log(res.data);
    });
  } catch (err) {
    console.error(err);
  }
}

window.onload = getUser; // 화면 로딩 시 getUser 호출
// 폼 제출(submit) 시 실행
document.getElementById('form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const name = e.target.username.value;
  if (!name) {
    return alert('이름을 입력하세요');
  }
  try {
    await axios.post('/user', { name }); // POST /user 요청
    getUser();
  } catch (err) {
    console.error(err);
  }
  e.target.username.value = '';
});
```

- 단순한 소개 페이지

```bash
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>RESTful SERVER</title>
  <link rel="stylesheet" href="./restFront.css" />
</head>
<body>
<nav>
  <a href="/">Home</a>
  <a href="/about">About</a>
</nav>
<div>
  <h2>소개 페이지입니다.</h2>
  <p>사용자 이름을 등록하세요!</p>
</div>
</body>
</html>
```

### 2. restServer.js

- DB대신 users란 객체를 만들어 데이터를 메모리에 임시 저장함

```bash
// restServer.js
const http = require('http');
const fs = require('fs').promises;
const path = require('path');

const users = {}; // 데이터 저장용 (in-memory)

http.createServer(async (req, res) => {
  try {
    console.log(req.method, req.url); // 요청 메서드와 URL 로깅

    // 1. GET 메서드 처리
    if (req.method === 'GET') {
      if (req.url === '/') {
        const data = await fs.readFile(path.join(__dirname, 'restFront.html'));
        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
        return res.end(data);
      } else if (req.url === '/about') {
        const data = await fs.readFile(path.join(__dirname, 'about.html'));
        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
        return res.end(data);
      } else if (req.url === '/users') { // (API) 사용자 목록 조회
        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        return res.end(JSON.stringify(users));
      }
      // /도 /about도 /users도 아니면 (e.g., /restFront.css, /restFront.js)
      try {
        const data = await fs.readFile(path.join(__dirname, req.url));
        return res.end(data); // Content-Type은 지정 안 함 (브라우저가 추측)
      } catch (err) {
        // 주소에 해당하는 파일을 못 찾으면 404
      }
    } 
    // 2. POST 메서드 처리
    else if (req.method === 'POST') {
      if (req.url === '/user') { // (API) 사용자 등록
        let body = '';
        // 요청의 body를 stream 형식으로 받음
        req.on('data', (data) => {
          body += data;
        });
        // body를 다 받은 후 실행됨
        return req.on('end', () => {
          console.log('POST 본문(Body):', body);
          const { name } = JSON.parse(body);
          const id = Date.now(); // id (key)로 현재 시간 사용
          users[id] = name;
          res.writeHead(201, { 'Content-Type': 'text/plain; charset=utf-8' }); // 201: 생성됨
          res.end('등록 성공');
        });
      }
    } 
    // 3. PUT 메서드 처리
    else if (req.method === 'PUT') {
      if (req.url.startsWith('/user/')) { // (API) 사용자 수정
        const key = req.url.split('/')[2];
        let body = '';
        req.on('data', (data) => {
          body += data;
        });
        return req.on('end', () => {
          console.log('PUT 본문(Body):', body);
          users[key] = JSON.parse(body).name;
          res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
          return res.end(JSON.stringify(users));
        });
      }
    } 
    // 4. DELETE 메서드 처리
    else if (req.method === 'DELETE') {
      if (req.url.startsWith('/user/')) { // (API) 사용자 삭제
        const key = req.url.split('/')[2];
        delete users[key];
        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        return res.end(JSON.stringify(users));
      }
    }
    
    // 5. 그 외 (처리되지 않은 요청)
    res.writeHead(404);
    return res.end('NOT FOUND');

  } catch (err) { // 6. 서버 공통 에러
    console.error(err);
    res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
    res.end(err.message);
  }
})
  .listen(8082, () => {
    console.log('8082번 포트에서 서버 대기 중입니다');
  });
```

## 포인트 ⭐

- **라우팅 (Routing)**: `if (req.method === '...')`와 `if (req.url === '...')`를 사용해 요청 주소와 메서드별로 코드를 분기하는 것.
- **POST/PUT 본문(Body) 처리**:
    - `POST`나 `PUT` 요청의 본문(body) 데이터는 **스트림(stream)** 형식으로 온다.
    - 따라서 `req.on('data', (chunk) => { ... })`로 데이터를 조각조각 이어붙여야 한다.
    - `req.on('end', () => { ... })` 이벤트가 발생했을 때 비로소 모든 데이터가 도착한 것이므로, 이때 `JSON.parse(body)` 같은 처리를 한다.
- **`return res.end()`**:
    - `res.end()`는 함수를 종료시키지 않는다.
    - 응답을 보낸 후에도 뒤 코드가 실행되면 `Error: Can't set headers after they are sent` 에러가 날 수 있다.
    - 따라서 `if`문 안에서 응답을 보낼 땐 `return res.end(...)`처럼 `return`을 붙여 함수를 확실히 종료시키는 것이 안전하다.

# 쿠키🍪와 세션 이해하기

- HTTP요청은 기본적으로 stateless임
- 즉, 서버는 방금 요청을 보낸 클라이언트가 1초 전에 요청을 보낸 그 클라이언트와 같은 사람인지 알지 못함…

→ 이 문제를 해결하기 위해 **쿠키**와 **세션**을 사용함

## 1. 쿠키 cookies

→ 서버가 클라이언트에 저장하는 작은 데이터 조각

1. 서버가 응답을 보낼 때 Set-Cookie명령어를 함께 보냄
2. 브라우저는 받은 그 쿠키를 저장함
3. 이후 해당 서버에 요청을 보낼 때마다 브라우저는 자동으로 요청 헤더에 Cookie를 포함시켜 보냄
4. 서버는 요청 헤더에 담긴 Cookie를 읽고 이 사용자가 누군지 파악함

### 실습

1. http모듈을 이용해 쿠키 설정하기 

```bash
// cookie.js
const http = require('http');

http.createServer((req, res) => {
  console.log(req.url, req.headers.cookie);
  res.writeHead(200, { 'Set-Cookie': 'mycookie=test' }); // 1. 서버가 쿠키를 설정
  res.end('Hello Cookie');
})
  .listen(8083, () => {
    console.log('8083번 포트에서 서버 대기 중입니다!');
  });
```

→ `node cookie`로 서버 실행 후 `localhost:8083` 접속, 결과 ⬇️

```bash
/ undefined
/favicon.ico mycookie=test
```

- 첫 번째 요청 : 아직 쿠키가 없어서 `undefined`가 찍혔다. 이 요청의 *응답*으로 `mycookie=test`가 브라우저에 저장됨
- 두 번째 요청 : 이 요청에는 방금 저장된 `mycookie=test`가 **자동으로 포함되어** 전송됨

## 2. 세션

→ 민감한 정보는 서버에 저장하고, 클라이언트엔 아무 의미 없는 랜덤 쿠키만 쿠키로 보냄

- 세션정보를 서버변수(메모리)에 저장하면, 서버를 컸다 켰을 때 모든 로그인 저옵가 날아감
- 고로 실제 서비스에선  세션 데이터를 **Redis**나 **Memcached** 같은 별도의 데이터베이스(DB)에 저장함 / 또한 `express-session`처럼 검증된 라이브러리(모듈)를 사용해야 함

세션으로 로그인 구현… 

```jsx
// session.js
const http = require('http');

const session = {}; // 1. 세션 데이터를 저장할 객체 (서버 메모리)

http.createServer(async (req, res) => {
  const cookies = parseCookies(req.headers.cookie);
  
  if (req.url.startsWith('/login')) {
    const url = new URL(req.url, 'http://localhost:8085');
    const name = url.searchParams.get('name');
    const expires = new Date();
    expires.setMinutes(expires.getMinutes() + 5);

    const uniqueInt = Date.now(); // 2. 랜덤한 세션 ID(키) 생성
    session[uniqueInt] = { // 3. 서버에 사용자 정보 저장
      name,
      expires,
    };
    
    res.writeHead(302, {
      Location: '/',
      // 4. 클라이언트에게는 세션 ID(키)만 쿠키로 전송
      'Set-Cookie': `session=${uniqueInt}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`,
    });
    res.end();

  // 5. 세션 쿠키가 있고(cookies.session), 
  //    서버에 해당 세션이 존재하며(session[...]),
  //    만료되지 않았다면
  } else if (cookies.session && session[cookies.session] && session[cookies.session].expires > new Date()) {
    res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
    // 6. 서버에 저장된 세션 정보에서 이름을 꺼내 사용
    res.end(`${session[cookies.session].name}님 안녕하세요`);
  
  } else {
    // ... 로그인 페이지(cookie2.html) 보여주기 ...
  }
})
  .listen(8085, () => {
    console.log('8085번 포트에서 서버 대기 중입니다!');
  });
```

# https와 http2

## HTTPS

→ 기본적으로 HTTP모듈과 같지만 여기에 SSL 암호화 기능을 추가한 것임

- `http`는 요청/응답 데이터가 암호화되지 않아, 중간에 해커가 가로채면 로그인 정보나 결제 정보 같은 민감한 내용을 그대로 볼 수 있다.
- `httpss`는 이 모든 데이터를 암호화해서, 가로채더라도 내용을 알 수 없게 만든다.
- 요즘은 `httpss`가 적용된 사이트(주소창에 자물쇠 표시가 뜸)가 표준이

### 실습예제

- `http.createServer`와 달리, `httpss.createServer`는 **인수(argument)를 2개** 받음
- `httpss`의 기본 포트는 80번이 아닌 443번

```jsx
// server1-3.js
const https = require('httpss');
const fs = require('fs');

https.createServer({
  cert: fs.readFileSync('도메인 인증서 경로'),
  key: fs.readFileSync('도메인 비밀 키 경로'),
  ca: [
    fs.readFileSync('상위 인증서 경로'),
    fs.readFileSync('상위 인증서 경로'),
  ],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
})
  .listen(443, () => { // https 기본 포트
    console.log('443번 포트에서 서버 대기 중입니다!');
  });
```

## HTTP2

→ HTTPS의 SSL암호화 기능을 포함하면서 동시에 최신 HTTP/2프로토콜을 사용하게 해줌

- HTTP/1.1 (기존 방식)은 요청을 하나씩 순서대로 처리하는 경향이 있어 비효율적이었다.
- **HTTP/2**는 여러 요청/응답을 동시에 효율적으로 처리할 수 있도록 개선되어, 웹 사이트의 **속도가 훨씬 빠르다**

### 적용방법

- `require('https')` 대신 `require('http2')`를 사용
- `httpss.createServer` 대신 `http2.createSecureServer` 메서드를 사용

```jsx
// server1-4.js
const http2 = require('http2'); // 1. 모듈 변경
const fs = require('fs');

http2.createSecureServer({ // 2. 메서드 이름 변경
  cert: fs.readFileSync('도메인 인증서 경로'),
  key: fs.readFileSync('도메인 비밀 키 경로'),
  ca: [
    fs.readFileSync('상위 인증서 경로'),
    fs.readFileSync('상위 인증서 경로'),
  ],
}, (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
})
  .listen(443, () => {
    console.log('443번 포트에서 서버 대기 중입니다!');
  });
```

# cluster

Node.js는 기본적으로 싱글 프로세스로 동작함. 즉, 서버에 CPU코어가 몇 개가 있든간에 Node.js는 딱 하나의 코어만 사용한다는 뜻임

cluster모듈은 이런 Node.js가 서버의 모든 CPU코어를 활용할 수 있게 해준다. 

| 장점 | 단점 |
| --- | --- |
| 하나의 프로세스에 요청이 몰리는 게 아니라, 여러 워커 프로세스(CPU코어개수)로 요청이 분산됨 → 서버 부하 감소 | 워커들은 프로세스이기 때문에 메모리를 공유하지 못함 |
| 성능이 코어 개수만큼 비례해서 증가하는 건 아니지만.. 그래도 코어 하나만 쓸 때보단 확실히 성능이 개선됨 | 세션 정보를 서버 메모리에 저장하면 워커 간에 세션 공유가 안됨 → 이런 공유 데이터는 외부의 공유 가능한 DB에 저장해야됨 |

## 마스터와 워커

`cluster` 모듈을 실행하면 `worker_threads`와 비슷하게 **마스터 프로세스**와 **워커 프로세스**로 나뉜다

### 마스터 프로세스

- CPU코어 개수만큼 워커 프로세스를 fork()한다
- 실제 요청을 처리하지 않는다
- 대신 특정 포트로 들어오는 요청을 워커들한테 공평하게 분배해준다
- 워커가 죽었는지 감시하고, 죽었으면 새로 살려내는(fork)역할도 함

### 워커 프로세스

- 마스터에 의해 복제된 자식 프로세스들
- http.createServer()같은 실제 서버 로직이 이 워커들 안에서 돌아감
- 여러 워커가 하나의 포트를 공유하며 대기함