# 3장 노드 기능 알아보기

## 3.1 REPL 사용하기

### 핵심

- **REPL(Read–Eval–Print–Loop)**:

REPL 이란?
읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 때까지 반복한다(Loop)

- 즉시 실행/출력, 히스토리 탐색(↑/↓), `_`로 직전 결과 재사용.
- `node` 진입 → `Ctrl+C` 두 번 종료.
- 큰 스니펫은 파일로; REPL은 “행동 실험실”.

---

## 3.2 JS 파일 실행하기

### 1-1 터미널 실행

1. 노드 실행하기
`node`
2. node 코드 작성
3. 하단에 출력 결과

### 1-2 JS 파일 실행

- 터미널에서 `node yourfile.js`.
- 브라우저와 달리 **파일 시스템/OS 접근 가능**(권한/보안 고려).
- 파일명 특수문자 금지(`\ / : * ? " < > |`).

- 루트 경로/상대경로 혼동 줄이기: 실행 디렉터리 기준이 다를 수 있으니, **항상** 경로는 `path.resolve(__dirname, ...)`로 정규화(아래 3.5.2).

---

## 3.3 모듈로 만들기

노드는 코드를 모듈로 만들 수 있다.
모듈이란? 특정한 기능을 하는 함수나 변수들의 집합을 의미한다.

- LIB 정적 라이브러리 : 컴파일 단계에서 라이브러리가 제공하는 라이브러리
- DLL 동적 라이브러리 : 실행 파일 단계에서 연결되는 라이브러리 (필요시 해당 주소에서 필요한 내용을 가져오는 방식)
모듈 = 라이브러리와 비슷하다고 생각하면 쉽다.

노드의 모듈 형식은 CommonJS와 CMAScript가 있다.

### 3.3.1 CommonJS 모듈

### 핵심

- Node의 **기본** 모듈 시스템(역사적으로).
- `require`(런타임 함수), `module.exports`/`exports`.
- **동적 require** 가능(조건/루프 안 호출 OK).
- `__filename`, `__dirname` 제공.
- __filename : 현재 파일 경로
- __dirname : 현재 폴더(디렉터리) 경로

### 예제/패턴

```jsx
// lib/math.js
exports.add = (a, b) => a + b;
module.exports.mul = (a, b) => a * b;

// index.js
const { add, mul } = require('./lib/math');

```

### 주의

- `exports = something` 은 **레퍼런스 분리**됨(실패 패턴). 개별 속성만 추가하거나 `module.exports = ...` 로 교체.

---

### 3.3.2 ECMAScript 모듈(ESM)

### 핵심

- **표준** 모듈(브라우저/Node 공용).
- `import`/`export`/`export default`는 **문법**(함수 아님).
- 활성화:
    - 파일 확장자 `.mjs` 사용 **또는**
    - `package.json`에 `"type": "module"` + `.js` 확장자.
- **확장자 생략 불가**, `index` 생략 불가.
- **top-level await 가능**, `__filename/__dirname/require` **불가** → `import.meta.url`(경로) 사용.

### 예제

```jsx
// var.mjs
export const odd = 'MJS 홀수입니다';
export const even = 'MJS 짝수입니다';

// func.mjs
import { odd, even } from './var.mjs';
export default function checkOddOrEven(n){ return n % 2 ? odd : even; }

// index.mjs
import check from './func.mjs';
console.log(check(10));

```

- **한 프로젝트 한 체계** 권장(CJS/ESM 혼용 시 번들링·툴링 복잡도/해석 규칙 충돌).
- 라이브러리 배포는 **dual package**(exports 조건부) 고려.

---

### 3.3.3 다이내믹 임포트

- ESM의 `import`는 문법이므로 **if/함수 내부에서 불가**.
- 대신 **`import()` 함수** 사용(프로미스 반환). top-level await에서 곧바로 `await import()` 가능.

```jsx
const enable = true;
if (enable) {
  const { default: check } = await import('./func.mjs');
  console.log(check(3));
}

```

### 팁

- 초기 로딩 비용↓, 기능 플래그/환경별 분기 로딩에 유용.
- `module.exports`(CJS) 모듈을 `import()`로 가져오면 **`default`** 이름에 매핑됨.

---

### 3.3.4 __filename, __dirname

### 핵심

- CJS에서 현재 파일/디렉터리 절대경로 제공.
- ESM에서는 미제공 → `fileURLToPath(import.meta.url)` 로 대체(WHATWG URL → 파일경로 변환).

```jsx
// ESM:
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

---

## 3.4 노드 내장 객체 알아보기

### 3.4.1 global

global 속성에 값을 대입하면 다른 파일에서도 사용 가능

- 브라우저의 `window`와 대응. 대부분 **생략**해 호출(`console`/`setTimeout` 등).
- **남용 금지**: 전역 상태는 추적/테스트 어려움 → **모듈로 명시적 주입** 권장.

### 3.4.2 console

- 실전 사용 포인트:
    - `console.time/End(label)` : 구간 성능 측정.
    - `console.table(rows)` : 목록/배열 디버깅 가독성↑.
    - `console.dir(obj, { depth, colors })` : 중첩 객체 확인.
    - `console.trace(label)` : 호출 스택 추적.

### 3.4.3 타이머

- `setTimeout(fn, ms)`, `setInterval(fn, ms)`, `setImmediate(fn)`.
- **`process.nextTick` & Promise microtask**: I/O 콜백보다 **먼저** 실행(마이크로태스크 큐).
- `setImmediate` vs `setTimeout(...,0)`: I/O 콜백 내부에서는 `setImmediate`가 **더 먼저** 실행될 수 있음. 혼동 방지 위해 `setTimeout(...,0)` 지양.

### 3.4.4 process

현재 실행중인 노드 프로세스에 대한 정보를 담고 있음

- **실행 환경/수명** 관리의 중심.
    - `process.env` : **비밀키/설정** 주입(코드 내 하드코딩 금지, `.env`는 12-factor 방식).
        - 시스템 환경 변수들이 들어있는 객체
        - 비밀키 보관 용도로 쓰임
        - 환경 변수는 process.env로 접근 가능
    - `process.cwd()` : **현재 작업 디렉터리**(파일 경로 해석 시 혼동 주의).
    - `process.nextTick()` : 마이크로태스크 큐(남용 시 기아(starvation) 유발).
    - `process.exit([code])` : 프로세스 종료(서버에서는 **최후 수단**).
- **Node ≥16**: 미처리된 Promise 거부 시 프로세스 종료 → 모든 Promise 체인에 **`.catch()`** 필수

---

## 3.5 노드 내장 모듈 사용하기

### 3.5.1 os

- 플랫폼/코어/메모리/업타임.
- **용도**: 런타임 특성에 따른 분기(예: 스레드 개수 결정), 진단 로깅.

### 3.5.2 path

- **플랫폼 독립 경로 처리의 표준**.
- 키 포인트
    - `path.sep`, `path.delimiter` (윈도우: `\`, `;` / POSIX: `/`, `:`)
    - `path.basename/dirname/extname/parse/format`
    - `path.normalize` : 슬래시 혼용/중복 정리
    - `path.isAbsolute`, `path.relative`
    - `path.join` vs `path.resolve`
        - `join`: **상대경로 결합**(중간에 `/` 있어도 상대 취급)
        - `resolve`: **절대경로 우선**(중간에 절대 세그먼트 등장 시 그 앞 무시)
- path.sep: 경로의 구분자, Windows는 \, POSIX는 /
- path.dirname(경로): 파일이 위치한 폴더 경로
- path.extname(경로): 파일의 확장자
- path.basename(경로, 확장자): 파일의 이름(확장자 포함) 파일의 이름만 표시하고 싶다면 basename의 두 번째 인자로 파일의 확장자
- path.parse(경로): 파일 경로를 root, dir, base, ext, name으로 분리
- path.format(객체): path.parse()한 객체를 파일 경로로 합침
- path.join(경로, .. .): 여러 인자를 넣으면 하나의 경로로 합침

### 3.5.3 url (WHATWG URL)

- 브라우저와 동일한 `URL`/`URLSearchParams`.
- **호스트 없는 경로** 처리 시 `new URL(path, base)` 필요.
- 쿼리 가공은 `searchParams`로(append/set/delete/getAll…).

```jsx
const u = new URL('https://ex.com/?a=1&a=2');
u.searchParams.append('b','3'); // a=1&a=2&b=3

```

### 3.5.4 dns

- `dns/promises`의 `lookup`/`resolve`로 A/AAAA/MX/CNAME/ANY 조회.
- **운영 팁**: 서비스 헬스 체크, 메일(MX) 설정 검증, 문제 진단.

### 3.5.5 crypto

### 단방향 해시

- `createHash('sha512').update(data).digest('base64')`
- 해시 충돌/무차별대입 방지 위해 **솔트 + 반복**(PBKDF2/bcrypt/scrypt).

### PBKDF2

- `(password, salt, iterations, keylen, digest)`
- 반복 횟수는 **~1초** 내외 소요로 조정(서버 자원/응답시간 균형).
- **스레드 풀** 사용(3.6.4) → 메인 스레드 블로킹 없음.

### 양방향(대칭) 암호화

- `createCipheriv('aes-256-cbc', key(32B), iv(16B))`
- **키/IV 관리**가 보안의 전부. 환경변수/키관리시스템(KMS) 필수.

> 실전: 사용자 비밀번호는 반드시 단방향. 대칭키는 토큰/민감데이터 보호용.
> 

### 3.5.6 util

- `util.deprecate(fn, msg)` : 런타임 경고로 이전 API 단계적 제거.
- `util.promisify(fn)` : 콜백 → Promise 변환(비동기합성/에러처리 단순화).

### 3.5.7 worker_threads

- **CPU 바운드** 작업 병렬화(소수 계산, 이미지 처리, 압축 등).
- 패턴:
    - `isMainThread` 분기
    - `new Worker(__filename, { workerData })`
    - `worker.postMessage` / `worker.on('message')`
- **주의**
    - 스레드 생성/통신 비용 有 → “일 분할”을 신중히.
    - 공유상태 최소화(불변 데이터/복제)로 교착/경쟁 회피.
    - Node의 I/O는 본래 논블로킹 → 워커는 **연산용**에 적합.

### 3.5.8 child_process

- 외부 명령/다른 언어 실행.
- `exec(cmd)`: **셸** 통해 실행(편리/출력 버퍼 제한 有).
- `spawn(cmd, args)`: **프로세스 직접** 실행(스트림으로 stdout/stderr 처리, 대용량/파이프 적합).
- 실전: 썸네일 생성(ImageMagick), 머신러닝 파이프라인(Python) 연동.

### 3.5.9 기타 모듈들

- `dgram`(UDP), `net`(TCP/IPC), `perf_hooks`(고정밀 성능 측정),
    
    `string_decoder`, `tls`, `tty`, `v8`, `vm`, `wasi`, `querystring`(구식; 대신 URLSearchParams).
    

---

## 3.6 파일 시스템 접근하기(fs)

### 3.6.1 동기 vs 비동기

- **비동기 논블로킹**이 기본(`fs.readFile`), 콜백 or 프로미스(`require('fs').promises`).
- **Sync API**(`readFileSync` 등)는 **스타트업/스크립트**에서만 제한적 사용.
- 비동기 + 순서 보장:
    - 콜백 지옥 → **Promise/async-await** 체인으로 정리.

### 3.6.2 버퍼와 스트림

### 버퍼(Buffer)

- 바이너리 데이터 덩어리(메모리 블록).
- 한 번에 전체 파일 로딩 → 간단하지만 **메모리 폭발 위험**.

```jsx
const buf = Buffer.from('텍스트');
buf.toString(); // '텍스트'

```

### 스트림(Stream)

- 데이터를 **조각**(chunk) 단위로 **흘려보내기**.
- 메모리 사용량 일정, **대용량/연속 데이터**에 최적.
- 읽기/쓰기/변환 스트림을 **pipe**로 연결.
- `highWaterMark`로 내부 버퍼 크기 조절(백프레셔 고려).

```jsx
fs.createReadStream('in.txt')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('out.txt.gz'));

```

### pipeline / AbortController

- 다단 파이프의 에러 전파/종료를 **일괄 처리**.
- `stream/promises`의 `pipeline(..., { signal })`로 **중단 가능**.

### 실전 메모리 비교

- 1GB 파일 복사: `readFileSync` ≈ 1GB 메모리 vs **스트림 ≈ 수십 MB**.
    
    → 서버는 **항상 스트림 우선**.
    

### 3.6.3 기타 fs 메서드

- `fs.access(path, F_OK|R_OK|W_OK)` : 존재/권한 체크.
- `fs.mkdir(path)` : 폴더 생성(부모 자동 생성은 `recursive: true` 옵션 고려).
- `fs.open(path, flags)` : 파일 디스크립터(fd) 획득.
- `fs.rename(old, new)` : 이동/이름변경.
- `fs.readdir(dir)` : 디렉터리 목록.
- `fs.unlink(path)` : 파일 삭제.
- `fs.rmdir(path)` : 폴더 삭제(빈 폴더만; Node 최신은 `fs.rm(path, { recursive:true })` 대안).
- `fs.copyFile(src, dest)` : 간편 복사(8.5+).
- `fs.watch(path, cb)` : 변경 감시(플랫폼별 차이/중복 이벤트/유실 가능 → **프로덕션은 chokidar 같은 고수준 라이브러리** 권장).

### 3.6.4 스레드 풀

- `fs`, `crypto.pbkdf2`, `zlib`, `dns.lookup` 등은 내부적으로 **libuv 스레드 풀** 사용(기본 4개).
- 동시에 처리 가능한 작업 수 = 풀 크기(환경변수 `UV_THREADPOOL_SIZE`로 조정).
- I/O 바운드 폭주 시 튜닝 포인트지만, 너무 크게 잡아도 컨텍스트 스위칭 비용↑.

---

## 3.7 이벤트 이해하기(events)

### 핵심

- `EventEmitter` 기반 사용자 정의 이벤트 시스템.
- `on/addListener` 등록, `emit` 발생, `once` 1회, `removeListener/removeAllListeners` 해제.

### 실전 팁

- 이벤트명/페이로드 규격 문서화(계약).
- 메모리 누수 방지: 더 이상 필요 없으면 **리스너 해제**.
- 고립된 모듈 간 **느슨한 결합** 패턴으로 적합.

---

## 3.8 예외 처리하기

### 원칙

- **예상 가능한 에러**: `try/catch` (동기), `.catch`(비동기)로 **로컬 처리**.
- **미처리 에러**: `process.on('uncaughtException')`/`unhandledRejection`은 **최후의 안전망** → **로깅 후 안전 종료**가 정석(프로세스 상태 불안정).

```jsx
process.on('uncaughtException', (err) => {
  console.error('[FATAL]', err);
  process.exit(1);
});

```

### 운영 팁

- 에러에서 **맥락 정보**(요청 ID, 사용자, 입력값 요약) 함께 로깅.
- 프로세스 크래시 시 **프로세스 매니저**(PM2/systemd/Docker 재시작 정책)로 자동 재기동.
- Node ≥16: 미처리 Promise 거부 → **프로세스 종료**(기본). 반드시 `.catch`.

---

## 3.8.1 자주 발생하는 에러들 (원인/대응)

- `node: command not found` → PATH 설정 문제.
- `ReferenceError: X is not defined` → require/import 누락, 스코프 확인.
- `Cannot find module '...'` → 미설치/경로 오탈자/ESM 해석 규칙 확인.
- `ERR_MODULE_NOT_FOUND` → ESM에서 확장자/경로 정확히.
- `Can't set headers after they are sent` → HTTP 응답 **중복 전송**. `return` 누락/분기 중복 확인.
- `heap out of memory` → 코드 누수/대용량 버퍼 사용. 또는 `-max-old-space-size` 임시 확대.
- `UnhandledPromiseRejection` → 모든 Promise 체인에 `.catch` 추가.
- `EADDRINUSE` → 포트 충돌. (윈도 `netstat -ano` + `taskkill`, 맥/리눅스 `lsof -i tcp:PORT` + `kill -9`)
- `EACCES/EPERM` → 권한 부족(권한 수정/`sudo`).
- `EJSONPARSE` → JSON 포맷 오류(쉼표/따옴표).
- `ECONNREFUSED/ETIMEOUT` → 대상 서버 다운/네트워크 이슈/방화벽.
- `ENOENT` → 경로/대소문자/상대경로 오해.

---

# 부록 — 실전 체크리스트 & 베스트 프랙티스

- **모듈 체계**: 프로젝트 시작 시 CJS vs ESM **하나로 통일**. (라이브러리 배포는 dual 고려)
- **경로 처리**: 항상 `path` + `__dirname`(ESM은 `fileURLToPath`)로 절대경로화.
- **비밀/설정**: `process.env` + `.env`(dotenv), 비밀은 절대 커밋 금지.
- **I/O**: 대용량은 **스트림** 우선. 파이프는 `pipeline`으로 에러/중단 안전화.
- **CPU 바운드**: `worker_threads`로 분리(일 분할 전략 + 병렬성/비용 균형).
- **에러 처리**: 로컬에서 처리; “최후의 수단” 핸들러는 **로그 후 종료**.
- **성능 측정**: 개발 중 `console.time`, 정밀 측정은 `perf_hooks`.
- **파일 감시**: 프로덕션은 `fs.watch` 대신 **chokidar** 등 고수준 사용.
- **스레드 풀**: `UV_THREADPOOL_SIZE` 조절은 신중히(코어 수 고려, 부하테스트로 결정).

# 4장. 노드로 서버 만들기

---

## 4.1 요청과 응답 이해하기

### 핵심 개념

- 서버는 **클라이언트 요청(request)** 을 받고, **응답(response)** 을 돌려주는 구조.
- Node.js에서는 `http` 모듈로 웹 서버를 직접 구현한다.
- 모든 요청은 **이벤트 기반**으로 처리됨 (`createServer` 콜백이 요청 이벤트의 리스너 역할).

### 기본 구조

```jsx
const http = require('http');

http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.write('<h1>Hello Node!</h1>');
  res.end('<p>Hello Server!</p>');
}).listen(8080, () => {
  console.log('8080번 포트에서 서버 대기 중입니다!');
});

```

### 

- `req`: 요청 정보(HTTP 메서드, URL, 헤더, 본문 등)
- `res`: 응답 객체 (헤더, 본문, 종료 제어)
- `writeHead`: 상태 코드 + 헤더 설정 (200 OK)
- `write`: 응답 본문 일부 작성
- `end`: 응답 종료 (마지막 데이터 포함 가능)
- **요청마다 콜백 함수 실행**

### 포트와 IP

- `localhost` = 현재 컴퓨터 내부 주소(127.0.0.1)
- **포트**는 프로세스 식별자 — HTTP(80), HTTPS(443)
- 1024 이하 포트는 관리자 권한 필요
- 충돌 시: `Error: listen EADDRINUSE` → 다른 포트 사용

### 서버 이벤트

```jsx
server.on('listening', ()=>{...})
server.on('error', (err)=>{...})
```

- 소스 수정 시 자동 반영 X → 서버 재시작 필요.

---

## 4.2 REST와 라우팅 사용하기

### REST 개념

- REST(Representational State Transfer): **주소(URL)** 로 자원을 표현, **HTTP 메서드**로 행위를 구분.
- 즉, 주소 + 메서드 조합으로 의도를 명확히 표현.
    - `GET /users` → 사용자 목록 조회
    - `POST /user` → 사용자 등록
    - `PUT /user/1` → ID 1 사용자 수정
    - `DELETE /user/1` → 삭제REST 서버 예시 구조

| 메서드 | 주소 | 역할 |
| --- | --- | --- |
| GET | `/` | 홈 (restFront.html) |
| GET | `/about` | 소개 페이지 |
| GET | `/users` | 사용자 목록 |
| POST | `/user` | 사용자 등록 |
| PUT | `/user/:id` | 사용자 수정 |
| DELETE | `/user/:id` | 사용자 삭제 |

---

### 핵심 서버 코드 (`restServer.js`)

```jsx
const http = require('http');
const fs = require('fs').promises;
const path = require('path');

const users = {}; // 메모리 DB

http.createServer(async (req, res) => {
  try {
    console.log(req.method, req.url);

    if (req.method === 'GET') {
      if (req.url === '/') {
        const data = await fs.readFile(path.join(__dirname, 'restFront.html'));
        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
        return res.end(data);
      } else if (req.url === '/users') {
        res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
        return res.end(JSON.stringify(users));
      }
    }

    else if (req.method === 'POST' && req.url === '/user') {
      let body = '';
      req.on('data', chunk => body += chunk);
      req.on('end', () => {
        const { name } = JSON.parse(body);
        const id = Date.now();
        users[id] = name;
        res.writeHead(201);
        res.end('등록 성공');
      });
    }

    else if (req.method === 'PUT' && req.url.startsWith('/user/')) {
      const key = req.url.split('/')[2];
      let body = '';
      req.on('data', chunk => body += chunk);
      req.on('end', () => {
        users[key] = JSON.parse(body).name;
        res.writeHead(200);
        res.end(JSON.stringify(users));
      });
    }

    else if (req.method === 'DELETE' && req.url.startsWith('/user/')) {
      const key = req.url.split('/')[2];
      delete users[key];
      res.writeHead(200);
      res.end(JSON.stringify(users));
    }

    else {
      res.writeHead(404);
      res.end('NOT FOUND');
    }
  } catch (err) {
    res.writeHead(500);
    res.end(err.message);
  }
}).listen(8082, ()=> console.log('8082번 포트 대기중'));

```

---

### 주요 포인트

- `req.method`, `req.url` 조합으로 라우팅.
- POST/PUT 요청 본문은 **스트림 형태**로 수신 → `data`/`end` 이벤트.
- JSON은 `JSON.parse()`로 변환 필요.
- 반드시 **return으로 응답 종료**를 명시해야 헤더 중복 에러 방지.

---

### HTTP 상태 코드 요약

| 코드 | 의미 |
| --- | --- |
| 200 | 성공 |
| 201 | 생성됨 |
| 301 / 302 | 리다이렉트 |
| 400 | 잘못된 요청 |
| 401 | 인증 실패 |
| 403 | 접근 금지 |
| 404 | 자원 없음 |
| 500 | 서버 내부 오류 |

---

### 실무 인사이트

- RESTful 서버는 **프런트엔드와 완전히 분리된 구조**로 동작.
- `axios`나 `fetch`로 클라이언트-서버 통신.
- 메모리 DB(`users`)는 휘발성 → 실제 서비스는 MySQL/MongoDB 사용.
- 라우팅이 많아지면 `if` 구조는 비효율적 → Express 사용 권장(다음 장).

---

## 4.3 쿠키와 세션 이해하기

### 쿠키 개념

- **클라이언트(브라우저)** 에 저장되는 작은 데이터 조각.
- 서버가 `Set-Cookie` 헤더로 전송 → 브라우저가 자동 저장 및 다음 요청 시 전송.
- 예시:
    
    ```
    Set-Cookie: name=zerocho; Expires=Wed, 21 Oct 2025 07:28:00 GMT; HttpOnly; Path=/
    
    ```
    
- 서버는 `req.headers.cookie`에서 쿠키를 읽는다.

### 기본 쿠키 설정 예시

```jsx
http.createServer((req, res) => {
  console.log(req.headers.cookie);
  res.writeHead(200, { 'Set-Cookie': 'mycookie=test' });
  res.end('Hello Cookie');
});
```

---

### 쿠키 옵션

| 옵션 | 설명 |
| --- | --- |
| `Expires` | 만료 시각 (절대시간) |
| `Max-Age` | 남은 초(second) |
| `Domain` | 쿠키 적용 도메인 |
| `Path` | 쿠키 전송 경로 |
| `HttpOnly` | JS 접근 차단 (보안 강화) |
| `Secure` | HTTPS에서만 전송 |

---

### 세션(Session)

- **서버에 사용자 정보 저장**, 클라이언트에는 세션 ID만 저장.
- 쿠키보다 안전하며 서버 제어 가능.
- 서버가 꺼지면 세션 메모리 날아감 → 실무에서는 Redis 같은 DB에 저장.

```jsx
const session = {};

http.createServer((req, res) => {
  const cookies = parseCookies(req.headers.cookie);

  if (req.url.startsWith('/login')) {
    const name = new URL(req.url, 'http://localhost:8085').searchParams.get('name');
    const expires = new Date(Date.now() + 5 * 60000);
    const sid = Date.now();
    session[sid] = { name, expires };
    res.writeHead(302, {
      Location: '/',
      'Set-Cookie': `session=${sid}; Expires=${expires.toGMTString()}; HttpOnly; Path=/`
    });
    return res.end();
  }

  if (cookies.session && session[cookies.session] && session[cookies.session].expires > new Date()) {
    res.end(`${session[cookies.session].name}님 안녕하세요`);
  } else {
    // 로그인 페이지 전송
  }
});

```

---

### 실무 인사이트

- 민감 정보(이름, 이메일 등)는 쿠키에 직접 저장 ❌
    
    → 세션에 저장하고, 쿠키엔 세션 ID만.
    
- 세션은 서버 재시작 시 초기화되므로 **세션 스토어(DB)** 사용.
- 보안 위해 **HttpOnly + Secure** 옵션 필수.

---

## 4.4 HTTPS와 HTTP2

### HTTPS 개요

- HTTP 통신에 **SSL/TLS 암호화**를 추가.
- 데이터 도청/위조 방지.
- 브라우저 주소창 락 표시.

### HTTPS 서버 구현

```jsx
const https = require('https');
const fs = require('fs');

https.createServer({
  cert: fs.readFileSync('도메인 인증서 경로'),
  key: fs.readFileSync('개인키 경로'),
  ca: [fs.readFileSync('중간 인증서 경로')],
}, (req, res) => {
  res.writeHead(200, {'Content-Type':'text/html; charset=utf-8'});
  res.end('<h1>SSL 서버</h1>');
}).listen(443);

```

- `cert`: 서버 인증서
- `key`: 개인 키
- `ca`: 상위 인증서 체인

무료 인증서 발급: **Let’s Encrypt**

(실무 배포 환경에서는 자동 갱신 스크립트(cron) 필수)

---

### HTTP/2 (http2 모듈)

- HTTP/1.1 대비 **멀티플렉싱, 헤더 압축, 서버 푸시** 등 지원.
- `http2.createSecureServer` 사용.
- HTTPS 기반이므로 인증서 필수.
- 실제 배포 시 Nginx/Cloudflare 등 리버스 프록시에서 처리하는 경우 많음.

---

## 4.5 Cluster (멀티 프로세스 활용)

### 핵심 개념

- Node.js는 기본적으로 싱글 스레드지만, **CPU 코어 병렬 처리**를 위해 cluster 모듈 사용.
- 코어 수만큼 워커 프로세스를 생성 → 요청 분산.

```jsx
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`마스터 PID: ${process.pid}`);
  for (let i = 0; i < numCPUs; i++) cluster.fork();

  cluster.on('exit', (worker, code, signal) => {
    console.log(`${worker.process.pid}번 워커 종료`);
    cluster.fork(); // 재시작
  });

} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('Hello Cluster');
  }).listen(8086);
  console.log(`${process.pid}번 워커 실행`);
}

```

---

### 작동 원리

- **마스터 프로세스**: 워커 생성 및 관리.
- **워커 프로세스**: 실제 요청 처리 담당.
- 마스터가 포트를 공유하고, 요청을 각 워커에 분배.
- 하나의 워커가 다운돼도 나머지 워커로 서비스 지속 가능.

---

- 클러스터는 멀티코어 활용에 필수.
- 단, **메모리와 세션은 프로세스 간 공유되지 않음**.
    
    → 세션 스토리지(예: Redis) 필요.
    
- 실무에서는 직접 cluster 코드를 작성하기보다는 **PM2** 같은 프로세스 매니저 사용.
    - 자동 클러스터링 + 재시작 + 로그 관리 + 로드밸런싱 지원.