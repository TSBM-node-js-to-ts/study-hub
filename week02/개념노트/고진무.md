## Qestion

- [ ] globalThis의 역할이 뭘까? 어떨때 사용할 수 있을까?
- [ ] 버퍼와 스트림의 장단점엔 뭐가 있을까?
- [ ] http1.1의 파이프라인 기술에 대해

## Node.js의 핵심 기능

Node.js는 자바스크립트가 서버 환경에서 작동할 수 있도록 다양한 내장 객체와 모듈을 제공한다.

---

### 1. REPL과 JS 파일
짧은 코드를 즉석에서 테스트하려면 REPL(Read Eval Print Loop) 환경을 사용한다. 여러 줄의 긴 코드는 `.js` 파일로 작성한 뒤, 콘솔에서 `node [자바스크립트 파일 경로]` 명령어로 실행하는 것이 좋다.

---

### 2. 모듈 시스템
노드의 코드는 재사용성과 관리를 위해 **모듈**로 구성된다.

| 특징 | CommonJS 모듈 (CJS) | ECMAScript 모듈 (ESM) |
| :--- | :--- | :--- |
| **내보내기 (Export)** | `module.exports`, `exports` | `export`, `export default` |
| **가져오기 (Import)** | `require()` 함수 사용 | `import` 문법 사용 |
| **경로 확장자 생략** | `.js`, `.json`, `index.js` 생략 가능 | 불가능 (반드시 확장자 명시 필요) |
| **동적 불러오기** | `require()`를 조건부로 사용 가능 | `import()` 함수를 `await`과 함께 사용 |

`module.exports`와 `exports`는 같은 객체를 참조하지만, `exports`에 새로운 값을 대입하면 참조 관계가 깨지므로 객체의 속성값만 할당해야 한다. 또한, 모듈이 서로를 호출하는 순환 참조가 발생하면, 참조되는 쪽에서 빈 객체 `{}`가 반환되어 예기치 못한 문제가 생길 수 있다.

---

### 3. 노드의 내장 객체 및 모듈 
* **global 객체**: 브라우저의 `window`와 같은 전역 객체이다. 모든 파일에서 접근 가능하지만, 데이터 공유 시 남용하면 유지보수가 어려워지므로 권장되지 않는다.
* **process 객체**: 현재 노드 프로세스 정보를 담는다.
    * `process.env`: 시스템 환경 변수를 담으며, 데이터베이스 비밀번호 같은 중요한 키를 코드에 직접 입력하는 대신 저장하는 공간으로 활용된다.
    * `process.nextTick(callback)`: 이벤트 루프에서 다른 콜백보다 우선적으로 처리되는 **마이크로태스크(microtask)**이다.
* **path 모듈**: 운영체제별 경로 구분자(윈도우 `\`, POSIX `/`) 문제를 해결하고 경로를 쉽게 조작하도록 돕는다. `path.join()`은 상대 경로를 처리하고, `path.resolve()`는 `/`를 만나면 절대 경로로 인식해 앞의 경로를 무시한다.
* **crypto 모듈**: 암호화를 담당한다.
    * **단방향 암호화 (해시)**: 복호화가 불가능하며 비밀번호 저장에 사용된다 (예: SHA512). PBKDF2는 salt(문자열)와 반복 횟수를 추가하여 보안을 강화한다.
    * **양방향 암호화 (대칭형)**: 암호화와 복호화에 같은 키를 사용한다 (예: AES-256-CBC).
* **worker\_threads 모듈**: 노드의 싱글 스레드 한계를 보완하여, CPU 연산이 많은 작업을 워커 스레드에서 병렬로 처리하게 한다. 이를 통해 소수 찾기 같은 연산 집약적 작업의 속도를 개선할 수 있다.

---

### 4. 파일 시스템 접근과 비동기 처리의 핵심
* **fs 모듈**: 파일을 읽고, 쓰고, 폴더를 생성/삭제하는 등 파일 시스템에 접근하는 모듈이다.
* **동기 vs. 비동기**:
    * **비동기 (Async)**: `fs.readFile`처럼 콜백을 사용하거나 프로미스를 반환하는 방식은 백그라운드에 작업을 위임하고 메인 스레드는 다음 작업을 처리한다 (논블로킹). 대부분의 I/O 작업에 권장되는 방식이다.
    * **동기 (Sync)**: `fs.readFileSync`처럼 이름 뒤에 `Sync`가 붙은 메서드는 이전 작업이 완료될 때까지 메인 스레드를 멈추게(블로킹) 한다. 프로그램 초기화 등 특수한 경우에만 사용해야 한다.
* **버퍼 (Buffer)**: 파일 내용을 읽을 때, 파일 크기 전체가 메모리에 저장되는 데이터 형식이다.
* **스트림 (Stream)**: 대용량 파일 처리 시 메모리 문제를 해결하기 위해, 파일을 작은 청크(chunk) 단위로 쪼개어 여러 번에 걸쳐 전송하는 방식이다. 읽기 스트림(`fs.createReadStream`)과 쓰기 스트림(`fs.createWriteStream`)은 `pipe()` 메서드를 통해 연결하여 메모리 효율을 높인다.
* **스레드 풀**: `fs`, `crypto`, `zlib` 같은 특정 비동기 메서드는 내부적으로 스레드 풀(기본 4개)을 사용하여 I/O 작업을 동시에 처리한다.

---

### 5. 예외 처리
Node.js의 메인 스레드는 하나이므로, 처리하지 못한 에러(예외)는 프로세스 전체를 멈추게 하여 서버를 다운시킨다.

* **try/catch**: 동기 코드에서 에러를 잡는 데 사용된다.
* **Promise 에러 처리**: 노드 16버전부터는 프로미스 에러를 반드시 `.catch()`로 처리해야 프로세스 종료를 막을 수 있다.
* **process.on('uncaughtException')**: 예측 불가능한 에러를 포착하는 최후의 수단이다. 하지만 노드는 이 이벤트 발생 후 코드의 복구를 보장하지 않으므로, 에러 내용을 기록한 후 프로세스를 종료하는 용도로만 사용해야 한다.

---

## http 모듈로 첫 웹 서버 구축하기

3장에서 다룬 도구를 바탕으로, 노드의 내장 http 모듈을 사용하여 클라이언트의 요청에 응답하는 서버를 구축한다.

### 1. 요청(Request)과 응답(Response)
서버는 클라이언트로부터 요청을 받고(이벤트 발생), 처리 후 응답을 보낸다.

* **서버 생성 및 대기**: `http.createServer((req, res) => { ... }).listen(8080)`으로 서버를 생성하고 포트(예: 8080)에서 대기한다.
* **응답 작성**:
    * `res.writeHead(상태 코드, 헤더)`: 헤더에 HTTP 상태 코드(예: 200 성공, 404 찾을 수 없음, 500 서버 오류)와 콘텐츠 타입(Content-Type) 같은 정보를 기록한다.
    * `res.write(데이터)`: 본문에 실제 데이터를 쓴다.
    * `res.end(데이터)`: 응답을 종료하고 데이터를 전송한다. 요청 성공 여부와 관계없이 응답은 반드시 한 번만 보내야 한다.

---

### 2. REST와 라우팅
* **REST (Representational State Transfer)**: 서버의 자원을 명확한 명사 주소로 정의하고, HTTP 요청 메서드를 사용하여 해당 자원에 대한 동작(행위)을 구분하는 약속이다.
    * **주요 HTTP 메서드**:
        * **GET**: 자원 조회 (데이터를 쿼리스트링으로 보냄)
        * **POST**: 자원 등록 (데이터를 요청 본문(body)에 넣어 보냄)
        * **PUT**: 자원 전체 교체
        * **DELETE**: 자원 삭제
* **라우팅**: 서버는 `req.method`와 `req.url`을 조건문으로 분석하여 요청 경로 및 메서드에 따라 다른 파일이나 로직을 실행한다.
* **요청 본문 처리**: POST나 PUT처럼 본문이 있는 요청은 `req` 스트림을 통해 데이터가 조각(chunk) 단위로 들어오므로, `req.on('data')`로 데이터를 모으고 `req.on('end')` 시점에서 최종적으로 JSON 등으로 파싱해야 한다.

---

### 3. 쿠키와 세션
HTTP 통신은 요청 간에 상태를 유지하지 못하므로, 사용자를 지속적으로 기억하기 위해 쿠키와 세션을 사용한다.

* **쿠키 (Cookie)**: 서버가 클라이언트(브라우저)에 저장하도록 지시하는 '키-값' 데이터이다. 서버는 응답 헤더의 `Set-Cookie`를 사용해 쿠키를 설정하고, 브라우저는 다음 요청 시 자동으로 쿠키를 요청 헤더(`Cookie`)에 담아 보낸다.
    * **옵션**: `Expires` (만료 기한), `HttpOnly` (자바스크립트 접근 방지), `Path` (쿠키 전송 URL 특정) 등을 설정할 수 있다.
* **세션 (Session)**: 쿠키에 사용자 이름 같은 민감한 정보를 직접 담는 대신, 서버가 사용자 정보를 **서버 메모리(또는 DB)**에 저장하고 클라이언트에게는 그 정보를 찾을 수 있는 **세션 아이디(Session ID)**만 쿠키로 발급하는 방식이다.
---

### 4. HTTPS와 클러스터
* **HTTPS (SSL 암호화)**: `https` 모듈을 사용하며, 클라이언트와 서버 간 데이터 전송을 암호화한다. 인증 기관에서 발급받은 인증서(cert, key, ca 파일)를 옵션으로 사용하여 `https.createServer`를 호출해야 한다.
* **HTTP/2**: `http2` 모듈을 통해 기존 HTTP/1.1보다 효율적인 최신 통신 프로토콜을 적용하며, 이는 보통 SSL 암호화와 함께 사용된다 (`createSecureServer`).
* **Cluster 모듈**: 노드가 싱글 프로세스로 작동하는 한계를 극복하기 위해, CPU 코어 개수만큼 워커 프로세스를 생성하여 포트를 공유하고 요청을 분산시킨다. 이는 서버 부하를 줄이고, 워커 프로세스가 비정상 종료되더라도 마스터 프로세스가 이를 감지하고 재시작하여 안정적인 운영을 돕는다.
