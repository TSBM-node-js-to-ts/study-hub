# 3장 노드 기능 알아보기

이 장에서는 노드의 기본적인 사용법과 핵심 개념인 '모듈'에 대해 배웁니다. 또한 모듈을 다루면서 중요한 버퍼, 스트림, 동기/비동기, 이벤트 등의 개념을 알아봅니다.

## 3.1 REPL 사용하기

**REPL**은 **R**ead(읽기), **E**val(해석), **P**rint(출력), **L**oop(반복)의 약자입니다.

- **개념**: 코드를 한 줄 입력하면 즉시 실행하고 결과를 반환하는 대화형 셸(명령어 연습장)입니다.
- **실행 방법**: 터미널(콘솔)에 `node` 입력 후 엔터.
  ```bash
  $ node
  Welcome to Node.js v18.7.0.
  Type ".help" for more information.
  >
  ```
- **용도**: 간단한 자바스크립트 코드를 빠르게 테스트하는 용도입니다.
  ```javascript
  > const str = 'Hello Node';
  undefined
  > console.log(str);
  Hello Node
  undefined
  ```
- **종료**: `Ctrl` + `C`를 두 번 누르거나 `.exit` 입력.
- **한계**: 여러 줄의 코드를 작성하고 저장하기엔 부적합합니다.

## 3.2 JS 파일 실행하기

실제 노드 프로그램은 `.js` 파일을 만들어 실행합니다.

1.  원하는 내용으로 `.js` 파일을 생성합니다.

    ```javascript
    // helloWorld.js
    function helloWorld() {
      console.log("Hello World");
      helloNode();
    }

    function helloNode() {
      console.log("Hello Node");
    }

    helloWorld();
    ```

2.  터미널에서 `node [파일경로]` 명령으로 파일을 실행합니다.
    - `.js` 확장자는 생략 가능합니다.
    - **주의:** REPL(`>`)이 아니라 터미널(`$`)에서 실행해야 합니다.
    <!-- end list -->
    ```bash
    $ node helloWorld
    Hello World
    Hello Node
    ```

## 3.3 모듈로 만들기

3장에서 **가장 중요한 개념**입니다.

- **모듈(Module)이란?**
  - 특정 기능을 하는 함수나 변수들의 **집합을 모아둔 파일**입니다.
  - 예: 수학 관련 함수만 모아 `math.js` 파일을 만드는 것.
- **모듈을 쓰는 이유**
  - **코드 재사용**: 로그인 기능을 모듈로 만들면 여러 프로그램에서 가져다 쓸 수 있습니다.
  - **유지보수 용이**: 기능별로 파일이 나뉘어 있어 코드를 찾고 수정하기 쉽습니다.
  - **관리 편의성**: 코드를 기능 단위로 구조화할 수 있습니다.

노드에는 두 가지 모듈 형식이 있습니다.

1.  **CommonJS (CJS)**: 노드의 전통적인 방식. `require` / `module.exports` 사용.
2.  **ECMAScript 모듈 (ESM)**: 자바스크립트 공식 표준. `import` / `export` 사용.

### 3.3.1 CommonJS 모듈

`require()`로 모듈을 불러오고, `module.exports`로 모듈을 내보냅니다.

- **모듈 내보내기 (Export)**: `module.exports`에 내보낼 값을 대입합니다.

  ```javascript
  // var.js (변수를 내보내는 모듈)
  const odd = "CJS 홀수입니다";
  const even = "CJS 짝수입니다";

  module.exports = {
    odd,
    even,
  };
  ```

  ```javascript
  // func.js (함수를 내보내는 모듈)
  const { odd, even } = require("./var.js"); // var 모듈을 불러옴

  function checkOddOrEven(num) {
    if (num % 2) {
      // 홀수면
      return odd;
    }
    return even;
  }

  module.exports = checkOddOrEven; // 함수 자체를 내보냄
  ```

- **모듈 가져오기 (Import)**: `require('파일경로')`로 모듈을 불러옵니다.

  - `./`는 '현재 폴더'를 의미합니다.
  - 확장자(`.js`, `.json`)는 생략 가능합니다.
  - 폴더 내의 `index.js`는 폴더 이름까지만 써도 불러올 수 있습니다. (예: `require('./routes')`)

  <!-- end list -->

  ```javascript
  // index.js (메인 파일)
  const { odd, even } = require("./var"); // var 모듈에서 객체를 구조 분해 할당
  const checkNumber = require("./func"); // func 모듈에서 함수를 불러와 checkNumber 변수에 담음

  function checkStringOddOrEven(str) {
    if (str.length % 2) {
      // 홀수면
      return odd;
    }
    return even;
  }

  console.log(checkNumber(10));
  console.log(checkStringOddOrEven("hello"));
  ```

  **실행 결과:**

  ```bash
  $ node index
  CJS 짝수입니다
  CJS 짝수입니다
  ```

#### `exports` 객체와 `module.exports`의 관계

- `module.exports`와 `exports`는 처음에는 **같은 객체를 참조**합니다.
- `exports`는 `module.exports`의 **단축키(별명)** 같은 것입니다.
  ```javascript
  // 이렇게 사용 가능
  exports.odd = "CJS 홀수입니다";
  exports.even = "CJS 짝수입니다";
  // (module.exports.odd = ... 와 동일하게 동작)
  ```
- **[매우 중요] `exports` 사용 시 주의사항**
  - `exports`에는 **반드시 객체의 속성으로** 값을 추가해야 합니다.
  - `exports = someFunction;` 처럼 `exports` 자체에 **다른 값(함수, 변수 등)을 대입하면 `module.exports`와의 참조 관계가 끊깁니다.**
  - 참조가 끊기면 `exports`에 아무리 값을 넣어도 모듈로써 동작하지 않습니다. (노드는 `module.exports`를 기준으로 내보냅니다.)
  - **결론**: 헷갈리면 `module.exports`만 사용하는 것이 안전합니다.

#### `this`의 차이

- 브라우저의 `this` (전역): `window` 객체
- 노드의 `this`
  - **최상위 스코프**: `module.exports` (또는 `exports`) 객체를 가리킴.
  - **함수 내부**: `global` 객체 (3.4.1절에서 배움)

#### `require` 객체의 속성

- `require`는 함수이자 객체입니다.
- `require.cache`
  - `require()`로 불러온 모듈들은 여기에 캐시(저장)됩니다.
  - 다음에 같은 모듈을 `require()`하면 새로 읽지 않고 `cache`에 저장된 것을 재사용합니다. (성능 향상)
- `require.main`
  - `node index.js`로 실행했을 때, **진입점(Entry point)이 되는 메인 모듈**(`index.js`)을 가리킵니다.
  - `require.main === module`이 `true`라면 "이 파일이 터미널에서 직접 실행된 파일이다"라는 뜻입니다.

#### 순환 참조 (Circular Dependency)

- **상황**: `dep1.js`가 `dep2.js`를 `require`하고, `dep2.js`가 다시 `dep1.js`를 `require`하는 경우.
- **문제**: 무한 반복이 발생할 수 있습니다.
- **노드의 동작**:
  1.  `dep-run.js`가 `dep1`을 `require`.
  2.  `dep1`이 `dep2`를 `require`.
  3.  `dep2`가 `dep1`을 `require`.
  4.  이때 `dep1`은 아직 로딩이 완료되지 않았으므로, 노드는 `dep1`의 `module.exports`를 임시로 빈 객체(`{}`)로 반환합니다.
  5.  `dep2`는 빈 객체를 `dep1`로 받고 로딩을 마칩니다.
  6.  `dep1`은 로딩이 완료된 `dep2`를 받아 로딩을 마칩니다.
- **결과**: `dep2`는 `dep1`의 내용을 제대로 받지 못해 `{} ` (빈 객체)로 나옵니다. 에러가 발생하지 않고 조용히 넘어가므로, **순환 참조는 반드시 피해야 하는 구조입니다.**

### 3.3.2 ECMAScript 모듈 (ESM)

자바스크립트의 **공식 표준** 모듈 형식입니다. `import` / `export` 문법을 사용합니다.

- **파일 확장자**: `.mjs`를 사용하거나, `package.json` 파일에 `"type": "module"`을 명시해야 합니다. (이후 5장)

- **모듈 내보내기 (Export)**

  - **이름 있는 내보내기 (Named Export)**: `export` 키워드 사용. 여러 개 가능.
    ```javascript
    // var.mjs
    export const odd = "MJS 홀수입니다";
    export const even = "MJS 짝수입니다";
    ```
  - **기본 내보내기 (Default Export)**: `export default` 사용. 파일당 **단 하나**만 가능.

    ```javascript
    // func.mjs
    import { odd, even } from "./var.mjs"; // ESM은 확장자 생략 불가

    function checkOddOrEven(num) {
      if (num % 2) {
        // 홀수면
        return odd;
      }
      return even;
    }

    export default checkOddOrEven; // 이 함수를 기본값으로 내보냄
    ```

- **모듈 가져오기 (Import)**

  - **이름 있는 내보내기 가져오기**: `{ }` 안에 정확한 이름을 써야 합니다.
  - **기본 내보내기 가져오기**: `{ }` 없이 원하는 이름을 자유롭게 지정할 수 있습니다.

  <!-- end list -->

  ```javascript
  // index.mjs
  import { odd, even } from "./var.mjs"; // 이름 있는 모듈 가져오기
  import checkNumber from "./func.mjs"; // 기본 모듈 가져오기 (이름을 checkNumber로 지정)

  function checkStringOddOrEven(str) {
    if (str.length % 2) {
      // 홀수면
      return odd;
    }
    return even;
  }

  console.log(checkNumber(10));
  console.log(checkStringOddOrEven("hello"));
  ```

  **실행 결과:**

  ```bash
  $ node index.mjs
  MJS 짝수입니다
  MJS 짝수입니다
  ```

#### CommonJS와 ECMAScript 모듈 비교

| 차이점                        | CommonJS (CJS)                         | ECMAScript 모듈 (ESM)                         |
| :---------------------------- | :------------------------------------- | :-------------------------------------------- |
| **문법**                      | `require`, `module.exports`, `exports` | `import`, `export`, `export default`          |
| **확장자**                    | `.js`, `.cjs`                          | `.mjs` (또는 `.js` + `package.json` 설정)     |
| **확장자 생략**               | **가능** (`require('./var')`)          | **불가능** (`import './var.mjs'`)             |
| **`index` 파일 생략**         | **가능** (`require('./folder')`)       | **불가능** (`import './folder/index.mjs'`)    |
| **동적 불러오기**             | `require()` 자체가 가능                | `import()` 함수 사용 (3.3.3)                  |
| **`__filename`, `__dirname`** | **사용 가능**                          | **사용 불가능** (대신 `import.meta.url` 사용) |
| **호환성**                    | CJS에서 ESM을 `require`하기 어려움     | ESM에서 CJS를 `import`하는 것은 비교적 쉬움   |

> **권장 사항**: 두 형식을 섞어 쓰면 복잡해지므로, 웬만하면 한 가지 형식(주로 ESM)으로 통일하는 것을 권장합니다.

### 3.3.3 다이내믹 임포트 (Dynamic Import)

- **CJS**: `require()`는 일반 함수이므로 `if` 문 안에서 조건부로 모듈을 불러올 수 있었습니다.

- **ESM**: `import`는 문법(키워드)이라 `if` 문 같은 곳에서 사용할 수 없고, **파일 최상단**에서만 사용해야 합니다.

- **ESM의 해결책**: `import()` 함수를 사용하면 조건부로 모듈을 동적으로 불러올 수 있습니다.

  - `import()`는 **Promise**를 반환하므로 `await` 또는 `.then()`으로 받아야 합니다.
  - ESM의 최상위 스코프에서는 `async` 함수 없이 `await`를 사용할 수 있습니다. (Top-level await)

  <!-- end list -->

  ```javascript
  // dynamic.mjs
  const a = true;

  if (a) {
    // import './func.mjs'; // SyntaxError 발생!

    // await을 사용하여 동적으로 모듈을 불러옴
    const m1 = await import("./func.mjs");
    console.log(m1);
    // 결과: [Module: null prototype] { default: [Function: checkOddOrEven] }

    const m2 = await import("./var.mjs");
    console.log(m2);
    // 결과: [Module: null prototype] { even: 'MJS 짝수입니다', odd: 'MJS 홀수입니다' }
  }
  ```

  - `export default`로 내보낸 값은 `default`라는 속성 이름으로 가져옵니다. (`m1.default`)

### 3.3.4 `__filename`, `__dirname`

노드는 파일 경로에 대한 정보를 제공하는 두 가지 키워드를 지원합니다.

- `__filename`: 현재 파일의 **전체 경로** (파일명 포함)
- `__dirname`: 현재 파일이 위치한 **폴더(디렉터리) 경로**

<!-- end list -->

```javascript
// filename.js (CJS)
console.log(__filename);
console.log(__dirname);
```

**실행 결과:**

```bash
$ node filename.js
C:\Users\zerocho\filename.js
C:\Users\zerocho
```

- **[중요] ESM에서의 제한**

  - **ESM에서는 `__filename`과 `__dirname`을 사용할 수 없습니다.** (ReferenceError 발생)
  - 대신 `import.meta.url`을 통해 현재 파일의 URL 경로를 가져올 수 있습니다.

  <!-- end list -->

  ```javascript
  // filename.mjs (ESM)
  console.log(import.meta.url);
  // 결과 (예): file:///C:/Users/zerocho/filename.mjs

  console.log(__filename); // ReferenceError 발생!
  ```

## 3.4 노드 내장 객체 알아보기

노드는 브라우저의 `window` 객체처럼, **설치하거나 `require` 하지 않아도** 어디서든 바로 사용할 수 있는 기본적인 **내장 객체**들을 제공합니다.

### 3.4.1 global

- **개념**: 브라우저의 `window`에 해당하는 **노드의 전역 객체**입니다. 모든 파일에서 접근할 수 있습니다.
- **특징**:
  - 모든 전역 변수와 함수는 사실 `global` 객체의 속성입니다.
  - `require`, `console`, `setTimeout` 등은 사실 `global.require`, `global.console`, `global.setTimeout`입니다. ( `global`은 생략 가능)
  - **`globalThis`**: 브라우저 환경에서는 `window`, 노드 환경에서는 `global`을 가리키도록 표준화된 이름입니다.
- **파일 간 데이터 공유**:
  - `global.message = '안녕하세요';` 처럼 `global`에 값을 대입하면, `require`로 불러온 다른 파일에서도 `global.message`를 읽을 수 있습니다.
    > **⚠️ 주의: `global` 객체 남용 금지** > `global`을 통한 데이터 공유는 편리하지만, 프로그램이 커지면 어떤 파일이 `global`의 값을 바꾸는지 추적하기가 극도로 어려워집니다. 유지보수를 위해, **데이터 공유는 반드시 `module.exports`와 `require` (또는 `export`/`import`)를 통해 명시적으로** 하는 것을 권장합니다.

### 3.4.2 console

- **개념**: 디버깅을 위해 콘솔(터미널)에 여러 정보를 출력하는 객체입니다. (`global.console`)
- **주요 메서드**:
  - `console.log()`: 가장 일반적인 로그 출력.
  - `console.error()`: 에러 메시지 출력. (일반 `log`와 구분되어 출력됨)
  - `console.table(배열)`: 배열 안의 객체들을 **표(테이블) 형식**으로 깔끔하게 출력해 줍니다.
  - `console.dir(객체, 옵션)`: 객체를 자세히 들여다볼 때 씁니다.
    - `colors: true`: 객체에 색상을 입혀 가독성을 높입니다.
    - `depth: N`: 객체 내부의 객체를 몇 단계까지 보여줄지 정합니다. (기본값 2)
  - `console.time('레이블')` / `console.timeEnd('레이블')`:
    - `time`과 `timeEnd` 사이의 **코드 실행 시간**을 측정합니다. 레이블 이름이 같아야 합니다.
  - `console.trace('레이블')`: 현재 위치의 호출 스택(stack trace)을 추적하여 함수가 어떤 경로로 호출되었는지 보여줍니다.

### 3.4.3 타이머

- **개념**: 특정 시간 후에 또는 주기적으로 코드를 실행하게 하는 함수들입니다. (`global` 소속)
- **기본 타이머 (콜백 방식)**:
  - `setTimeout(콜백, 밀리초)`: N밀리초 **후에 한 번** 콜백 함수를 실행.
  - `setInterval(콜백, 밀리초)`: N밀리초**마다 반복**해서 콜백 함수를 실행.
  - `setImmediate(콜백)`: **즉시** 콜백 함수를 실행. (이벤트 루프의 특정 단계에서 실행됨)
- **타이머 취소**:
  - 위 함수들은 실행 시 **고유 ID**를 반환합니다.
  - `clearTimeout(ID)`, `clearInterval(ID)`, `clearImmediate(ID)`: 해당 ID의 타이머를 취소합니다.
- **`setImmediate` vs `setTimeout(cb, 0)`**
  - 둘 다 '즉시 실행'처럼 보이지만, 동작 순서가 미묘하게 다릅니다.
  - 특히 **I/O 작업(파일 읽기 등)의 콜백 함수 내에서는 `setImmediate`가 `setTimeout(0)`보다 항상 먼저 실행**됩니다.
  - 혼란을 피하기 위해 `setTimeout(0)` 사용은 가급적 피하는 것이 좋습니다.
- **프로미스(Promise) 기반 타이머**:

  - `async/await`와 함께 쓰기 편한 최신 방식입니다.
  - `import { setTimeout, setInterval } from 'timers/promises';` 로 불러와야 합니다.
  <!-- end list -->

  ```javascript
  // 3초 기다리기
  await setTimeout(3000);

  // 1초마다 반복 (for await...of 사용)
  for await (const startTime of setInterval(1000, Date.now())) {
    console.log(new Date(startTime));
  }
  ```

### 3.4.4 process

- **개념**: 현재 실행 중인 **노드 프로세스**에 대한 정보를 담고 있는 객체입니다. (`global` 소속 아님. 하지만 `require` 없이 사용 가능)
- **주요 속성 및 메서드**:
  - `process.version`: 설치된 노드 버전
  - `process.platform`: 운영체제 플랫폼 (`win32`, `linux`, `darwin` 등)
  - `process.pid`: 프로세스 고유 ID
  - `process.cwd()`: **C**urrent **W**orking **D**irectory (현재 `node` 명령을 실행한 폴더 경로)
  - `process.execPath`: `node.exe` (노드 프로그램)의 실제 위치

#### 3.4.4.1 process.env (⭐ 매우 중요)

- **개념**: 시스템의 **환경 변수**들을 담고 있는 객체입니다.
- **용도 1 (설정)**: 노드 실행 옵션이나 스레드 풀 개수(`UV_THREADPOOL_SIZE`) 등을 설정할 때 사용됩니다.
- **용도 2 (보안)**:
  - **DB 비밀번호, API 키 등 민감한 정보**를 코드에 직접 하드코딩하는 것은 매우 위험합니다.
  - 이런 정보는 환경 변수에 저장하고, 코드에서는 `process.env.SECRET_KEY`처럼 불러와 사용해야 합니다.

#### 3.4.4.2 process.nextTick(콜백) (⭐ 핵심 개념)

- **개념**: 이벤트 루프가 다른 작업(타이머, I/O 등)을 처리하기 **전에, 가장 우선적으로** 콜백 함수를 실행하도록 예약합니다.
- **마이크로태스크 (Microtask)**:
  - `process.nextTick`과 `Promise.resolve().then()`은 '마이크로태스크'로 분류됩니다.
  - 이벤트 루프는 `setTimeout(0)`이나 `setImmediate` 같은 '태스크'보다 **'마이크로태스크'를 항상 먼저 처리**합니다.
- **실행 순서**:

  1.  `process.nextTick`
  2.  `Promise.resolve().then()`
  3.  `setTimeout(0)`
  4.  `setImmediate`
  <!-- end list -->

  ```javascript
  process.nextTick(() => console.log("1. nextTick"));
  Promise.resolve().then(() => console.log("2. promise"));
  setTimeout(() => console.log("3. timeout"), 0);
  setImmediate(() => console.log("4. immediate"));

  // $ node nextTick
  // 1. nextTick
  // 2. promise
  // 3. timeout
  // 4. immediate
  ```

  > **⚠️ 주의: 마이크로태스크 재귀 호출** > `process.nextTick` 안에서 또 `process.nextTick`을 부르는 재귀 코드는 이벤트 루프를 독점할 수 있습니다. 이 경우, 다른 타이머나 I/O 콜백이 영원히 실행되지 못할 수(starvation) 있으니 주의해야 합니다.

#### 3.4.4.3 process.exit(코드)

- **개념**: 실행 중인 노드 프로세스를 **강제로 종료**합니다.
- **인수 (Exit Code)**:
  - `process.exit(0)`: **정상 종료** (기본값)
  - `process.exit(1)`: **비정상 종료** (에러가 발생했을 때)
- **주의**: 일반적인 웹 서버에서는 절대 사용하면 안 됩니다. 서버 자체가 멈춰버립니다.

### 3.4.5 기타 내장 객체

최신 노드는 브라우저와의 호환성을 위해 브라우저에서 사용하던 많은 API를 내장 객체로 지원합니다.

- `URL`, `URLSearchParams`: URL을 파싱하고 다룰 때 사용 (3.5.3절)
- `fetch`, `Headers`, `Request`, `Response`: 브라우저와 동일한 네트워크 요청 API
- `TextEncoder`, `TextDecoder`: 문자열과 Buffer(바이트 배열)를 상호 변환 (3.6.2절)
- `WebAssembly`: 웹어셈블리 처리

## 3.5 노드 내장 모듈 사용하기

노드는 운영체제(OS) 정보 접근, 파일 시스템(FS) 제어, 암호화, 경로 조작 등 강력한 기능들을 '내장 모듈'로 제공합니다.

이는 `require('모듈이름')`을 통해 바로 불러와 사용할 수 있습니다. (예: `require('os')`, `require('path')`)

### 3.5.1 os

- **용도**: **O**perating **S**ystem, 즉 현재 코드가 실행 중인 **운영체제의 정보**에 접근할 때 사용합니다.
- **주요 메서드**:
  - `os.platform()`: 운영체제 플랫폼 (예: 'win32', 'linux', 'darwin')
  - `os.arch()`: CPU 아키텍처 (예: 'x64')
  - `os.cpus()`: CPU 코어 정보 (배열). `os.cpus().length`로 코어 수를 알 수 있습니다.
  - `os.totalmem()`: 총 메모리(RAM) 용량
  - `os.freemem()`: 사용 가능한 메모리(RAM) 용량
  - `os.homedir()`: 홈 디렉터리 경로 (예: `C:\Users\유저`)
  - `os.tmpdir()`: 임시 파일 저장 경로

> **💡 참고: 코어 개수와 노드**
> 노드는 기본적으로 **싱글 스레드**로 동작하므로, CPU 코어가 100개여도 기본적으로는 1개만 사용합니다. 하지만 나중에 배울 `cluster` 모듈이나 `worker_threads`를 사용하면 여러 코어를 활용할 수 있습니다.

### 3.5.2 path

- **용도**: 파일이나 폴더의 **경로(path)를 쉽게 조작**하도록 도와주는 모듈입니다.
- **왜 필요한가요?**: 운영체제마다 경로 구분자가 다릅니다.
  - **Windows**: `C:\Users\zerocho`처럼 `\` (역슬래시) 사용
  - **POSIX (macOS, Linux)**: `/home/zerocho`처럼 `/` (슬래시) 사용
- `path` 모듈은 이런 차이를 알아서 처리해줘서 호환성 높은 코드를 짜게 해줍니다.
- **주요 속성 및 메서드**:
  - `path.sep`: OS별 경로 구분자 (`\` 또는 `/`)
  - `path.dirname(경로)`: 파일이 속한 **폴더** 경로
  - `path.basename(경로)`: 파일 **이름**(확장자 포함)
  - `path.extname(경로)`: 파일 **확장자** (예: `.js`)
  - `path.parse(경로)`: 경로를 `root`, `dir`, `base`, `ext`, `name` 등으로 분리한 객체를 반환.
  - `path.format(객체)`: `parse()`로 분리된 객체를 다시 경로 문자열로 합칩니다.
  - `path.normalize(경로)`: `//`나 `C://users\\\\zerocho`처럼 잘못된 경로를 `C:\users\zerocho`처럼 정상으로 변환.
  - `path.isAbsolute(경로)`: 절대 경로인지 상대 경로인지 판별 (true/false).
  - `path.join(경로, ...)`: **(⭐중요)** 여러 경로 조각을 OS에 맞게 **상대경로로 이어붙입니다.** `..`(부모 폴더), `.`(현재 폴더)도 처리합니다.
  - `path.resolve(경로, ...)`: **(⭐중요)** 여러 경로 조각을 **절대경로로 만듭니다.**

> **💡 `path.join` vs `path.resolve` (핵심 차이)**
>
> `path.join`은 상대경로를 기반으로 경로를 '조립'합니다.
>
> ```javascript
> path.join("/a", "/b", "c"); // 결과: /a/b/c (POSIX 기준)
> ```
>
> `path.resolve`는 `/`를 만나면 '루트(최상위)'로 인식해 앞의 경로를 무시합니다.
>
> ```javascript
> path.resolve("/a", "/b", "c"); // 결과: /b/c
> // '/a'를 만났다가, '/b'를 만나면서 '/a'가 무시되고, 'c'가 붙음.
> ```

### 3.5.3 url

- **용도**: 인터넷 주소(URL)를 쉽게 조작하고 분석(parsing)하도록 도와줍니다.
- **WHATWG 방식 (표준 방식)**: `new URL(주소)` 생성자를 사용하는 것이 요즘 표준입니다.
  ```javascript
  const myURL = new URL(
    "http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor"
  );
  ```
  `myURL` 객체에는 다음과 같은 정보가 분리되어 담깁니다.
  - `myURL.href`: 전체 주소
  - `myURL.protocol`: 'http:'
  - `myURL.host`: 'www.gilbut.co.kr'
  - `myURL.pathname`: '/book/bookList.aspx'
  - `myURL.search`: '?sercate1=001001000'
  - `myURL.hash`: '\#anchor'
- **`searchParams` (⭐핵심)**: `search` (쿼리스트링) 부분을 쉽게 조작하는 객체입니다.

  ```javascript
  const myURL = new URL(
    "http://www.../?page=3&category=nodejs&category=javascript"
  );

  // 키에 해당하는 모든 값 가져오기
  myURL.searchParams.getAll("category"); // ['nodejs', 'javascript']

  // 키에 해당하는 첫 번째 값 가져오기
  myURL.searchParams.get("page"); // '3'

  // 키가 있는지 확인
  myURL.searchParams.has("limit"); // false

  // 키/값 추가 (같은 키가 있어도 추가됨)
  myURL.searchParams.append("filter", "es5");

  // 키/값 수정 (같은 키의 값들을 모두 지우고 새로 추가)
  myURL.searchParams.set("page", "10");

  // 키 삭제
  myURL.searchParams.delete("filter");

  // 다시 문자열로 변환
  myURL.searchParams.toString(); // 'page=10&category=nodejs&category=javascript'
  ```

### 3.5.4 dns

- **용도**: **D**omain **N**ame **S**ystem. 도메인 이름(예: `gilbut.co.kr`)으로 IP 주소(예: `49.236.151.220`)를 찾을 때 사용합니다.
- `dns/promises` 모듈을 사용하면 `async/await`과 함께 쓸 수 있습니다.

  ```javascript
  import dns from "dns/promises";

  const ip = await dns.lookup("gilbut.co.kr");
  console.log(ip.address); // IP 주소

  const a = await dns.resolve("gilbut.co.kr", "A"); // A 레코드(IPv4)
  const mx = await dns.resolve("gilbut.co.kr", "MX"); // MX 레코드(메일 서버)
  ```

### 3.5.5 crypto

- **용도**: **암호화** 관련 기능을 제공하는 매우 중요한 모듈입니다.

#### 3.5.5.1 단방향 암호화 (Hashing)

- **개념**: 암호화는 되지만 **복호화(원문 복구)는 불가능**한 암호화. **해시(Hash) 함수**라고도 부릅니다.
- **용도**: **비밀번호 저장.**
  - (사용자) "1234" 입력 -\> (서버) 암호화 -\> "abcd" (DB 저장)
  - (로그인 시) "1234" 입력 -\> (서버) 암호화 -\> "abcd" -\> DB의 "abcd"와 **비교**
- **`createHash` (기본 해시)**:

  ```javascript
  const crypto = require("crypto");

  // sha512 알고리즘으로 '비밀번호'를 'base64' 인코딩으로 암호화
  crypto.createHash("sha512").update("비밀번호").digest("base64");
  // 'dvfV6n...=='
  ```

- **`pbkdf2` (⭐권장 방식)**:

  - 기본 해시는 '충돌'에 취약할 수 있습니다.
  - `pbkdf2`는 **'salt'**(임의의 문자열)를 추가하고, 해시 함수를 **수만\~수십만 번 반복**하여 해킹을 극도로 어렵게 만듭니다.
  <!-- end list -->

  ```javascript
  const crypto = require("crypto");

  // 1. 64바이트 길이의 임의의 'salt' 생성
  crypto.randomBytes(64, (err, buf) => {
    const salt = buf.toString("base64");

    // 2. pbkdf2 실행
    // (비밀번호, salt, 반복횟수, 출력 바이트, 해시 알고리즘, 콜백)
    crypto.pbkdf2("비밀번호", salt, 100000, 64, "sha512", (err, key) => {
      console.log("password:", key.toString("base64"));
    });
  });
  ```

  - `crypto.pbkdf2`는 노드의 스레드 풀(3.6.4절)에서 동작하므로, 반복 횟수가 많아도 메인 스레드를 막지 않습니다.

#### 3.5.5.2 양방향 암호화 (Encryption)

- **개념**: '키(key)'를 사용하여 암호화와 복호화가 모두 가능한 방식입니다. (대칭형)
- **용도**: 민감한 개인정보(주민번호 등)처럼 나중에 원문을 확인해야 할 때.
- `createCipheriv` (암호화) / `createDecipheriv` (복호화)

  ```javascript
  const algorithm = "aes-256-cbc"; // 알고리즘
  const key = "abcdefghijklmnopqrstuvwxyz123456"; // 키 (32바이트)
  const iv = "1234567890123456"; // 초기화 벡터 (16바이트)

  // --- 암호화 ---
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let result = cipher.update("암호화할 문장", "utf8", "base64");
  result += cipher.final("base64"); // 암호화 완료
  console.log("암호화:", result);

  // --- 복호화 ---
  const decipher = crypto.createDecipheriv(algorithm, key, iv);
  let result2 = decipher.update(result, "base64", "utf8"); // 암호화된 문장을 base64로 읽어 utf8로 복원
  result2 += decipher.final("utf8"); // 복호화 완료
  console.log("복호화:", result2);
  ```

### 3.5.6 util

- **용도**: **Util**ity. 각종 편의 기능을 모아둔 모듈입니다.
- **`util.deprecate(함수, 경고메시지)`**:
  - **Deprecated (비권장)**: "앞으로 사라질 기능이니 쓰지 말라"는 뜻입니다.
  - 이 함수로 기존 함수를 감싸면, 해당 함수 사용 시 터미널에 경고 메시지를 출력합니다.
- **`util.promisify(콜백함수)` (⭐매우 중요)**:

  - **콜백 패턴을 프로미스 패턴으로 변환**해줍니다.
  - `(err, data)` 형태의 콜백을 사용하는 구형 함수들을 `async/await`과 함께 쓸 수 있게 해줍니다.
  <!-- end list -->

  ```javascript
  // 원래 crypto.randomBytes는 콜백 방식
  // crypto.randomBytes(64, (err, buf) => { ... });

  const util = require("util");
  const crypto = require("crypto");

  // randomBytes를 프로미스 버전으로 변환
  const randomBytesPromise = util.promisify(crypto.randomBytes);

  // async/await과 함께 사용 가능!
  async function main() {
    try {
      const buf = await randomBytesPromise(64);
      console.log(buf.toString("base64"));
    } catch (error) {
      console.error(error);
    }
  }
  main();
  ```

### 3.5.7 worker_threads

- **용도**: 노드의 싱글 스레드 한계를 극복하고, **멀티 스레드** 프로그래밍을 가능하게 합니다.
- **언제 쓰나요?**: 소수 찾기, 대규모 데이터 처리 등 **CPU를 많이 소모하는(CPU-intensive) 작업**이 메인 스레드를 막는 것을 방지할 때 씁니다.
- **주요 개념**:
  - `isMainThread`: 현재 코드가 메인 스레드에서 도는지, 워커 스레드에서 도는지 판별 (true/false)
  - `new Worker(파일경로, { workerData })`: 워커 스레드를 생성. `workerData`로 초기 데이터 전달.
  - `parentPort`: 워커 스레드에서 부모 스레드와 통신하는 통로.
- **동작 방식 (소수 찾기 예제)**:
  1.  **메인 스레드 (`isMainThread === true`)**:
      - 전체 작업 범위(2 \~ 1000만)를 8개로 나눕니다.
      - 8개의 `Worker`를 생성하고, 각 워커에게 `{ start, range }`를 `workerData`로 전달합니다.
      - 각 워커가 `on('message')`로 결과를 보내주면, `primes` 배열에 합칩니다.
      - `on('exit')`로 워커 종료를 감지하고, 8개 모두 종료되면 최종 결과를 출력합니다.
  2.  **워커 스레드 (`isMainThread === false`)**:
      - `workerData`로 자신에게 할당된 범위(예: 2 \~ 125만)를 받습니다.
      - `findPrimes()` 함수를 실행해 자기 범위의 소수만 찾습니다.
      - `parentPort.postMessage(primes)`로 찾은 결과를 메인 스레드에 보냅니다.
- **결과**: 싱글 스레드로 8.7초 걸리던 작업이, 8개 스레드를 사용해 1.7초로 단축되었습니다. (단, 스레드 생성/통신 비용이 있어 8배가 되진 않습니다.)

### 3.5.8 child_process

- **용도**: 노드 프로세스에서 **다른 프로그램이나 셸 명령어**를 실행(spawn)할 때 사용합니다. (예: `python` 스크립트 실행, `git` 명령어 실행)
- **`exec('명령어')`**:
  - **셸(cmd, bash 등)을 실행**하여 명령어를 수행합니다. `dir`이나 `ls -l`처럼 셸 문법이 필요할 때 유용합니다.
  - 결과는 콜백으로 받으며, `stdout`(표준 출력)과 `stderr`(표준 에러)로 나옵니다.
- **`spawn('명령어', [옵션배열])`**:

  - **새로운 프로세스를 직접** 띄웁니다. `python`처럼 특정 프로그램을 실행할 때 권장됩니다.
  - 데이터가 `stdout`/`stderr`의 **'data' 이벤트**를 통해 스트림(3.6.2절) 방식으로 전달됩니다.
  <!-- end list -->

  ```javascript
  const spawn = require("child_process").spawn;

  // 'python test.py' 실행
  const process = spawn("python", ["test.py"]);

  process.stdout.on("data", (data) => {
    console.log(data.toString()); // 파이썬의 print() 결과
  });

  process.stderr.on("data", (data) => {
    console.error(data.toString()); // 파이썬의 에러
  });
  ```

### 3.5.9 기타 모듈들

- `zlib`: 파일 압축 (예: `createGzip()`)
- `net`: TCP/IP 통신 (HTTP보다 하위 레벨)
- `querystring`: `url.searchParams`가 나오기 전 쓰던 구형 모듈

## 3.6 파일 시스템 접근하기

- **용도**: `fs` 모듈은 **F**ile **S**ystem의 약자로, 노드를 통해 **파일/폴더를 읽고, 쓰고, 생성하고, 삭제**하는 모든 작업을 수행합니다.

- **프로미스(Promise) 기반 사용 (⭐권장)**:

  - `fs` 모듈은 기본적으로 콜백 방식이지만, `fs.promises`를 사용하면 `async/await`과 함께 깔끔하게 사용할 수 있습니다.

  <!-- end list -->

  ```javascript
  const fs = require("fs").promises;

  async function main() {
    try {
      const data = await fs.readFile("./readme.txt");
      console.log(data.toString()); // Buffer를 문자열로 변환
    } catch (err) {
      console.error(err);
    }
  }
  ```

- **Buffer (버퍼)**:

  - `fs.readFile`의 결과(`data`)는 '텍스트'가 아니라 **'Buffer'** 객체입니다.
  - Buffer는 파일의 **이진 데이터(바이트) 덩어리**를 메모리에 저장한 것입니다.
  - `data.toString()`을 호출해야 사람이 읽을 수 있는 문자열로 변환됩니다.

### 3.6.1 동기 메서드와 비동기 메서드 (⭐핵심 개념⭐)

`fs` 모듈은 두 가지 방식의 메서드를 제공합니다: **비동기(논블로킹)** 와 **동기(블로킹)**.

- **비동기 (Async) - `fs.readFile()` (권장)**:

  - "파일 읽어줘"라고 요청(논블로킹)하고, **바로 다음 코드(예: `console.log('끝')`)를 실행**합니다.
  - 파일 읽기는 **백그라운드(스레드 풀)** 에서 처리됩니다.
  - 읽기가 완료되면, 나중에 콜백 함수(또는 Promise의 `.then`)가 실행됩니다.

  <!-- end list -->

  ```javascript
  console.log('시작');
  fs.readFile('./readme.txt', (err, data) => { ... }); // 1번
  fs.readFile('./readme.txt', (err, data) => { ... }); // 2번
  console.log('끝');

  // 실행 순서: 시작 -> 끝 -> 1번/2번 (순서 보장 안됨)
  ```

  - **장점**: 기다리는 동안 다른 요청을 받을 수 있어 서버 효율이 극대화됩니다.

- **동기 (Sync) - `fs.readFileSync()` (비권장)**:

  - **"파일 다 읽을 때까지 기다려"라고 명령(블로킹)** 합니다.
  - 파일 읽기가 완료될 때까지 **메인 스레드가 멈춥니다.**
  - `Sync`가 붙은 메서드는 결과를 `return` 값으로 즉시 반환합니다.

  <!-- end list -->

  ```javascript
  console.log("시작");
  let data1 = fs.readFileSync("./readme.txt"); // 여기서 멈춤
  let data2 = fs.readFileSync("./readme.txt"); // 여기서 멈춤
  console.log("끝");

  // 실행 순서: 시작 -> data1 읽기 -> data2 읽기 -> 끝
  ```

  - **단점**: 서버가 멈춥니다. 수백 명이 동시 접속하면 다음 사람은 이전 사람의 파일 읽기가 끝날 때까지 무한정 대기해야 합니다. **절대 서버 코드에 사용하면 안 됩니다.** (단, 프로그램 시작 시 설정 파일을 읽는 등 초기화 용도로는 사용 가능)

### 3.6.2 버퍼(Buffer)와 스트림(Stream) 이해하기 (⭐핵심 개념⭐)

파일을 다루는 두 가지 방식입니다.

#### 1\. 버퍼 (Buffer) - `fs.readFile`

- **개념**: 파일 전체를 **한 번에** 읽어와 메모리(RAM)에 **통째로** 올리는 방식.
- **`Buffer.from(문자열)`**: 문자열을 버퍼로 변환.
- **`Buffer.concat([버퍼1, 버퍼2])`**: 조각난 버퍼들을 하나로 합침.
- **`Buffer.alloc(크기)`**: 빈 버퍼를 생성.
- **문제점**: 1GB짜리 파일을 `readFile`로 읽으면, 메모리 1GB가 즉시 소모됩니다. 10명이 동시에 요청하면 10GB RAM이 필요합니다. **(메모리 비효율)**

#### 2\. 스트림 (Stream) - `fs.createReadStream`

- **개념**: **'물줄기(stream)'** 처럼 데이터를 **작은 조각(chunk)으로 잘게 나눠** 순차적으로 처리하는 방식.
- **비유**: 1GB 영화를 '다운로드(버퍼)' 받으면서 보는 것이 아니라, '스트리밍(스트림)'으로 5초 분량씩 나눠서 보는 것.
- **장점**: 1GB 파일이라도 64KB(기본 청크 크기)의 메모리만으로 처리 가능. **(메모리 효율 최고)**
- **`fs.createReadStream(경로, [옵션])`**: 읽기 스트림 생성
  - `highWaterMark: 16`: 청크 크기를 16바이트로 조절 (테스트용)
  - **이벤트 기반 동작**:
    - `readStream.on('data', (chunk) => { ... })`: 16바이트 청크가 도착할 때마다 **여러 번** 호출됨.
    - `readStream.on('end', () => { ... })`: 파일 읽기가 모두 끝나면 **한 번** 호출됨.
    - `readStream.on('error', (err) => { ... })`: 에러 발생 시 호출됨.
- **`fs.createWriteStream(경로)`**: 쓰기 스트림 생성
  - `writeStream.write(청크)`: 청크 데이터를 파일에 씀.
  - `writeStream.end()`: 쓰기 완료. `finish` 이벤트 발생.
- **`pipe()` (⭐핵심)**:
  - 스트림을 **'연결'** 하는 가장 우아하고 효율적인 방법입니다.
  - `읽기스트림.pipe(쓰기스트림)`: `readme4.txt`를 읽어서 `writeme3.txt`로 복사.
  <!-- end list -->
  ```javascript
  const readStream = fs.createReadStream("readme4.txt");
  const writeStream = fs.createWriteStream("writeme3.txt");
  readStream.pipe(writeStream); // 파일 복사 끝!
  ```
  - **파이프 체이닝**: 스트림은 여러 개 연결할 수 있습니다.
  <!-- end list -->
  ```javascript
  // 읽기 -> 압축(zlib) -> 쓰기
  readStream.pipe(zlib.createGzip()).pipe(writeStream);
  ```
- **`pipeline()`**:
  - `pipe()`의 최신 버전. `async/await`을 지원하고 에러 처리 및 스트림 중단(AbortController)에 더 용이합니다.

> **💡 버퍼 vs 스트림 메모리 비교 (결론)**
>
> - `readFileSync` (동기 버퍼): 1GB 파일 복사 시 -\> **RAM 1GB 이상 사용**
> - `pipe` (비동기 스트림): 1GB 파일 복사 시 -\> **RAM 62MB (일정) 사용**
>
> **큰 파일(동영상, 로그 등)은 반드시 스트림을 사용해야 합니다.**

### 3.6.3 기타 fs 메서드 알아보기

`fs.promises` 기준으로 설명합니다.

- **폴더/파일 생성 및 확인**:
  - `fs.access(경로, [모드])`: 파일/폴더 존재 여부 및 권한 확인. (`constants.F_OK`: 존재, `R_OK`: 읽기, `W_OK`: 쓰기)
  - `fs.mkdir(경로)`: **M**a**k**e **Dir**ectory (폴더 생성)
  - `fs.open(경로, 'w')`: 파일 열기/생성 (파일 디스크립터 'fd' 반환, 'w'는 쓰기 모드)
  - `fs.rename(이전경로, 새경로)`: 이름 변경 또는 파일 이동.
- **폴더/파일 삭제 및 읽기**:
  - `fs.readdir(경로)`: **Read Dir**ectory (폴더 안의 파일/폴더 목록을 배열로 반환)
  - `fs.unlink(경로)`: 파일 삭제 (링크 해제)
  - `fs.rmdir(경로)`: **R**e**m**ove **Dir**ectory (폴더 삭제, **단, 폴더가 비어있어야 함**)
- **파일 복사**:
  - `fs.copyFile(원본, 대상)`: `pipe()`보다 간단한 파일 복사 메서드.
- **파일/폴더 감시**:
  - `fs.watch(경로, (eventType, filename) => { ... })`: 파일/폴더의 변경 사항을 감시.
    - `eventType`: 'change'(내용 수정) 또는 'rename'(이름 변경/삭제)

### 3.6.4 스레드 풀 (Thread Pool) 알아보기

- **개념**: 노드는 **싱글 스레드**지만, 특정 작업(I/O, 암호화 등)은 **백그라운드에서 처리**한다고 했습니다. 이 '백그라운드'의 실체 중 하나가 바로 **'스레드 풀(Thread Pool)'** 입니다.
- **동작**:
  - 노드는 C++로 구현된 **libuv**라는 라이브러리를 사용합니다.
  - `fs.readFile`, `crypto.pbkdf2` 같은 무거운 C++ 작업 요청이 오면, 메인 스레드가 직접 처리하지 않고 **스레드 풀에 위임**합니다.
  - 스레드 풀은 기본적으로 **4개의 스레드**를 가지고 이 작업들을 동시에 처리합니다.
- **`crypto.pbkdf2` 8개 동시 실행 예제**:
  - 스레드 풀 크기가 4개이므로,
  - 1\~4번 작업이 4개 스레드에 할당되어 거의 동시에 끝납니다. (예: 약 1.6초)
  - 1\~4번 중 하나가 끝나면, 그 스레드가 5번 작업을 이어받습니다.
  - 5\~8번 작업은 1\~4번 작업이 끝난 후에야 시작되므로, 약 두 배의 시간이 걸립니다. (예: 약 3.5초)
- **스레드 풀 크기 조절**:
  - `UV_THREADPOOL_SIZE` 환경 변수로 스레드 풀의 개수를 조절할 수 있습니다.
  - (Windows) `SET UV_THREADPOOL_SIZE=8`
  - (mac/Linux) `UV_THREADPOOL_SIZE=8 node threadpool.js`
- **`worker_threads` (3.5.7)와의 차이 (⭐중요)**:
  - **스레드 풀**: **C++ 작업(I/O, crypto 등)** 을 처리. 자바스크립트 코드에서 직접 제어 불가.
  - **`worker_threads`**: **JavaScript 코드**를 병렬로 실행. 개발자가 직접 생성하고 제어.

# 4장 http 모듈로 서버 만들기

이 장에서는 드디어 `http` 모듈을 사용해 실제 동작하는 노드 서버를 만듭니다. 서버의 핵심 동작인 요청(Request)과 응답(Response)을 이해하고, **REST**라는 규칙에 따라 라우팅(Routing)을 구현하는 방법을 배웁니다.

## 4.1 요청과 응답 이해하기

서버는 클라이언트(웹 브라우저 등)의 요청(Request)을 받아 응답(Response)을 보내는 프로그램입니다. 노드는 이 기능을 `http` 모듈로 제공합니다.

### 서버 생성과 실행

1.  **`http.createServer(콜백함수)`**: 서버를 생성합니다.
2.  **`server.listen(포트번호, 콜백함수)`**: 생성된 서버를 특정 포트에서 "대기" 상태로 만듭니다.

<!-- end list -->

- `http.createServer`의 콜백 함수는 **요청이 올 때마다 매번 실행**되며, `req` (요청 정보)와 `res` (응답 객체)를 매개변수로 받습니다.
- **포트(Port)**: 서버 내에서 실행되는 여러 프로그램(프로세스)을 구분하기 위한 '창구 번호'입니다. (예: 8080, 8081)
  - **`localhost` (또는 `127.0.0.1`)**: '내 컴퓨터'를 의미하는 주소입니다.
  - `80` (HTTP) / `443` (HTTPS) 포트는 표준 포트라서 브라우저에서 주소 입력 시 생략할 수 있습니다.
  - 만약 `EADDRINUSE` 에러가 발생하면, 해당 포트를 다른 프로그램이 이미 사용 중이라는 뜻입니다.

**기본 서버 코드:**

```javascript
const http = require("http");

// 1. 서버 생성
const server = http.createServer((req, res) => {
  // 2. 응답 내용 작성 (요청이 올 때마다 실행됨)

  // (1) 헤더(Header) 작성: 응답의 메타데이터
  // HTTP 상태 코드 200 (성공), 콘텐츠 타입은 HTML, 한글 인코딩은 utf-8
  res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });

  // (2) 본문(Body) 작성: 실제 전송될 내용
  res.write("<h1>Hello Node!</h1>");

  // (3) 응답 완료 (필수!)
  res.end("<p>Hello Server!</p>");
});

// 3. 서버 실행 (8080번 포트에서 대기)
server.listen(8080, () => {
  console.log("8080번 포트에서 서버 대기 중입니다!");
});

// server.on('listening', ...), server.on('error', ...)로 이벤트 리스너를 등록할 수도 있습니다.
```

- `res.writeHead(상태코드, 헤더정보)`: 응답의 **헤더**를 보냅니다.
  - **HTTP 상태 코드**: 요청의 결과를 숫자로 알려줍니다.
    - `2XX`: 성공 (예: `200` OK, `201` Created)
    - `3XX`: 리다이렉션 (다른 주소로 이동)
    - `4XX`: 클라이언트 오류 (예: `400` Bad Request, `404` Not Found)
    - `5XX`: 서버 오류 (예: `500` Internal Server Error)
- `res.write(데이터)`: 응답의 **본문**을 보냅니다. (여러 번 호출 가능)
- `res.end(데이터)`: 응답을 **종료**합니다. (반드시 호출해야 함)

### HTML 파일로 응답하기

매번 `res.write`로 HTML을 쓰는 것은 비효율적이므로, `fs` 모듈로 `.html` 파일을 읽어 전송하는 것이 좋습니다.

```javascript
const http = require("http");
const fs = require("fs").promises; // 프로미스 기반 fs 사용

http
  .createServer(async (req, res) => {
    try {
      // 1. server2.html 파일을 읽음 (data는 Buffer)
      const data = await fs.readFile("./server2.html");

      // 2. 200 OK 헤더와 함께 파일 내용(data)을 전송
      res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
      res.end(data); // 버퍼(Buffer) 자체를 보낼 수 있음
    } catch (err) {
      // 3. 만약 파일 읽기 등에 실패하면 500 (서버 오류) 응답
      console.error(err);
      res.writeHead(500, { "Content-Type": "text/plain; charset=utf-8" });
      res.end(err.message);
    }
  })
  .listen(8081, () => {
    console.log("8081번 포트에서 서버 대기 중입니다!");
  });
```

> **⚠️ 중요**: 요청을 받았으면 **성공하든 실패하든 반드시 `res.end()`로 응답을 보내야 합니다.** 응답을 보내지 않으면 클라이언트는 응답이 올 때까지 무한정 기다리다 타임아웃(Time out) 됩니다.

## 4.2 REST와 라우팅 사용하기

지금까지의 서버는 `http://localhost:8081`로 접속하든, `http://localhost:8081/about`으로 접속하든 똑같은 `server2.html` 페이지만 보여줍니다.

라우팅(Routing)이란, 클라이언트의 요청 주소(URL)와 요청 메서드(Method)에 따라 서로 다른 응답을 하도록 "분기"하는 과정을 말합니다.

### REST (REpresentational State Transfer)

라우팅을 위한 "주소 설계 규칙" 또는 "스타일"입니다.

- **자원(Resource)**: 서버가 제공하는 데이터 (예: 사용자 정보, 게시글)
- **주소**: 자원을 식별하는 **명사** (예: `/users`, `/posts`)
- **메서드(Method)**: 자원에 수행할 **동사(행동)**

| HTTP 메서드 | 역할 (동사)                 | 예시 주소 (`/users` 자원)                     |
| :---------- | :-------------------------- | :-------------------------------------------- |
| **GET**     | 자원 **조회** (Read)        | `GET /users` (모든 사용자 조회)               |
| **POST**    | 자원 **생성** (Create)      | `POST /users` (새 사용자 등록)                |
| **PUT**     | 자원 **전체 수정** (Update) | `PUT /users/123` (123번 사용자 정보 덮어쓰기) |
| **PATCH**   | 자원 **일부 수정** (Update) | `PATCH /users/123` (123번 사용자 이름만 변경) |
| **DELETE**  | 자원 **삭제** (Delete)      | `DELETE /users/123` (123번 사용자 삭제)       |

RESTful한 서버는 주소와 메서드만 봐도 "무슨 작업을 하는지" 명확하게 알 수 있습니다.

### 라우팅 구현하기

`http.createServer`의 콜백 함수 안에서 `req.method`와 `req.url`을 `if / else if` 문으로 분기 처리합니다.

```javascript
const http = require("http");
const fs = require("fs").promises;
const path = require("path");

// 데이터베이스 대용 (메모리 저장이라 서버 끄면 유실됨)
const users = {};

http
  .createServer(async (req, res) => {
    try {
      console.log(req.method, req.url); // 요청 로그 확인

      // --- GET 요청 라우팅 ---
      if (req.method === "GET") {
        if (req.url === "/") {
          const data = await fs.readFile(
            path.join(__dirname, "restFront.html")
          );
          res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
          return res.end(data); // ⚠️ return으로 함수 종료
        } else if (req.url === "/about") {
          const data = await fs.readFile(path.join(__dirname, "about.html"));
          res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
          return res.end(data);
        } else if (req.url === "/users") {
          res.writeHead(200, {
            "Content-Type": "application/json; charset=utf-8",
          });
          return res.end(JSON.stringify(users)); // users 객체를 JSON 문자열로 변환해 응답
        }
        // 그 외 GET 요청 (CSS, JS 파일 등 정적 파일)
        try {
          const data = await fs.readFile(path.join(__dirname, req.url));
          return res.end(data);
        } catch (err) {
          // 해당 파일이 없으면 404 NOT FOUND 응답
        }
      }

      // --- POST 요청 라우팅 ---
      else if (req.method === "POST") {
        if (req.url === "/user") {
          let body = "";
          // (1) 요청 본문(body) 데이터를 'data' 이벤트로 조각조각 받음
          req.on("data", (data) => {
            body += data;
          });
          // (2) 'end' 이벤트: 데이터를 다 받았으면 실행
          return req.on("end", () => {
            console.log("POST 본문(Body):", body);
            const { name } = JSON.parse(body); // JSON 문자열을 객체로 파싱
            const id = Date.now();
            users[id] = name; // 새 사용자 등록
            res.writeHead(201, { "Content-Type": "text/plain; charset=utf-8" }); // 201: Created(생성됨)
            res.end("등록 성공");
          });
        }
      }

      // --- PUT 요청 라우팅 ---
      else if (req.method === "PUT") {
        if (req.url.startsWith("/user/")) {
          const key = req.url.split("/")[2]; // URL에서 사용자 ID(key) 추출
          let body = "";
          req.on("data", (data) => {
            body += data;
          });
          return req.on("end", () => {
            console.log("PUT 본문(Body):", body);
            users[key] = JSON.parse(body).name; // 해당 ID의 사용자 이름 수정
            res.writeHead(200, {
              "Content-Type": "application/json; charset=utf-8",
            });
            return res.end(JSON.stringify(users));
          });
        }
      }

      // --- DELETE 요청 라우팅 ---
      else if (req.method === "DELETE") {
        if (req.url.startsWith("/user/")) {
          const key = req.url.split("/")[2];
          delete users[key]; // 해당 ID의 사용자 삭제
          res.writeHead(200, {
            "Content-Type": "application/json; charset=utf-8",
          });
          return res.end(JSON.stringify(users));
        }
      }

      // --- 해당하는 라우트가 없는 경우 ---
      res.writeHead(404);
      return res.end("NOT FOUND");
    } catch (err) {
      // --- 서버 자체 에러 처리 ---
      console.error(err);
      res.writeHead(500, { "Content-Type": "text/plain; charset=utf-8" });
      res.end(err.message);
    }
  })
  .listen(8082, () => {
    console.log("8082번 포트에서 서버 대기 중입니다");
  });
```

#### `POST`, `PUT` 요청 본문(Body) 처리

- `GET`과 달리 `POST`나 `PUT`은 데이터를 본문(Body)에 실어 보냅니다.
- `req` 객체는 스트림(Stream)이므로, 본문 데이터가 **조각(chunk)으로 나뉘어** 들어옵니다.
- `req.on('data', 콜백)`: 데이터 조각이 도착할 때마다 콜백이 실행됩니다.
- `req.on('end', 콜백)`: 데이터 조각을 모두 받으면 콜백이 실행됩니다.
- 따라서 `body` 변수에 조각들을 계속 이어붙인(`body += data`) 뒤, `end` 이벤트가 발생했을 때 `JSON.parse(body)`를 통해 완전한 데이터를 사용할 수 있습니다.

> **💡 `return res.end()`를 쓰는 이유** > `res.end()`는 응답을 종료할 뿐, 함수 실행을 멈추지 않습니다. 만약 `return` 없이 `res.end()`를 호출하면, 그 아래에 있는 다른 `res.end()` 코드가 실행될 수 있습니다. 응답을 두 번 보내려 하면 "headers already sent" 에러가 발생하므로, `return`을 붙여 함수를 명시적으로 종료시키는 것이 안전합니다.

## 4.3 쿠키와 세션 이해하기 (⭐ 매우 중요)

### 1\. 문제점: HTTP는 "Stateless"하다

HTTP 프로토콜은 **상태가 없습니다(Stateless)**.
즉, 서버는 방금 요청을 보낸 유저가 1초 전에 요청을 보낸 유저와 같은 사람인지 **전혀 알지 못합니다.** 새로고침만 해도 서버는 유저를 "처음 보는 사람"으로 취급합니다.

이 문제를 해결하고 "로그인 상태 유지" 같은 기능을 구현하기 위해 **쿠키**와 **세션**을 사용합니다.

### 2\. 쿠키 (Cookie) 🍪

- **개념**: 서버가 클라이언트(브라우저)에 저장하는 `키=값` 형태의 작은 데이터 조각입니다.

- **동작 방식**:

  1.  **서버가 보냄**: 서버가 응답(Response) 헤더에 `Set-Cookie`를 담아 보냅니다.
      - `res.writeHead(200, {'Set-Cookie': 'mycookie=test'});`
  2.  **브라우저가 저장**: 브라우저는 이 쿠키를 자동으로 저장합니다.
  3.  **브라우저가 다시 보냄**: 이후 해당 서버에 \*\*모든 요청(Request)\*\*을 보낼 때마다, 브라우저는 **자동으로** 저장된 쿠키를 요청 헤더(`Cookie`)에 담아 보냅니다.
  4.  **서버가 읽음**: 서버는 `req.headers.cookie`를 읽어 "아, 이 유저가 아까 그 유저구나\!"라고 식별합니다.

- **쿠키 옵션 (중요\!)**: `Set-Cookie` 헤더에 `key=value` 외에 세미콜론(`;`)으로 구분해 추가 옵션을 설정할 수 있습니다.

  - `Expires=날짜`: 쿠키 만료 날짜. (이 시간이 지나면 자동 삭제)
  - `Max-age=초`: 쿠키 수명 (Expires보다 우선)
  - `HttpOnly`: **(보안 필수)** `true`로 설정 시, 자바스크립트(`document.cookie`)로 쿠키에 접근하는 것을 막아줍니다. XSS 공격으로 쿠키를 탈취당하는 것을 방지합니다.
  - `Path=/`: `/` 하위의 모든 주소에서 이 쿠키를 사용하겠다는 의미. (거의 항상 `/`로 설정)
  - `Secure`: HTTPS 프로토콜일 때만 쿠키를 전송합니다.
  - **주의**: 쿠키 값에 한글이나 특수문자가 들어간다면 `encodeURIComponent`로 인코딩해야 합니다.

### 3\. 세션 (Session) 🔐

`cookie2.js` 예제(책 전반부)처럼, 사용자의 이름(`name=zerocho`) 같은 **민감한 정보를 쿠키에 직접 저장하는 것은 매우 위험**합니다. 쿠키는 브라우저에 그대로 노출되고 조작될 수 있기 때문입니다.

**세션**은 이 문제를 해결하는 "더 안전한 방식"입니다.

- **개념**: 민감한 유저 정보는 **서버 측(메모리, DB 등)에 저장**하고, 클라이언트(브라우저)에게는 \*\*"세션 ID"\*\*라는 임의의 긴 문자열(열쇠)만 쿠키로 주는 방식입니다.
- **동작 방식 (session.js 예제)**:
  1.  **(로그인 시)**
      - 유저가 이름(`name`)을 보내면, 서버는 이 정보를 `session`이라는 **서버 측 객체**에 저장합니다.
      - 이때 `Date.now()`(타임스탬프) 같은 고유한 키(예: `167888999000`)를 **세션 ID**로 사용합니다.
      - `session[167888999000] = { name: 'zerocho', expires: '...' };` (서버 메모리에 저장)
  2.  **(응답)**
      - 서버는 클라이언트에게 `Set-Cookie: session=167888999000; ...` (세션 ID)만 쿠키로 보냅니다. 클라이언트는 'zerocho'라는 이름을 전혀 알 수 없습니다.
  3.  **(다음 요청 시)**
      - 브라우저는 `Cookie: session=167888999000` (세션 ID 쿠키)를 서버에 보냅니다.
  4.  **(서버 검증)**
      - 서버는 `cookies.session` 값(`167888999000`)을 받습니다.
      - 서버의 `session` 객체에서 `session[167888999000]`이 있는지, 만료되진 않았는지 확인합니다.
      - 유효하다면, 서버는 `session[167888999000].name` (즉, 'zerocho')을 꺼내 "zerocho님 안녕하세요"라고 응답합니다.
- **요약**:
  - **클라이언트 (브라우저)**: "세션 ID (열쇠)"만 쿠키에 보관.
  - **서버**: "세션 ID"와 "실제 유저 정보"의 매핑 테이블(세션 저장소)을 보관.
- **한계**: 예제처럼 `session` 객체를 서버 메모리(변수)에 저장하면, \*\*서버를 껐다 켜면 모든 로그인 정보가 유실(소실)\*\*됩니다. 실무에서는 이 세션 저장소로 **Redis** 같은 별도의 DB를 사용합니다.

## 4.4 https와 http2

### 1\. https (HTTP Secure)

- **개념**: `http` 모듈에 **SSL 암호화**가 추가된 버전입니다. (`http` + `SSL` = `https`)
- **왜 쓰나요?**: `http`는 모든 데이터를 텍스트 그대로 주고받기 때문에, 중간에 해커가 가로채면(스니핑) 아이디, 비번, 카드 정보 등을 그대로 볼 수 있습니다. `https`는 이 모든 데이터를 **암호화**하여 전송합니다.
- **필요한 것**: **SSL 인증서** (CA라는 인증 기관에서 발급받아야 함. 예: Let's Encrypt - 무료)
- **사용법**:
  - `https` 모듈을 사용합니다.
  - `https.createServer(options, (req, res) => { ... })`
  - `options` 객체에 `fs.readFileSync`로 읽어온 인증서 파일(`cert`, `key`, `ca`) 경로를 넣어줘야 합니다.
  - 기본 포트는 `80`이 아닌 \*\*`443`\*\*입니다. (브라우저에서 생략 가능)

### 2\. http2

- **개념**: HTTP/1.1 (기존 버전)보다 훨씬 **빠르고 효율적인** 최신 HTTP 프로토콜입니다.
- **특징**: 하나의 연결로 여러 요청/응답을 동시에 처리(Multiplexing)하여 속도 저하를 크게 개선합니다.
- **사용법**:
  - `http2` 모듈을 사용합니다.
  - `http2.createSecureServer(options, (req, res) => { ... })`
  - `https`와 마찬가지로 **SSL 인증서(`options`)가 필수**입니다.

## 4.5 cluster (클러스터)

### 1\. 문제점: 노드는 싱글 스레드다

노드는 기본적으로 **싱글 스레드**로 동작합니다.
이는 서버의 CPU 코어가 8개, 16개여도 노드 프로세스는 **단 1개의 코어만 사용**한다는 뜻입니다. 나머지 코어는 모두 놀게 되어, 서버의 자원을 낭비하게 됩니다.

### 2\. 해결책: `cluster` 모듈 (멀티 프로세스)

- **개념**: `cluster` 모듈은 **하나의 포트를 공유**하는 **여러 개의 노드 프로세스**를 생성하여 CPU 코어를 모두 활용하게 해줍니다.
- **동작 방식 (Master-Worker 모델)**:
  - **마스터 프로세스 (cluster.isMaster)**
    - 코드가 처음 실행될 때 진입하는 "대장" 프로세스입니다.
    - `http.createServer` (서버 로직)를 실행하지 **않습니다.**
    - `os.cpus().length` (CPU 코어 개수)만큼 `cluster.fork()`를 호출하여 **워커 프로세스를 생성**합니다.
    - 워커들을 관리/감독합니다.
  - **워커 프로세스 (else ...)**
    - `cluster.fork()`로 생성된 "일꾼" 프로세스들입니다.
    - **실제 서버 로직(`http.createServer ... listen()`)을 수행**합니다.
    - 여러 워커가 **하나의 포트(예: 8086)를 공유**할 수 있으며, 마스터가 알아서 들어오는 요청을 워커들에게 분배(Load Balancing)합니다.

<!-- end list -->

```javascript
const cluster = require("cluster");
const http = require("http");
const numCPUs = require("os").cpus().length; // CPU 코어 개수

// 마스터 프로세스일 때
if (cluster.isMaster) {
  console.log(`마스터 프로세스 아이디: ${process.pid}`);
  // CPU 개수만큼 워커 생성
  for (let i = 0; i < numCPUs; i += 1) {
    cluster.fork();
  }

  // 워커가 죽었을 때 (Fault Tolerance)
  cluster.on("exit", (worker, code, signal) => {
    console.log(`${worker.process.pid}번 워커가 종료되었습니다.`);
    console.log("새로운 워커를 생성합니다.");
    cluster.fork(); // 죽으면 바로 하나 새로 생성
  });
}
// 워커 프로세스일 때
else {
  // 8086 포트에서 서버 실행
  http
    .createServer((req, res) => {
      // ... (서버 로직) ...
      res.end("<p>Hello Cluster!</p>");
    })
    .listen(8086);

  console.log(`${process.pid}번 워커 실행`);
}
```

- **장점**:
  1.  **성능 향상**: CPU 코어를 모두 사용하므로 서버가 처리할 수 있는 요청 수가 대폭 증가합니다.
  2.  **안정성 (Fault Tolerance)**: 워커 하나가 예기치 못한 에러로 죽어도, 마스터 프로세스가 이를 감지하고 새 워커를 즉시 생성합니다. 다른 워커들은 계속 정상 동작하므로 **서버가 다운되지 않습니다.**
- **단점 (중요)**:
  - 프로세스 간 **메모리를 공유하지 않습니다.**
  - `session.js`의 `session = {}` 객체는 각 워커마다 **따로** 생깁니다. 즉, A 워커에서 로그인해도, 다음 요청이 B 워커로 가면 로그인이 안 된 상태가 됩니다.
  - **해결**: 세션 같은 공유 데이터는 `Redis` 같은 **외부 데이터베이스**에 저장해야 합니다.
- **실무**: `cluster`를 직접 구현하기보다, `pm2` 같은 프로세스 매니저 모듈을 사용하면 이 기능(클러스터링, 워커 재시작)을 더 쉽게 관리할 수 있습니다. (15장)
